Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> read
Rule 12    statute -> write
Rule 13    statute -> cycle
Rule 14    statute -> repeat
Rule 15    statute -> command
Rule 16    statute -> calling
Rule 17    statute -> array
Rule 18    statute -> matrix
Rule 19    statute -> random
Rule 20    statute -> return
Rule 21    typeMod -> INT
Rule 22    typeMod -> FLOAT
Rule 23    typeMod -> BOOL
Rule 24    typeMod -> empty
Rule 25    addMod -> <empty>
Rule 26    module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
Rule 27    moduleA -> ( vars ) block
Rule 28    moduleA -> block
Rule 29    moduleID -> ID
Rule 30    vars -> type ID varsA
Rule 31    varsA -> , vars
Rule 32    varsA -> empty
Rule 33    type -> INT
Rule 34    type -> FLOAT
Rule 35    type -> BOOL
Rule 36    id -> ID initdim [ sumdim exp ] [ sumdim exp ]
Rule 37    id -> ID initdim [ sumdim exp ]
Rule 38    id -> callID initdim # calling2
Rule 39    id -> ID initdim empty
Rule 40    initdim -> <empty>
Rule 41    sumdim -> <empty>
Rule 42    calling -> # callID calling2 ;
Rule 43    calling2 -> ( maincalling )
Rule 44    maincalling -> insertEra callingA
Rule 45    callID -> ID
Rule 46    insertEra -> <empty>
Rule 47    callingA -> callingB
Rule 48    callingA -> empty
Rule 49    callingB -> exp checkParam callingC
Rule 50    checkParam -> <empty>
Rule 51    callingC -> , sumXparam callingB
Rule 52    callingC -> empty
Rule 53    sumXparam -> <empty>
Rule 54    block -> { blockA
Rule 55    blockA -> blockB }
Rule 56    blockA -> }
Rule 57    blockB -> statute blockC
Rule 58    blockC -> blockB
Rule 59    blockC -> empty
Rule 60    assign -> id = expression ;
Rule 61    condition -> IF ( expression ) gotoFalse block conditionA continueGo
Rule 62    conditionA -> ELSE gotoE block
Rule 63    conditionA -> empty
Rule 64    random -> RAND typeRand ID CTE_INTEGER ;
Rule 65    typeRand -> INT
Rule 66    typeRand -> FLOAT
Rule 67    read -> INPUT typeDim ID # ;
Rule 68    write -> ECHO ( writeA writeB ) ;
Rule 69    writeA -> expression
Rule 70    writeA -> CTE_STRING
Rule 71    writeB -> , writeA
Rule 72    writeB -> empty
Rule 73    array -> ARR typeDim ID [ CTE_INTEGER ] ;
Rule 74    matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
Rule 75    typeDim -> INT
Rule 76    typeDim -> FLOAT
Rule 77    typeDim -> BOOL
Rule 78    command -> figure exp exp color ;
Rule 79    command -> SAMPLE commandA
Rule 80    commandA -> ON move exp CTE_INTEGER color ;
Rule 81    commandA -> OFF move exp ;
Rule 82    cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW
Rule 83    repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ;
Rule 84    repeatA -> command repeatB
Rule 85    repeatB -> repeatA
Rule 86    repeatB -> empty
Rule 87    expression -> exp = = exp
Rule 88    expression -> exp < > exp
Rule 89    expression -> exp < = exp
Rule 90    expression -> exp > = exp
Rule 91    expression -> exp > exp
Rule 92    expression -> exp < exp
Rule 93    expression -> exp AND exp
Rule 94    expression -> exp OR exp
Rule 95    expression -> exp empty
Rule 96    exp -> exp + exp
Rule 97    exp -> exp - exp
Rule 98    exp -> exp * exp
Rule 99    exp -> exp / exp
Rule 100   exp -> factor empty
Rule 101   return -> RETURN exp ;
Rule 102   factor -> ( expression )
Rule 103   factor -> var_cte
Rule 104   figure -> OVAL
Rule 105   figure -> TRIO
Rule 106   figure -> QUAD
Rule 107   figure -> ARC
Rule 108   move -> UP
Rule 109   move -> DOWN
Rule 110   move -> LEFT
Rule 111   move -> RIGHT
Rule 112   color -> RED
Rule 113   color -> YELLOW
Rule 114   color -> BLUE
Rule 115   color -> GREEN
Rule 116   color -> BLACK
Rule 117   color -> WHITE
Rule 118   color -> ORANGE
Rule 119   color -> PURPLE
Rule 120   color -> CYAN
Rule 121   var_cte -> id
Rule 122   var_cte -> CTE_INTEGER
Rule 123   var_cte -> CTE_FLOAT
Rule 124   var_cte -> TRUE
Rule 125   var_cte -> FALSE
Rule 126   gotoFalse -> <empty>
Rule 127   gotoE -> <empty>
Rule 128   gotoW -> <empty>
Rule 129   gotoR -> <empty>
Rule 130   continueGo -> <empty>
Rule 131   continueGoW -> <empty>
Rule 132   insertQuadMod -> <empty>
Rule 133   endMod -> <empty>
Rule 134   empty -> <empty>

Terminals, with rules where they appear

#                    : 26 38 42 67
(                    : 27 43 61 68 82 102
)                    : 27 43 61 68 82 102
*                    : 98
+                    : 96
,                    : 31 51 71
-                    : 97
/                    : 99
;                    : 42 60 64 67 68 73 74 78 80 81 83 101
<                    : 88 89 92
=                    : 60 87 87 89 90
>                    : 88 90 91
AND                  : 93
ARC                  : 107
ARR                  : 73
BLACK                : 116
BLUE                 : 114
BOOL                 : 23 35 77
CTE_FLOAT            : 123
CTE_INTEGER          : 64 73 74 74 80 83 122
CTE_STRING           : 70
CYAN                 : 120
DOWN                 : 109
ECHO                 : 68
ELSE                 : 62
END                  : 2 3
FALSE                : 125
FLOAT                : 22 34 66 76
GREEN                : 115
ID                   : 29 30 36 37 39 45 64 67 73 74
IF                   : 61
INIT                 : 1
INPUT                : 67
INT                  : 21 33 65 75
LEFT                 : 110
MAT                  : 74
MOD                  : 26
OFF                  : 81
ON                   : 80
OR                   : 94
ORANGE               : 118
OVAL                 : 104
PURPLE               : 119
QUAD                 : 106
RAND                 : 64
RED                  : 112
REPLAY               : 83
RETURN               : 101
RIGHT                : 111
SAMPLE               : 79
TRIO                 : 105
TRUE                 : 124
UP                   : 108
WHILE                : 82
WHITE                : 117
YELLOW               : 113
[                    : 36 36 37 73 74 74 83
]                    : 36 36 37 73 74 74 83
error                : 
{                    : 54
}                    : 55 56

Nonterminals, with rules where they appear

addMod               : 26
array                : 17
assign               : 9
block                : 27 28 61 62 82
blockA               : 54
blockB               : 55 58
blockC               : 57
callID               : 38 42
calling              : 16
calling2             : 38 42
callingA             : 44
callingB             : 47 51
callingC             : 49
checkParam           : 49
color                : 78 80
command              : 15 84
commandA             : 79
condition            : 10
conditionA           : 61
continueGo           : 61
continueGoW          : 82
cycle                : 13
empty                : 6 24 32 39 48 52 59 63 72 86 95 100
endMod               : 26
exp                  : 36 36 37 49 78 78 80 81 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 96 96 97 97 98 98 99 99 101
expression           : 60 61 69 82 102
factor               : 100
figure               : 78
gotoE                : 62
gotoFalse            : 61 82
gotoR                : 83
gotoW                : 82
id                   : 60 121
initdim              : 36 37 38 39
insertEra            : 44
insertQuadMod        : 26
maincalling          : 43
matrix               : 18
module               : 8
moduleA              : 26
moduleID             : 26
move                 : 80 81
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
random               : 19
read                 : 11
repeat               : 14
repeatA              : 83 85
repeatB              : 84
return               : 20
statute              : 7 57
sumXparam            : 51
sumdim               : 36 36 37
type                 : 30
typeDim              : 67 73 74
typeMod              : 26
typeRand             : 64
var_cte              : 103
vars                 : 27 31
varsA                : 30
workspace            : 4
write                : 12
writeA               : 68 71
writeB               : 68

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . random
    (20) statute -> . return
    (26) module -> . MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
    (60) assign -> . id = expression ;
    (61) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (67) read -> . INPUT typeDim ID # ;
    (68) write -> . ECHO ( writeA writeB ) ;
    (82) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (83) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (78) command -> . figure exp exp color ;
    (79) command -> . SAMPLE commandA
    (42) calling -> . # callID calling2 ;
    (73) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (74) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (64) random -> . RAND typeRand ID CTE_INTEGER ;
    (101) return -> . RETURN exp ;
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (104) figure -> . OVAL
    (105) figure -> . TRIO
    (106) figure -> . QUAD
    (107) figure -> . ARC
    (45) callID -> . ID

    END             shift and go to state 22
    MOD             shift and go to state 40
    IF              shift and go to state 19
    INPUT           shift and go to state 28
    ECHO            shift and go to state 24
    WHILE           shift and go to state 10
    REPLAY          shift and go to state 11
    SAMPLE          shift and go to state 25
    #               shift and go to state 16
    ARR             shift and go to state 33
    MAT             shift and go to state 34
    RAND            shift and go to state 3
    RETURN          shift and go to state 4
    ID              shift and go to state 29
    OVAL            shift and go to state 9
    TRIO            shift and go to state 20
    QUAD            shift and go to state 12
    ARC             shift and go to state 36

    figure                         shift and go to state 5
    callID                         shift and go to state 6
    random                         shift and go to state 7
    module                         shift and go to state 8
    array                          shift and go to state 14
    id                             shift and go to state 15
    matrix                         shift and go to state 17
    write                          shift and go to state 18
    repeat                         shift and go to state 21
    return                         shift and go to state 13
    read                           shift and go to state 23
    programA                       shift and go to state 26
    programB                       shift and go to state 27
    condition                      shift and go to state 30
    cycle                          shift and go to state 31
    statute                        shift and go to state 32
    calling                        shift and go to state 35
    command                        shift and go to state 37
    workspace                      shift and go to state 38
    assign                         shift and go to state 39

state 2

    (0) S' -> program .



state 3

    (64) random -> RAND . typeRand ID CTE_INTEGER ;
    (65) typeRand -> . INT
    (66) typeRand -> . FLOAT

    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    typeRand                       shift and go to state 41

state 4

    (101) return -> RETURN . exp ;
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 52
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 5

    (78) command -> figure . exp exp color ;
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 53
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 6

    (38) id -> callID . initdim # calling2
    (40) initdim -> .

    #               reduce using rule 40 (initdim -> .)

    initdim                        shift and go to state 54

state 7

    (19) statute -> random .

    MOD             reduce using rule 19 (statute -> random .)
    IF              reduce using rule 19 (statute -> random .)
    INPUT           reduce using rule 19 (statute -> random .)
    ECHO            reduce using rule 19 (statute -> random .)
    WHILE           reduce using rule 19 (statute -> random .)
    REPLAY          reduce using rule 19 (statute -> random .)
    SAMPLE          reduce using rule 19 (statute -> random .)
    #               reduce using rule 19 (statute -> random .)
    ARR             reduce using rule 19 (statute -> random .)
    MAT             reduce using rule 19 (statute -> random .)
    RAND            reduce using rule 19 (statute -> random .)
    RETURN          reduce using rule 19 (statute -> random .)
    ID              reduce using rule 19 (statute -> random .)
    OVAL            reduce using rule 19 (statute -> random .)
    TRIO            reduce using rule 19 (statute -> random .)
    QUAD            reduce using rule 19 (statute -> random .)
    ARC             reduce using rule 19 (statute -> random .)
    END             reduce using rule 19 (statute -> random .)
    }               reduce using rule 19 (statute -> random .)


state 8

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    INPUT           reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    WHILE           reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    ARR             reduce using rule 8 (workspace -> module .)
    MAT             reduce using rule 8 (workspace -> module .)
    RAND            reduce using rule 8 (workspace -> module .)
    RETURN          reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 9

    (104) figure -> OVAL .

    (               reduce using rule 104 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 104 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 104 (figure -> OVAL .)
    TRUE            reduce using rule 104 (figure -> OVAL .)
    FALSE           reduce using rule 104 (figure -> OVAL .)
    ID              reduce using rule 104 (figure -> OVAL .)


state 10

    (82) cycle -> WHILE . gotoW ( expression ) gotoFalse block continueGoW
    (128) gotoW -> .

    (               reduce using rule 128 (gotoW -> .)

    gotoW                          shift and go to state 55

state 11

    (83) repeat -> REPLAY . CTE_INTEGER gotoR [ repeatA ] ;

    CTE_INTEGER     shift and go to state 56


state 12

    (106) figure -> QUAD .

    (               reduce using rule 106 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 106 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 106 (figure -> QUAD .)
    TRUE            reduce using rule 106 (figure -> QUAD .)
    FALSE           reduce using rule 106 (figure -> QUAD .)
    ID              reduce using rule 106 (figure -> QUAD .)


state 13

    (20) statute -> return .

    MOD             reduce using rule 20 (statute -> return .)
    IF              reduce using rule 20 (statute -> return .)
    INPUT           reduce using rule 20 (statute -> return .)
    ECHO            reduce using rule 20 (statute -> return .)
    WHILE           reduce using rule 20 (statute -> return .)
    REPLAY          reduce using rule 20 (statute -> return .)
    SAMPLE          reduce using rule 20 (statute -> return .)
    #               reduce using rule 20 (statute -> return .)
    ARR             reduce using rule 20 (statute -> return .)
    MAT             reduce using rule 20 (statute -> return .)
    RAND            reduce using rule 20 (statute -> return .)
    RETURN          reduce using rule 20 (statute -> return .)
    ID              reduce using rule 20 (statute -> return .)
    OVAL            reduce using rule 20 (statute -> return .)
    TRIO            reduce using rule 20 (statute -> return .)
    QUAD            reduce using rule 20 (statute -> return .)
    ARC             reduce using rule 20 (statute -> return .)
    END             reduce using rule 20 (statute -> return .)
    }               reduce using rule 20 (statute -> return .)


state 14

    (17) statute -> array .

    MOD             reduce using rule 17 (statute -> array .)
    IF              reduce using rule 17 (statute -> array .)
    INPUT           reduce using rule 17 (statute -> array .)
    ECHO            reduce using rule 17 (statute -> array .)
    WHILE           reduce using rule 17 (statute -> array .)
    REPLAY          reduce using rule 17 (statute -> array .)
    SAMPLE          reduce using rule 17 (statute -> array .)
    #               reduce using rule 17 (statute -> array .)
    ARR             reduce using rule 17 (statute -> array .)
    MAT             reduce using rule 17 (statute -> array .)
    RAND            reduce using rule 17 (statute -> array .)
    RETURN          reduce using rule 17 (statute -> array .)
    ID              reduce using rule 17 (statute -> array .)
    OVAL            reduce using rule 17 (statute -> array .)
    TRIO            reduce using rule 17 (statute -> array .)
    QUAD            reduce using rule 17 (statute -> array .)
    ARC             reduce using rule 17 (statute -> array .)
    END             reduce using rule 17 (statute -> array .)
    }               reduce using rule 17 (statute -> array .)


state 15

    (60) assign -> id . = expression ;

    =               shift and go to state 57


state 16

    (42) calling -> # . callID calling2 ;
    (45) callID -> . ID

    ID              shift and go to state 59

    callID                         shift and go to state 58

state 17

    (18) statute -> matrix .

    MOD             reduce using rule 18 (statute -> matrix .)
    IF              reduce using rule 18 (statute -> matrix .)
    INPUT           reduce using rule 18 (statute -> matrix .)
    ECHO            reduce using rule 18 (statute -> matrix .)
    WHILE           reduce using rule 18 (statute -> matrix .)
    REPLAY          reduce using rule 18 (statute -> matrix .)
    SAMPLE          reduce using rule 18 (statute -> matrix .)
    #               reduce using rule 18 (statute -> matrix .)
    ARR             reduce using rule 18 (statute -> matrix .)
    MAT             reduce using rule 18 (statute -> matrix .)
    RAND            reduce using rule 18 (statute -> matrix .)
    RETURN          reduce using rule 18 (statute -> matrix .)
    ID              reduce using rule 18 (statute -> matrix .)
    OVAL            reduce using rule 18 (statute -> matrix .)
    TRIO            reduce using rule 18 (statute -> matrix .)
    QUAD            reduce using rule 18 (statute -> matrix .)
    ARC             reduce using rule 18 (statute -> matrix .)
    END             reduce using rule 18 (statute -> matrix .)
    }               reduce using rule 18 (statute -> matrix .)


state 18

    (12) statute -> write .

    MOD             reduce using rule 12 (statute -> write .)
    IF              reduce using rule 12 (statute -> write .)
    INPUT           reduce using rule 12 (statute -> write .)
    ECHO            reduce using rule 12 (statute -> write .)
    WHILE           reduce using rule 12 (statute -> write .)
    REPLAY          reduce using rule 12 (statute -> write .)
    SAMPLE          reduce using rule 12 (statute -> write .)
    #               reduce using rule 12 (statute -> write .)
    ARR             reduce using rule 12 (statute -> write .)
    MAT             reduce using rule 12 (statute -> write .)
    RAND            reduce using rule 12 (statute -> write .)
    RETURN          reduce using rule 12 (statute -> write .)
    ID              reduce using rule 12 (statute -> write .)
    OVAL            reduce using rule 12 (statute -> write .)
    TRIO            reduce using rule 12 (statute -> write .)
    QUAD            reduce using rule 12 (statute -> write .)
    ARC             reduce using rule 12 (statute -> write .)
    END             reduce using rule 12 (statute -> write .)
    }               reduce using rule 12 (statute -> write .)


state 19

    (61) condition -> IF . ( expression ) gotoFalse block conditionA continueGo

    (               shift and go to state 60


state 20

    (105) figure -> TRIO .

    (               reduce using rule 105 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 105 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 105 (figure -> TRIO .)
    TRUE            reduce using rule 105 (figure -> TRIO .)
    FALSE           reduce using rule 105 (figure -> TRIO .)
    ID              reduce using rule 105 (figure -> TRIO .)


state 21

    (14) statute -> repeat .

    MOD             reduce using rule 14 (statute -> repeat .)
    IF              reduce using rule 14 (statute -> repeat .)
    INPUT           reduce using rule 14 (statute -> repeat .)
    ECHO            reduce using rule 14 (statute -> repeat .)
    WHILE           reduce using rule 14 (statute -> repeat .)
    REPLAY          reduce using rule 14 (statute -> repeat .)
    SAMPLE          reduce using rule 14 (statute -> repeat .)
    #               reduce using rule 14 (statute -> repeat .)
    ARR             reduce using rule 14 (statute -> repeat .)
    MAT             reduce using rule 14 (statute -> repeat .)
    RAND            reduce using rule 14 (statute -> repeat .)
    RETURN          reduce using rule 14 (statute -> repeat .)
    ID              reduce using rule 14 (statute -> repeat .)
    OVAL            reduce using rule 14 (statute -> repeat .)
    TRIO            reduce using rule 14 (statute -> repeat .)
    QUAD            reduce using rule 14 (statute -> repeat .)
    ARC             reduce using rule 14 (statute -> repeat .)
    END             reduce using rule 14 (statute -> repeat .)
    }               reduce using rule 14 (statute -> repeat .)


state 22

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 23

    (11) statute -> read .

    MOD             reduce using rule 11 (statute -> read .)
    IF              reduce using rule 11 (statute -> read .)
    INPUT           reduce using rule 11 (statute -> read .)
    ECHO            reduce using rule 11 (statute -> read .)
    WHILE           reduce using rule 11 (statute -> read .)
    REPLAY          reduce using rule 11 (statute -> read .)
    SAMPLE          reduce using rule 11 (statute -> read .)
    #               reduce using rule 11 (statute -> read .)
    ARR             reduce using rule 11 (statute -> read .)
    MAT             reduce using rule 11 (statute -> read .)
    RAND            reduce using rule 11 (statute -> read .)
    RETURN          reduce using rule 11 (statute -> read .)
    ID              reduce using rule 11 (statute -> read .)
    OVAL            reduce using rule 11 (statute -> read .)
    TRIO            reduce using rule 11 (statute -> read .)
    QUAD            reduce using rule 11 (statute -> read .)
    ARC             reduce using rule 11 (statute -> read .)
    END             reduce using rule 11 (statute -> read .)
    }               reduce using rule 11 (statute -> read .)


state 24

    (68) write -> ECHO . ( writeA writeB ) ;

    (               shift and go to state 61


state 25

    (79) command -> SAMPLE . commandA
    (80) commandA -> . ON move exp CTE_INTEGER color ;
    (81) commandA -> . OFF move exp ;

    ON              shift and go to state 64
    OFF             shift and go to state 63

    commandA                       shift and go to state 62

state 26

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 27

    (2) programA -> programB . END

    END             shift and go to state 65


state 28

    (67) read -> INPUT . typeDim ID # ;
    (75) typeDim -> . INT
    (76) typeDim -> . FLOAT
    (77) typeDim -> . BOOL

    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 69

    typeDim                        shift and go to state 68

state 29

    (36) id -> ID . initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> ID . initdim [ sumdim exp ]
    (39) id -> ID . initdim empty
    (45) callID -> ID .
    (40) initdim -> .

    #               reduce using rule 45 (callID -> ID .)
    [               reduce using rule 40 (initdim -> .)
    =               reduce using rule 40 (initdim -> .)
    ;               reduce using rule 40 (initdim -> .)
    +               reduce using rule 40 (initdim -> .)
    -               reduce using rule 40 (initdim -> .)
    *               reduce using rule 40 (initdim -> .)
    /               reduce using rule 40 (initdim -> .)
    (               reduce using rule 40 (initdim -> .)
    CTE_INTEGER     reduce using rule 40 (initdim -> .)
    CTE_FLOAT       reduce using rule 40 (initdim -> .)
    TRUE            reduce using rule 40 (initdim -> .)
    FALSE           reduce using rule 40 (initdim -> .)
    ID              reduce using rule 40 (initdim -> .)
    <               reduce using rule 40 (initdim -> .)
    >               reduce using rule 40 (initdim -> .)
    AND             reduce using rule 40 (initdim -> .)
    OR              reduce using rule 40 (initdim -> .)
    )               reduce using rule 40 (initdim -> .)
    RED             reduce using rule 40 (initdim -> .)
    YELLOW          reduce using rule 40 (initdim -> .)
    BLUE            reduce using rule 40 (initdim -> .)
    GREEN           reduce using rule 40 (initdim -> .)
    BLACK           reduce using rule 40 (initdim -> .)
    WHITE           reduce using rule 40 (initdim -> .)
    ORANGE          reduce using rule 40 (initdim -> .)
    PURPLE          reduce using rule 40 (initdim -> .)
    CYAN            reduce using rule 40 (initdim -> .)
    ,               reduce using rule 40 (initdim -> .)
    ]               reduce using rule 40 (initdim -> .)

    initdim                        shift and go to state 70

state 30

    (10) statute -> condition .

    MOD             reduce using rule 10 (statute -> condition .)
    IF              reduce using rule 10 (statute -> condition .)
    INPUT           reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    WHILE           reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    ARR             reduce using rule 10 (statute -> condition .)
    MAT             reduce using rule 10 (statute -> condition .)
    RAND            reduce using rule 10 (statute -> condition .)
    RETURN          reduce using rule 10 (statute -> condition .)
    ID              reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)


state 31

    (13) statute -> cycle .

    MOD             reduce using rule 13 (statute -> cycle .)
    IF              reduce using rule 13 (statute -> cycle .)
    INPUT           reduce using rule 13 (statute -> cycle .)
    ECHO            reduce using rule 13 (statute -> cycle .)
    WHILE           reduce using rule 13 (statute -> cycle .)
    REPLAY          reduce using rule 13 (statute -> cycle .)
    SAMPLE          reduce using rule 13 (statute -> cycle .)
    #               reduce using rule 13 (statute -> cycle .)
    ARR             reduce using rule 13 (statute -> cycle .)
    MAT             reduce using rule 13 (statute -> cycle .)
    RAND            reduce using rule 13 (statute -> cycle .)
    RETURN          reduce using rule 13 (statute -> cycle .)
    ID              reduce using rule 13 (statute -> cycle .)
    OVAL            reduce using rule 13 (statute -> cycle .)
    TRIO            reduce using rule 13 (statute -> cycle .)
    QUAD            reduce using rule 13 (statute -> cycle .)
    ARC             reduce using rule 13 (statute -> cycle .)
    END             reduce using rule 13 (statute -> cycle .)
    }               reduce using rule 13 (statute -> cycle .)


state 32

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    INPUT           reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    WHILE           reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    ARR             reduce using rule 7 (workspace -> statute .)
    MAT             reduce using rule 7 (workspace -> statute .)
    RAND            reduce using rule 7 (workspace -> statute .)
    RETURN          reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 33

    (73) array -> ARR . typeDim ID [ CTE_INTEGER ] ;
    (75) typeDim -> . INT
    (76) typeDim -> . FLOAT
    (77) typeDim -> . BOOL

    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 69

    typeDim                        shift and go to state 71

state 34

    (74) matrix -> MAT . typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (75) typeDim -> . INT
    (76) typeDim -> . FLOAT
    (77) typeDim -> . BOOL

    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 69

    typeDim                        shift and go to state 72

state 35

    (16) statute -> calling .

    MOD             reduce using rule 16 (statute -> calling .)
    IF              reduce using rule 16 (statute -> calling .)
    INPUT           reduce using rule 16 (statute -> calling .)
    ECHO            reduce using rule 16 (statute -> calling .)
    WHILE           reduce using rule 16 (statute -> calling .)
    REPLAY          reduce using rule 16 (statute -> calling .)
    SAMPLE          reduce using rule 16 (statute -> calling .)
    #               reduce using rule 16 (statute -> calling .)
    ARR             reduce using rule 16 (statute -> calling .)
    MAT             reduce using rule 16 (statute -> calling .)
    RAND            reduce using rule 16 (statute -> calling .)
    RETURN          reduce using rule 16 (statute -> calling .)
    ID              reduce using rule 16 (statute -> calling .)
    OVAL            reduce using rule 16 (statute -> calling .)
    TRIO            reduce using rule 16 (statute -> calling .)
    QUAD            reduce using rule 16 (statute -> calling .)
    ARC             reduce using rule 16 (statute -> calling .)
    END             reduce using rule 16 (statute -> calling .)
    }               reduce using rule 16 (statute -> calling .)


state 36

    (107) figure -> ARC .

    (               reduce using rule 107 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 107 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 107 (figure -> ARC .)
    TRUE            reduce using rule 107 (figure -> ARC .)
    FALSE           reduce using rule 107 (figure -> ARC .)
    ID              reduce using rule 107 (figure -> ARC .)


state 37

    (15) statute -> command .

    MOD             reduce using rule 15 (statute -> command .)
    IF              reduce using rule 15 (statute -> command .)
    INPUT           reduce using rule 15 (statute -> command .)
    ECHO            reduce using rule 15 (statute -> command .)
    WHILE           reduce using rule 15 (statute -> command .)
    REPLAY          reduce using rule 15 (statute -> command .)
    SAMPLE          reduce using rule 15 (statute -> command .)
    #               reduce using rule 15 (statute -> command .)
    ARR             reduce using rule 15 (statute -> command .)
    MAT             reduce using rule 15 (statute -> command .)
    RAND            reduce using rule 15 (statute -> command .)
    RETURN          reduce using rule 15 (statute -> command .)
    ID              reduce using rule 15 (statute -> command .)
    OVAL            reduce using rule 15 (statute -> command .)
    TRIO            reduce using rule 15 (statute -> command .)
    QUAD            reduce using rule 15 (statute -> command .)
    ARC             reduce using rule 15 (statute -> command .)
    END             reduce using rule 15 (statute -> command .)
    }               reduce using rule 15 (statute -> command .)


state 38

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (134) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . random
    (20) statute -> . return
    (26) module -> . MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
    (60) assign -> . id = expression ;
    (61) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (67) read -> . INPUT typeDim ID # ;
    (68) write -> . ECHO ( writeA writeB ) ;
    (82) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (83) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (78) command -> . figure exp exp color ;
    (79) command -> . SAMPLE commandA
    (42) calling -> . # callID calling2 ;
    (73) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (74) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (64) random -> . RAND typeRand ID CTE_INTEGER ;
    (101) return -> . RETURN exp ;
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (104) figure -> . OVAL
    (105) figure -> . TRIO
    (106) figure -> . QUAD
    (107) figure -> . ARC
    (45) callID -> . ID

    END             reduce using rule 134 (empty -> .)
    MOD             shift and go to state 40
    IF              shift and go to state 19
    INPUT           shift and go to state 28
    ECHO            shift and go to state 24
    WHILE           shift and go to state 10
    REPLAY          shift and go to state 11
    SAMPLE          shift and go to state 25
    #               shift and go to state 16
    ARR             shift and go to state 33
    MAT             shift and go to state 34
    RAND            shift and go to state 3
    RETURN          shift and go to state 4
    ID              shift and go to state 29
    OVAL            shift and go to state 9
    TRIO            shift and go to state 20
    QUAD            shift and go to state 12
    ARC             shift and go to state 36

    figure                         shift and go to state 5
    callID                         shift and go to state 6
    random                         shift and go to state 7
    module                         shift and go to state 8
    array                          shift and go to state 14
    id                             shift and go to state 15
    matrix                         shift and go to state 17
    write                          shift and go to state 18
    empty                          shift and go to state 73
    repeat                         shift and go to state 21
    return                         shift and go to state 13
    read                           shift and go to state 23
    programB                       shift and go to state 74
    programC                       shift and go to state 75
    condition                      shift and go to state 30
    cycle                          shift and go to state 31
    statute                        shift and go to state 32
    calling                        shift and go to state 35
    command                        shift and go to state 37
    workspace                      shift and go to state 38
    assign                         shift and go to state 39

state 39

    (9) statute -> assign .

    MOD             reduce using rule 9 (statute -> assign .)
    IF              reduce using rule 9 (statute -> assign .)
    INPUT           reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    WHILE           reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    ARR             reduce using rule 9 (statute -> assign .)
    MAT             reduce using rule 9 (statute -> assign .)
    RAND            reduce using rule 9 (statute -> assign .)
    RETURN          reduce using rule 9 (statute -> assign .)
    ID              reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)


state 40

    (26) module -> MOD . typeMod # moduleID addMod insertQuadMod moduleA endMod
    (21) typeMod -> . INT
    (22) typeMod -> . FLOAT
    (23) typeMod -> . BOOL
    (24) typeMod -> . empty
    (134) empty -> .

    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    #               reduce using rule 134 (empty -> .)

    typeMod                        shift and go to state 76
    empty                          shift and go to state 80

state 41

    (64) random -> RAND typeRand . ID CTE_INTEGER ;

    ID              shift and go to state 81


state 42

    (65) typeRand -> INT .

    ID              reduce using rule 65 (typeRand -> INT .)


state 43

    (66) typeRand -> FLOAT .

    ID              reduce using rule 66 (typeRand -> FLOAT .)


state 44

    (103) factor -> var_cte .

    +               reduce using rule 103 (factor -> var_cte .)
    -               reduce using rule 103 (factor -> var_cte .)
    *               reduce using rule 103 (factor -> var_cte .)
    /               reduce using rule 103 (factor -> var_cte .)
    )               reduce using rule 103 (factor -> var_cte .)
    ;               reduce using rule 103 (factor -> var_cte .)
    ,               reduce using rule 103 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 103 (factor -> var_cte .)
    (               reduce using rule 103 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 103 (factor -> var_cte .)
    TRUE            reduce using rule 103 (factor -> var_cte .)
    FALSE           reduce using rule 103 (factor -> var_cte .)
    ID              reduce using rule 103 (factor -> var_cte .)
    =               reduce using rule 103 (factor -> var_cte .)
    <               reduce using rule 103 (factor -> var_cte .)
    >               reduce using rule 103 (factor -> var_cte .)
    AND             reduce using rule 103 (factor -> var_cte .)
    OR              reduce using rule 103 (factor -> var_cte .)
    RED             reduce using rule 103 (factor -> var_cte .)
    YELLOW          reduce using rule 103 (factor -> var_cte .)
    BLUE            reduce using rule 103 (factor -> var_cte .)
    GREEN           reduce using rule 103 (factor -> var_cte .)
    BLACK           reduce using rule 103 (factor -> var_cte .)
    WHITE           reduce using rule 103 (factor -> var_cte .)
    ORANGE          reduce using rule 103 (factor -> var_cte .)
    PURPLE          reduce using rule 103 (factor -> var_cte .)
    CYAN            reduce using rule 103 (factor -> var_cte .)
    ]               reduce using rule 103 (factor -> var_cte .)


state 45

    (124) var_cte -> TRUE .

    +               reduce using rule 124 (var_cte -> TRUE .)
    -               reduce using rule 124 (var_cte -> TRUE .)
    *               reduce using rule 124 (var_cte -> TRUE .)
    /               reduce using rule 124 (var_cte -> TRUE .)
    RED             reduce using rule 124 (var_cte -> TRUE .)
    YELLOW          reduce using rule 124 (var_cte -> TRUE .)
    BLUE            reduce using rule 124 (var_cte -> TRUE .)
    GREEN           reduce using rule 124 (var_cte -> TRUE .)
    BLACK           reduce using rule 124 (var_cte -> TRUE .)
    WHITE           reduce using rule 124 (var_cte -> TRUE .)
    ORANGE          reduce using rule 124 (var_cte -> TRUE .)
    PURPLE          reduce using rule 124 (var_cte -> TRUE .)
    CYAN            reduce using rule 124 (var_cte -> TRUE .)
    )               reduce using rule 124 (var_cte -> TRUE .)
    ;               reduce using rule 124 (var_cte -> TRUE .)
    ,               reduce using rule 124 (var_cte -> TRUE .)
    (               reduce using rule 124 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 124 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 124 (var_cte -> TRUE .)
    TRUE            reduce using rule 124 (var_cte -> TRUE .)
    FALSE           reduce using rule 124 (var_cte -> TRUE .)
    ID              reduce using rule 124 (var_cte -> TRUE .)
    =               reduce using rule 124 (var_cte -> TRUE .)
    <               reduce using rule 124 (var_cte -> TRUE .)
    >               reduce using rule 124 (var_cte -> TRUE .)
    AND             reduce using rule 124 (var_cte -> TRUE .)
    OR              reduce using rule 124 (var_cte -> TRUE .)
    ]               reduce using rule 124 (var_cte -> TRUE .)


state 46

    (121) var_cte -> id .

    +               reduce using rule 121 (var_cte -> id .)
    -               reduce using rule 121 (var_cte -> id .)
    *               reduce using rule 121 (var_cte -> id .)
    /               reduce using rule 121 (var_cte -> id .)
    RED             reduce using rule 121 (var_cte -> id .)
    YELLOW          reduce using rule 121 (var_cte -> id .)
    BLUE            reduce using rule 121 (var_cte -> id .)
    GREEN           reduce using rule 121 (var_cte -> id .)
    BLACK           reduce using rule 121 (var_cte -> id .)
    WHITE           reduce using rule 121 (var_cte -> id .)
    ORANGE          reduce using rule 121 (var_cte -> id .)
    PURPLE          reduce using rule 121 (var_cte -> id .)
    CYAN            reduce using rule 121 (var_cte -> id .)
    )               reduce using rule 121 (var_cte -> id .)
    ;               reduce using rule 121 (var_cte -> id .)
    ,               reduce using rule 121 (var_cte -> id .)
    (               reduce using rule 121 (var_cte -> id .)
    CTE_INTEGER     reduce using rule 121 (var_cte -> id .)
    CTE_FLOAT       reduce using rule 121 (var_cte -> id .)
    TRUE            reduce using rule 121 (var_cte -> id .)
    FALSE           reduce using rule 121 (var_cte -> id .)
    ID              reduce using rule 121 (var_cte -> id .)
    =               reduce using rule 121 (var_cte -> id .)
    <               reduce using rule 121 (var_cte -> id .)
    >               reduce using rule 121 (var_cte -> id .)
    AND             reduce using rule 121 (var_cte -> id .)
    OR              reduce using rule 121 (var_cte -> id .)
    ]               reduce using rule 121 (var_cte -> id .)


state 47

    (102) factor -> ( . expression )
    (87) expression -> . exp = = exp
    (88) expression -> . exp < > exp
    (89) expression -> . exp < = exp
    (90) expression -> . exp > = exp
    (91) expression -> . exp > exp
    (92) expression -> . exp < exp
    (93) expression -> . exp AND exp
    (94) expression -> . exp OR exp
    (95) expression -> . exp empty
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 82
    factor                         shift and go to state 48
    expression                     shift and go to state 83
    id                             shift and go to state 46

state 48

    (100) exp -> factor . empty
    (134) empty -> .

    ;               reduce using rule 134 (empty -> .)
    +               reduce using rule 134 (empty -> .)
    -               reduce using rule 134 (empty -> .)
    *               reduce using rule 134 (empty -> .)
    /               reduce using rule 134 (empty -> .)
    (               reduce using rule 134 (empty -> .)
    CTE_INTEGER     reduce using rule 134 (empty -> .)
    CTE_FLOAT       reduce using rule 134 (empty -> .)
    TRUE            reduce using rule 134 (empty -> .)
    FALSE           reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    =               reduce using rule 134 (empty -> .)
    <               reduce using rule 134 (empty -> .)
    >               reduce using rule 134 (empty -> .)
    AND             reduce using rule 134 (empty -> .)
    OR              reduce using rule 134 (empty -> .)
    )               reduce using rule 134 (empty -> .)
    RED             reduce using rule 134 (empty -> .)
    YELLOW          reduce using rule 134 (empty -> .)
    BLUE            reduce using rule 134 (empty -> .)
    GREEN           reduce using rule 134 (empty -> .)
    BLACK           reduce using rule 134 (empty -> .)
    WHITE           reduce using rule 134 (empty -> .)
    ORANGE          reduce using rule 134 (empty -> .)
    PURPLE          reduce using rule 134 (empty -> .)
    CYAN            reduce using rule 134 (empty -> .)
    ,               reduce using rule 134 (empty -> .)
    ]               reduce using rule 134 (empty -> .)

    empty                          shift and go to state 84

state 49

    (122) var_cte -> CTE_INTEGER .

    +               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 122 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 122 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 122 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 122 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 122 (var_cte -> CTE_INTEGER .)
    WHITE           reduce using rule 122 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 122 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 122 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 122 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 122 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 122 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 122 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 122 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 122 (var_cte -> CTE_INTEGER .)
    =               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 122 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 122 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 122 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 122 (var_cte -> CTE_INTEGER .)


state 50

    (125) var_cte -> FALSE .

    +               reduce using rule 125 (var_cte -> FALSE .)
    -               reduce using rule 125 (var_cte -> FALSE .)
    *               reduce using rule 125 (var_cte -> FALSE .)
    /               reduce using rule 125 (var_cte -> FALSE .)
    RED             reduce using rule 125 (var_cte -> FALSE .)
    YELLOW          reduce using rule 125 (var_cte -> FALSE .)
    BLUE            reduce using rule 125 (var_cte -> FALSE .)
    GREEN           reduce using rule 125 (var_cte -> FALSE .)
    BLACK           reduce using rule 125 (var_cte -> FALSE .)
    WHITE           reduce using rule 125 (var_cte -> FALSE .)
    ORANGE          reduce using rule 125 (var_cte -> FALSE .)
    PURPLE          reduce using rule 125 (var_cte -> FALSE .)
    CYAN            reduce using rule 125 (var_cte -> FALSE .)
    )               reduce using rule 125 (var_cte -> FALSE .)
    ;               reduce using rule 125 (var_cte -> FALSE .)
    ,               reduce using rule 125 (var_cte -> FALSE .)
    (               reduce using rule 125 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 125 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 125 (var_cte -> FALSE .)
    TRUE            reduce using rule 125 (var_cte -> FALSE .)
    FALSE           reduce using rule 125 (var_cte -> FALSE .)
    ID              reduce using rule 125 (var_cte -> FALSE .)
    =               reduce using rule 125 (var_cte -> FALSE .)
    <               reduce using rule 125 (var_cte -> FALSE .)
    >               reduce using rule 125 (var_cte -> FALSE .)
    AND             reduce using rule 125 (var_cte -> FALSE .)
    OR              reduce using rule 125 (var_cte -> FALSE .)
    ]               reduce using rule 125 (var_cte -> FALSE .)


state 51

    (123) var_cte -> CTE_FLOAT .

    +               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 123 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 123 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 123 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 123 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 123 (var_cte -> CTE_FLOAT .)
    WHITE           reduce using rule 123 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 123 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 123 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 123 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 123 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 123 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 123 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 123 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 123 (var_cte -> CTE_FLOAT .)
    =               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 123 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 123 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 123 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 123 (var_cte -> CTE_FLOAT .)


state 52

    (101) return -> RETURN exp . ;
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ;               shift and go to state 89
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 53

    (78) command -> figure exp . exp color ;
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88
    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 90
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 54

    (38) id -> callID initdim . # calling2

    #               shift and go to state 91


state 55

    (82) cycle -> WHILE gotoW . ( expression ) gotoFalse block continueGoW

    (               shift and go to state 92


state 56

    (83) repeat -> REPLAY CTE_INTEGER . gotoR [ repeatA ] ;
    (129) gotoR -> .

    [               reduce using rule 129 (gotoR -> .)

    gotoR                          shift and go to state 93

state 57

    (60) assign -> id = . expression ;
    (87) expression -> . exp = = exp
    (88) expression -> . exp < > exp
    (89) expression -> . exp < = exp
    (90) expression -> . exp > = exp
    (91) expression -> . exp > exp
    (92) expression -> . exp < exp
    (93) expression -> . exp AND exp
    (94) expression -> . exp OR exp
    (95) expression -> . exp empty
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 82
    factor                         shift and go to state 48
    expression                     shift and go to state 94
    id                             shift and go to state 46

state 58

    (42) calling -> # callID . calling2 ;
    (43) calling2 -> . ( maincalling )

    (               shift and go to state 95

    calling2                       shift and go to state 96

state 59

    (45) callID -> ID .

    (               reduce using rule 45 (callID -> ID .)


state 60

    (61) condition -> IF ( . expression ) gotoFalse block conditionA continueGo
    (87) expression -> . exp = = exp
    (88) expression -> . exp < > exp
    (89) expression -> . exp < = exp
    (90) expression -> . exp > = exp
    (91) expression -> . exp > exp
    (92) expression -> . exp < exp
    (93) expression -> . exp AND exp
    (94) expression -> . exp OR exp
    (95) expression -> . exp empty
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    exp                            shift and go to state 82
    factor                         shift and go to state 48
    var_cte                        shift and go to state 44
    expression                     shift and go to state 97
    id                             shift and go to state 46

state 61

    (68) write -> ECHO ( . writeA writeB ) ;
    (69) writeA -> . expression
    (70) writeA -> . CTE_STRING
    (87) expression -> . exp = = exp
    (88) expression -> . exp < > exp
    (89) expression -> . exp < = exp
    (90) expression -> . exp > = exp
    (91) expression -> . exp > exp
    (92) expression -> . exp < exp
    (93) expression -> . exp AND exp
    (94) expression -> . exp OR exp
    (95) expression -> . exp empty
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    CTE_STRING      shift and go to state 99
    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 82
    factor                         shift and go to state 48
    writeA                         shift and go to state 98
    expression                     shift and go to state 100
    id                             shift and go to state 46

state 62

    (79) command -> SAMPLE commandA .

    SAMPLE          reduce using rule 79 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 79 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 79 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 79 (command -> SAMPLE commandA .)
    ARC             reduce using rule 79 (command -> SAMPLE commandA .)
    ]               reduce using rule 79 (command -> SAMPLE commandA .)
    IF              reduce using rule 79 (command -> SAMPLE commandA .)
    INPUT           reduce using rule 79 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 79 (command -> SAMPLE commandA .)
    WHILE           reduce using rule 79 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 79 (command -> SAMPLE commandA .)
    #               reduce using rule 79 (command -> SAMPLE commandA .)
    ARR             reduce using rule 79 (command -> SAMPLE commandA .)
    MAT             reduce using rule 79 (command -> SAMPLE commandA .)
    RAND            reduce using rule 79 (command -> SAMPLE commandA .)
    RETURN          reduce using rule 79 (command -> SAMPLE commandA .)
    ID              reduce using rule 79 (command -> SAMPLE commandA .)
    }               reduce using rule 79 (command -> SAMPLE commandA .)
    MOD             reduce using rule 79 (command -> SAMPLE commandA .)
    END             reduce using rule 79 (command -> SAMPLE commandA .)


state 63

    (81) commandA -> OFF . move exp ;
    (108) move -> . UP
    (109) move -> . DOWN
    (110) move -> . LEFT
    (111) move -> . RIGHT

    UP              shift and go to state 103
    DOWN            shift and go to state 104
    LEFT            shift and go to state 105
    RIGHT           shift and go to state 101

    move                           shift and go to state 102

state 64

    (80) commandA -> ON . move exp CTE_INTEGER color ;
    (108) move -> . UP
    (109) move -> . DOWN
    (110) move -> . LEFT
    (111) move -> . RIGHT

    UP              shift and go to state 103
    DOWN            shift and go to state 104
    LEFT            shift and go to state 105
    RIGHT           shift and go to state 101

    move                           shift and go to state 106

state 65

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 66

    (75) typeDim -> INT .

    ID              reduce using rule 75 (typeDim -> INT .)


state 67

    (76) typeDim -> FLOAT .

    ID              reduce using rule 76 (typeDim -> FLOAT .)


state 68

    (67) read -> INPUT typeDim . ID # ;

    ID              shift and go to state 107


state 69

    (77) typeDim -> BOOL .

    ID              reduce using rule 77 (typeDim -> BOOL .)


state 70

    (36) id -> ID initdim . [ sumdim exp ] [ sumdim exp ]
    (37) id -> ID initdim . [ sumdim exp ]
    (39) id -> ID initdim . empty
    (134) empty -> .

    [               shift and go to state 108
    =               reduce using rule 134 (empty -> .)
    ;               reduce using rule 134 (empty -> .)
    +               reduce using rule 134 (empty -> .)
    -               reduce using rule 134 (empty -> .)
    *               reduce using rule 134 (empty -> .)
    /               reduce using rule 134 (empty -> .)
    (               reduce using rule 134 (empty -> .)
    CTE_INTEGER     reduce using rule 134 (empty -> .)
    CTE_FLOAT       reduce using rule 134 (empty -> .)
    TRUE            reduce using rule 134 (empty -> .)
    FALSE           reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    <               reduce using rule 134 (empty -> .)
    >               reduce using rule 134 (empty -> .)
    AND             reduce using rule 134 (empty -> .)
    OR              reduce using rule 134 (empty -> .)
    )               reduce using rule 134 (empty -> .)
    RED             reduce using rule 134 (empty -> .)
    YELLOW          reduce using rule 134 (empty -> .)
    BLUE            reduce using rule 134 (empty -> .)
    GREEN           reduce using rule 134 (empty -> .)
    BLACK           reduce using rule 134 (empty -> .)
    WHITE           reduce using rule 134 (empty -> .)
    ORANGE          reduce using rule 134 (empty -> .)
    PURPLE          reduce using rule 134 (empty -> .)
    CYAN            reduce using rule 134 (empty -> .)
    ,               reduce using rule 134 (empty -> .)
    ]               reduce using rule 134 (empty -> .)

    empty                          shift and go to state 109

state 71

    (73) array -> ARR typeDim . ID [ CTE_INTEGER ] ;

    ID              shift and go to state 110


state 72

    (74) matrix -> MAT typeDim . ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    ID              shift and go to state 111


state 73

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 74

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 75

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 76

    (26) module -> MOD typeMod . # moduleID addMod insertQuadMod moduleA endMod

    #               shift and go to state 112


state 77

    (21) typeMod -> INT .

    #               reduce using rule 21 (typeMod -> INT .)


state 78

    (22) typeMod -> FLOAT .

    #               reduce using rule 22 (typeMod -> FLOAT .)


state 79

    (23) typeMod -> BOOL .

    #               reduce using rule 23 (typeMod -> BOOL .)


state 80

    (24) typeMod -> empty .

    #               reduce using rule 24 (typeMod -> empty .)


state 81

    (64) random -> RAND typeRand ID . CTE_INTEGER ;

    CTE_INTEGER     shift and go to state 113


state 82

    (87) expression -> exp . = = exp
    (88) expression -> exp . < > exp
    (89) expression -> exp . < = exp
    (90) expression -> exp . > = exp
    (91) expression -> exp . > exp
    (92) expression -> exp . < exp
    (93) expression -> exp . AND exp
    (94) expression -> exp . OR exp
    (95) expression -> exp . empty
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp
    (134) empty -> .

    =               shift and go to state 116
    <               shift and go to state 115
    >               shift and go to state 119
    AND             shift and go to state 114
    OR              shift and go to state 117
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88
    )               reduce using rule 134 (empty -> .)
    ;               reduce using rule 134 (empty -> .)
    ,               reduce using rule 134 (empty -> .)

    empty                          shift and go to state 118

state 83

    (102) factor -> ( expression . )

    )               shift and go to state 120


state 84

    (100) exp -> factor empty .

    +               reduce using rule 100 (exp -> factor empty .)
    -               reduce using rule 100 (exp -> factor empty .)
    *               reduce using rule 100 (exp -> factor empty .)
    /               reduce using rule 100 (exp -> factor empty .)
    RED             reduce using rule 100 (exp -> factor empty .)
    YELLOW          reduce using rule 100 (exp -> factor empty .)
    BLUE            reduce using rule 100 (exp -> factor empty .)
    GREEN           reduce using rule 100 (exp -> factor empty .)
    BLACK           reduce using rule 100 (exp -> factor empty .)
    WHITE           reduce using rule 100 (exp -> factor empty .)
    ORANGE          reduce using rule 100 (exp -> factor empty .)
    PURPLE          reduce using rule 100 (exp -> factor empty .)
    CYAN            reduce using rule 100 (exp -> factor empty .)
    )               reduce using rule 100 (exp -> factor empty .)
    ;               reduce using rule 100 (exp -> factor empty .)
    ,               reduce using rule 100 (exp -> factor empty .)
    (               reduce using rule 100 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 100 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 100 (exp -> factor empty .)
    TRUE            reduce using rule 100 (exp -> factor empty .)
    FALSE           reduce using rule 100 (exp -> factor empty .)
    ID              reduce using rule 100 (exp -> factor empty .)
    =               reduce using rule 100 (exp -> factor empty .)
    <               reduce using rule 100 (exp -> factor empty .)
    >               reduce using rule 100 (exp -> factor empty .)
    AND             reduce using rule 100 (exp -> factor empty .)
    OR              reduce using rule 100 (exp -> factor empty .)
    ]               reduce using rule 100 (exp -> factor empty .)


state 85

    (96) exp -> exp + . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 121
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 86

    (98) exp -> exp * . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 122
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 87

    (97) exp -> exp - . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 123
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 88

    (99) exp -> exp / . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 124
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 89

    (101) return -> RETURN exp ; .

    IF              reduce using rule 101 (return -> RETURN exp ; .)
    INPUT           reduce using rule 101 (return -> RETURN exp ; .)
    ECHO            reduce using rule 101 (return -> RETURN exp ; .)
    WHILE           reduce using rule 101 (return -> RETURN exp ; .)
    REPLAY          reduce using rule 101 (return -> RETURN exp ; .)
    SAMPLE          reduce using rule 101 (return -> RETURN exp ; .)
    #               reduce using rule 101 (return -> RETURN exp ; .)
    ARR             reduce using rule 101 (return -> RETURN exp ; .)
    MAT             reduce using rule 101 (return -> RETURN exp ; .)
    RAND            reduce using rule 101 (return -> RETURN exp ; .)
    RETURN          reduce using rule 101 (return -> RETURN exp ; .)
    ID              reduce using rule 101 (return -> RETURN exp ; .)
    OVAL            reduce using rule 101 (return -> RETURN exp ; .)
    TRIO            reduce using rule 101 (return -> RETURN exp ; .)
    QUAD            reduce using rule 101 (return -> RETURN exp ; .)
    ARC             reduce using rule 101 (return -> RETURN exp ; .)
    }               reduce using rule 101 (return -> RETURN exp ; .)
    MOD             reduce using rule 101 (return -> RETURN exp ; .)
    END             reduce using rule 101 (return -> RETURN exp ; .)


state 90

    (78) command -> figure exp exp . color ;
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp
    (112) color -> . RED
    (113) color -> . YELLOW
    (114) color -> . BLUE
    (115) color -> . GREEN
    (116) color -> . BLACK
    (117) color -> . WHITE
    (118) color -> . ORANGE
    (119) color -> . PURPLE
    (120) color -> . CYAN

    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88
    RED             shift and go to state 134
    YELLOW          shift and go to state 129
    BLUE            shift and go to state 125
    GREEN           shift and go to state 128
    BLACK           shift and go to state 132
    WHITE           shift and go to state 133
    ORANGE          shift and go to state 131
    PURPLE          shift and go to state 127
    CYAN            shift and go to state 130

    color                          shift and go to state 126

state 91

    (38) id -> callID initdim # . calling2
    (43) calling2 -> . ( maincalling )

    (               shift and go to state 95

    calling2                       shift and go to state 135

state 92

    (82) cycle -> WHILE gotoW ( . expression ) gotoFalse block continueGoW
    (87) expression -> . exp = = exp
    (88) expression -> . exp < > exp
    (89) expression -> . exp < = exp
    (90) expression -> . exp > = exp
    (91) expression -> . exp > exp
    (92) expression -> . exp < exp
    (93) expression -> . exp AND exp
    (94) expression -> . exp OR exp
    (95) expression -> . exp empty
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 82
    factor                         shift and go to state 48
    expression                     shift and go to state 136
    id                             shift and go to state 46

state 93

    (83) repeat -> REPLAY CTE_INTEGER gotoR . [ repeatA ] ;

    [               shift and go to state 137


state 94

    (60) assign -> id = expression . ;

    ;               shift and go to state 138


state 95

    (43) calling2 -> ( . maincalling )
    (44) maincalling -> . insertEra callingA
    (46) insertEra -> .

    (               reduce using rule 46 (insertEra -> .)
    CTE_INTEGER     reduce using rule 46 (insertEra -> .)
    CTE_FLOAT       reduce using rule 46 (insertEra -> .)
    TRUE            reduce using rule 46 (insertEra -> .)
    FALSE           reduce using rule 46 (insertEra -> .)
    ID              reduce using rule 46 (insertEra -> .)
    )               reduce using rule 46 (insertEra -> .)

    insertEra                      shift and go to state 139
    maincalling                    shift and go to state 140

state 96

    (42) calling -> # callID calling2 . ;

    ;               shift and go to state 141


state 97

    (61) condition -> IF ( expression . ) gotoFalse block conditionA continueGo

    )               shift and go to state 142


state 98

    (68) write -> ECHO ( writeA . writeB ) ;
    (71) writeB -> . , writeA
    (72) writeB -> . empty
    (134) empty -> .

    ,               shift and go to state 143
    )               reduce using rule 134 (empty -> .)

    writeB                         shift and go to state 144
    empty                          shift and go to state 145

state 99

    (70) writeA -> CTE_STRING .

    )               reduce using rule 70 (writeA -> CTE_STRING .)
    ,               reduce using rule 70 (writeA -> CTE_STRING .)


state 100

    (69) writeA -> expression .

    )               reduce using rule 69 (writeA -> expression .)
    ,               reduce using rule 69 (writeA -> expression .)


state 101

    (111) move -> RIGHT .

    (               reduce using rule 111 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 111 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 111 (move -> RIGHT .)
    TRUE            reduce using rule 111 (move -> RIGHT .)
    FALSE           reduce using rule 111 (move -> RIGHT .)
    ID              reduce using rule 111 (move -> RIGHT .)


state 102

    (81) commandA -> OFF move . exp ;
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 146
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 103

    (108) move -> UP .

    (               reduce using rule 108 (move -> UP .)
    CTE_INTEGER     reduce using rule 108 (move -> UP .)
    CTE_FLOAT       reduce using rule 108 (move -> UP .)
    TRUE            reduce using rule 108 (move -> UP .)
    FALSE           reduce using rule 108 (move -> UP .)
    ID              reduce using rule 108 (move -> UP .)


state 104

    (109) move -> DOWN .

    (               reduce using rule 109 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 109 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 109 (move -> DOWN .)
    TRUE            reduce using rule 109 (move -> DOWN .)
    FALSE           reduce using rule 109 (move -> DOWN .)
    ID              reduce using rule 109 (move -> DOWN .)


state 105

    (110) move -> LEFT .

    (               reduce using rule 110 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 110 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 110 (move -> LEFT .)
    TRUE            reduce using rule 110 (move -> LEFT .)
    FALSE           reduce using rule 110 (move -> LEFT .)
    ID              reduce using rule 110 (move -> LEFT .)


state 106

    (80) commandA -> ON move . exp CTE_INTEGER color ;
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 147
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 107

    (67) read -> INPUT typeDim ID . # ;

    #               shift and go to state 148


state 108

    (36) id -> ID initdim [ . sumdim exp ] [ sumdim exp ]
    (37) id -> ID initdim [ . sumdim exp ]
    (41) sumdim -> .

    (               reduce using rule 41 (sumdim -> .)
    CTE_INTEGER     reduce using rule 41 (sumdim -> .)
    CTE_FLOAT       reduce using rule 41 (sumdim -> .)
    TRUE            reduce using rule 41 (sumdim -> .)
    FALSE           reduce using rule 41 (sumdim -> .)
    ID              reduce using rule 41 (sumdim -> .)

    sumdim                         shift and go to state 149

state 109

    (39) id -> ID initdim empty .

    +               reduce using rule 39 (id -> ID initdim empty .)
    -               reduce using rule 39 (id -> ID initdim empty .)
    *               reduce using rule 39 (id -> ID initdim empty .)
    /               reduce using rule 39 (id -> ID initdim empty .)
    )               reduce using rule 39 (id -> ID initdim empty .)
    ;               reduce using rule 39 (id -> ID initdim empty .)
    ,               reduce using rule 39 (id -> ID initdim empty .)
    ]               reduce using rule 39 (id -> ID initdim empty .)
    RED             reduce using rule 39 (id -> ID initdim empty .)
    YELLOW          reduce using rule 39 (id -> ID initdim empty .)
    BLUE            reduce using rule 39 (id -> ID initdim empty .)
    GREEN           reduce using rule 39 (id -> ID initdim empty .)
    BLACK           reduce using rule 39 (id -> ID initdim empty .)
    WHITE           reduce using rule 39 (id -> ID initdim empty .)
    ORANGE          reduce using rule 39 (id -> ID initdim empty .)
    PURPLE          reduce using rule 39 (id -> ID initdim empty .)
    CYAN            reduce using rule 39 (id -> ID initdim empty .)
    =               reduce using rule 39 (id -> ID initdim empty .)
    (               reduce using rule 39 (id -> ID initdim empty .)
    CTE_INTEGER     reduce using rule 39 (id -> ID initdim empty .)
    CTE_FLOAT       reduce using rule 39 (id -> ID initdim empty .)
    TRUE            reduce using rule 39 (id -> ID initdim empty .)
    FALSE           reduce using rule 39 (id -> ID initdim empty .)
    ID              reduce using rule 39 (id -> ID initdim empty .)
    <               reduce using rule 39 (id -> ID initdim empty .)
    >               reduce using rule 39 (id -> ID initdim empty .)
    AND             reduce using rule 39 (id -> ID initdim empty .)
    OR              reduce using rule 39 (id -> ID initdim empty .)


state 110

    (73) array -> ARR typeDim ID . [ CTE_INTEGER ] ;

    [               shift and go to state 150


state 111

    (74) matrix -> MAT typeDim ID . [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    [               shift and go to state 151


state 112

    (26) module -> MOD typeMod # . moduleID addMod insertQuadMod moduleA endMod
    (29) moduleID -> . ID

    ID              shift and go to state 152

    moduleID                       shift and go to state 153

state 113

    (64) random -> RAND typeRand ID CTE_INTEGER . ;

    ;               shift and go to state 154


state 114

    (93) expression -> exp AND . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 155
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 115

    (88) expression -> exp < . > exp
    (89) expression -> exp < . = exp
    (92) expression -> exp < . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    >               shift and go to state 157
    =               shift and go to state 156
    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 158
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 116

    (87) expression -> exp = . = exp

    =               shift and go to state 159


state 117

    (94) expression -> exp OR . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 160
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 118

    (95) expression -> exp empty .

    ,               reduce using rule 95 (expression -> exp empty .)
    )               reduce using rule 95 (expression -> exp empty .)
    ;               reduce using rule 95 (expression -> exp empty .)


state 119

    (90) expression -> exp > . = exp
    (91) expression -> exp > . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    =               shift and go to state 161
    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 162
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 120

    (102) factor -> ( expression ) .

    +               reduce using rule 102 (factor -> ( expression ) .)
    -               reduce using rule 102 (factor -> ( expression ) .)
    *               reduce using rule 102 (factor -> ( expression ) .)
    /               reduce using rule 102 (factor -> ( expression ) .)
    )               reduce using rule 102 (factor -> ( expression ) .)
    ;               reduce using rule 102 (factor -> ( expression ) .)
    ,               reduce using rule 102 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 102 (factor -> ( expression ) .)
    (               reduce using rule 102 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 102 (factor -> ( expression ) .)
    TRUE            reduce using rule 102 (factor -> ( expression ) .)
    FALSE           reduce using rule 102 (factor -> ( expression ) .)
    ID              reduce using rule 102 (factor -> ( expression ) .)
    =               reduce using rule 102 (factor -> ( expression ) .)
    <               reduce using rule 102 (factor -> ( expression ) .)
    >               reduce using rule 102 (factor -> ( expression ) .)
    AND             reduce using rule 102 (factor -> ( expression ) .)
    OR              reduce using rule 102 (factor -> ( expression ) .)
    RED             reduce using rule 102 (factor -> ( expression ) .)
    YELLOW          reduce using rule 102 (factor -> ( expression ) .)
    BLUE            reduce using rule 102 (factor -> ( expression ) .)
    GREEN           reduce using rule 102 (factor -> ( expression ) .)
    BLACK           reduce using rule 102 (factor -> ( expression ) .)
    WHITE           reduce using rule 102 (factor -> ( expression ) .)
    ORANGE          reduce using rule 102 (factor -> ( expression ) .)
    PURPLE          reduce using rule 102 (factor -> ( expression ) .)
    CYAN            reduce using rule 102 (factor -> ( expression ) .)
    ]               reduce using rule 102 (factor -> ( expression ) .)


state 121

    (96) exp -> exp + exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    +               reduce using rule 96 (exp -> exp + exp .)
    -               reduce using rule 96 (exp -> exp + exp .)
    RED             reduce using rule 96 (exp -> exp + exp .)
    YELLOW          reduce using rule 96 (exp -> exp + exp .)
    BLUE            reduce using rule 96 (exp -> exp + exp .)
    GREEN           reduce using rule 96 (exp -> exp + exp .)
    BLACK           reduce using rule 96 (exp -> exp + exp .)
    WHITE           reduce using rule 96 (exp -> exp + exp .)
    ORANGE          reduce using rule 96 (exp -> exp + exp .)
    PURPLE          reduce using rule 96 (exp -> exp + exp .)
    CYAN            reduce using rule 96 (exp -> exp + exp .)
    )               reduce using rule 96 (exp -> exp + exp .)
    ;               reduce using rule 96 (exp -> exp + exp .)
    ,               reduce using rule 96 (exp -> exp + exp .)
    (               reduce using rule 96 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 96 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 96 (exp -> exp + exp .)
    TRUE            reduce using rule 96 (exp -> exp + exp .)
    FALSE           reduce using rule 96 (exp -> exp + exp .)
    ID              reduce using rule 96 (exp -> exp + exp .)
    =               reduce using rule 96 (exp -> exp + exp .)
    <               reduce using rule 96 (exp -> exp + exp .)
    >               reduce using rule 96 (exp -> exp + exp .)
    AND             reduce using rule 96 (exp -> exp + exp .)
    OR              reduce using rule 96 (exp -> exp + exp .)
    ]               reduce using rule 96 (exp -> exp + exp .)
    *               shift and go to state 86
    /               shift and go to state 88

  ! *               [ reduce using rule 96 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 96 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]


state 122

    (98) exp -> exp * exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    +               reduce using rule 98 (exp -> exp * exp .)
    -               reduce using rule 98 (exp -> exp * exp .)
    *               reduce using rule 98 (exp -> exp * exp .)
    /               reduce using rule 98 (exp -> exp * exp .)
    RED             reduce using rule 98 (exp -> exp * exp .)
    YELLOW          reduce using rule 98 (exp -> exp * exp .)
    BLUE            reduce using rule 98 (exp -> exp * exp .)
    GREEN           reduce using rule 98 (exp -> exp * exp .)
    BLACK           reduce using rule 98 (exp -> exp * exp .)
    WHITE           reduce using rule 98 (exp -> exp * exp .)
    ORANGE          reduce using rule 98 (exp -> exp * exp .)
    PURPLE          reduce using rule 98 (exp -> exp * exp .)
    CYAN            reduce using rule 98 (exp -> exp * exp .)
    )               reduce using rule 98 (exp -> exp * exp .)
    ;               reduce using rule 98 (exp -> exp * exp .)
    ,               reduce using rule 98 (exp -> exp * exp .)
    (               reduce using rule 98 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 98 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 98 (exp -> exp * exp .)
    TRUE            reduce using rule 98 (exp -> exp * exp .)
    FALSE           reduce using rule 98 (exp -> exp * exp .)
    ID              reduce using rule 98 (exp -> exp * exp .)
    =               reduce using rule 98 (exp -> exp * exp .)
    <               reduce using rule 98 (exp -> exp * exp .)
    >               reduce using rule 98 (exp -> exp * exp .)
    AND             reduce using rule 98 (exp -> exp * exp .)
    OR              reduce using rule 98 (exp -> exp * exp .)
    ]               reduce using rule 98 (exp -> exp * exp .)

  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]
  ! *               [ shift and go to state 86 ]
  ! /               [ shift and go to state 88 ]


state 123

    (97) exp -> exp - exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    +               reduce using rule 97 (exp -> exp - exp .)
    -               reduce using rule 97 (exp -> exp - exp .)
    RED             reduce using rule 97 (exp -> exp - exp .)
    YELLOW          reduce using rule 97 (exp -> exp - exp .)
    BLUE            reduce using rule 97 (exp -> exp - exp .)
    GREEN           reduce using rule 97 (exp -> exp - exp .)
    BLACK           reduce using rule 97 (exp -> exp - exp .)
    WHITE           reduce using rule 97 (exp -> exp - exp .)
    ORANGE          reduce using rule 97 (exp -> exp - exp .)
    PURPLE          reduce using rule 97 (exp -> exp - exp .)
    CYAN            reduce using rule 97 (exp -> exp - exp .)
    )               reduce using rule 97 (exp -> exp - exp .)
    ;               reduce using rule 97 (exp -> exp - exp .)
    ,               reduce using rule 97 (exp -> exp - exp .)
    (               reduce using rule 97 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 97 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 97 (exp -> exp - exp .)
    TRUE            reduce using rule 97 (exp -> exp - exp .)
    FALSE           reduce using rule 97 (exp -> exp - exp .)
    ID              reduce using rule 97 (exp -> exp - exp .)
    =               reduce using rule 97 (exp -> exp - exp .)
    <               reduce using rule 97 (exp -> exp - exp .)
    >               reduce using rule 97 (exp -> exp - exp .)
    AND             reduce using rule 97 (exp -> exp - exp .)
    OR              reduce using rule 97 (exp -> exp - exp .)
    ]               reduce using rule 97 (exp -> exp - exp .)
    *               shift and go to state 86
    /               shift and go to state 88

  ! *               [ reduce using rule 97 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 97 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]


state 124

    (99) exp -> exp / exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    +               reduce using rule 99 (exp -> exp / exp .)
    -               reduce using rule 99 (exp -> exp / exp .)
    *               reduce using rule 99 (exp -> exp / exp .)
    /               reduce using rule 99 (exp -> exp / exp .)
    RED             reduce using rule 99 (exp -> exp / exp .)
    YELLOW          reduce using rule 99 (exp -> exp / exp .)
    BLUE            reduce using rule 99 (exp -> exp / exp .)
    GREEN           reduce using rule 99 (exp -> exp / exp .)
    BLACK           reduce using rule 99 (exp -> exp / exp .)
    WHITE           reduce using rule 99 (exp -> exp / exp .)
    ORANGE          reduce using rule 99 (exp -> exp / exp .)
    PURPLE          reduce using rule 99 (exp -> exp / exp .)
    CYAN            reduce using rule 99 (exp -> exp / exp .)
    )               reduce using rule 99 (exp -> exp / exp .)
    ;               reduce using rule 99 (exp -> exp / exp .)
    ,               reduce using rule 99 (exp -> exp / exp .)
    (               reduce using rule 99 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 99 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 99 (exp -> exp / exp .)
    TRUE            reduce using rule 99 (exp -> exp / exp .)
    FALSE           reduce using rule 99 (exp -> exp / exp .)
    ID              reduce using rule 99 (exp -> exp / exp .)
    =               reduce using rule 99 (exp -> exp / exp .)
    <               reduce using rule 99 (exp -> exp / exp .)
    >               reduce using rule 99 (exp -> exp / exp .)
    AND             reduce using rule 99 (exp -> exp / exp .)
    OR              reduce using rule 99 (exp -> exp / exp .)
    ]               reduce using rule 99 (exp -> exp / exp .)

  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]
  ! *               [ shift and go to state 86 ]
  ! /               [ shift and go to state 88 ]


state 125

    (114) color -> BLUE .

    ;               reduce using rule 114 (color -> BLUE .)


state 126

    (78) command -> figure exp exp color . ;

    ;               shift and go to state 163


state 127

    (119) color -> PURPLE .

    ;               reduce using rule 119 (color -> PURPLE .)


state 128

    (115) color -> GREEN .

    ;               reduce using rule 115 (color -> GREEN .)


state 129

    (113) color -> YELLOW .

    ;               reduce using rule 113 (color -> YELLOW .)


state 130

    (120) color -> CYAN .

    ;               reduce using rule 120 (color -> CYAN .)


state 131

    (118) color -> ORANGE .

    ;               reduce using rule 118 (color -> ORANGE .)


state 132

    (116) color -> BLACK .

    ;               reduce using rule 116 (color -> BLACK .)


state 133

    (117) color -> WHITE .

    ;               reduce using rule 117 (color -> WHITE .)


state 134

    (112) color -> RED .

    ;               reduce using rule 112 (color -> RED .)


state 135

    (38) id -> callID initdim # calling2 .

    +               reduce using rule 38 (id -> callID initdim # calling2 .)
    -               reduce using rule 38 (id -> callID initdim # calling2 .)
    *               reduce using rule 38 (id -> callID initdim # calling2 .)
    /               reduce using rule 38 (id -> callID initdim # calling2 .)
    )               reduce using rule 38 (id -> callID initdim # calling2 .)
    ;               reduce using rule 38 (id -> callID initdim # calling2 .)
    ,               reduce using rule 38 (id -> callID initdim # calling2 .)
    ]               reduce using rule 38 (id -> callID initdim # calling2 .)
    RED             reduce using rule 38 (id -> callID initdim # calling2 .)
    YELLOW          reduce using rule 38 (id -> callID initdim # calling2 .)
    BLUE            reduce using rule 38 (id -> callID initdim # calling2 .)
    GREEN           reduce using rule 38 (id -> callID initdim # calling2 .)
    BLACK           reduce using rule 38 (id -> callID initdim # calling2 .)
    WHITE           reduce using rule 38 (id -> callID initdim # calling2 .)
    ORANGE          reduce using rule 38 (id -> callID initdim # calling2 .)
    PURPLE          reduce using rule 38 (id -> callID initdim # calling2 .)
    CYAN            reduce using rule 38 (id -> callID initdim # calling2 .)
    =               reduce using rule 38 (id -> callID initdim # calling2 .)
    (               reduce using rule 38 (id -> callID initdim # calling2 .)
    CTE_INTEGER     reduce using rule 38 (id -> callID initdim # calling2 .)
    CTE_FLOAT       reduce using rule 38 (id -> callID initdim # calling2 .)
    TRUE            reduce using rule 38 (id -> callID initdim # calling2 .)
    FALSE           reduce using rule 38 (id -> callID initdim # calling2 .)
    ID              reduce using rule 38 (id -> callID initdim # calling2 .)
    <               reduce using rule 38 (id -> callID initdim # calling2 .)
    >               reduce using rule 38 (id -> callID initdim # calling2 .)
    AND             reduce using rule 38 (id -> callID initdim # calling2 .)
    OR              reduce using rule 38 (id -> callID initdim # calling2 .)


state 136

    (82) cycle -> WHILE gotoW ( expression . ) gotoFalse block continueGoW

    )               shift and go to state 164


state 137

    (83) repeat -> REPLAY CTE_INTEGER gotoR [ . repeatA ] ;
    (84) repeatA -> . command repeatB
    (78) command -> . figure exp exp color ;
    (79) command -> . SAMPLE commandA
    (104) figure -> . OVAL
    (105) figure -> . TRIO
    (106) figure -> . QUAD
    (107) figure -> . ARC

    SAMPLE          shift and go to state 25
    OVAL            shift and go to state 9
    TRIO            shift and go to state 20
    QUAD            shift and go to state 12
    ARC             shift and go to state 36

    figure                         shift and go to state 5
    repeatA                        shift and go to state 165
    command                        shift and go to state 166

state 138

    (60) assign -> id = expression ; .

    MOD             reduce using rule 60 (assign -> id = expression ; .)
    IF              reduce using rule 60 (assign -> id = expression ; .)
    INPUT           reduce using rule 60 (assign -> id = expression ; .)
    ECHO            reduce using rule 60 (assign -> id = expression ; .)
    WHILE           reduce using rule 60 (assign -> id = expression ; .)
    REPLAY          reduce using rule 60 (assign -> id = expression ; .)
    SAMPLE          reduce using rule 60 (assign -> id = expression ; .)
    #               reduce using rule 60 (assign -> id = expression ; .)
    ARR             reduce using rule 60 (assign -> id = expression ; .)
    MAT             reduce using rule 60 (assign -> id = expression ; .)
    RAND            reduce using rule 60 (assign -> id = expression ; .)
    RETURN          reduce using rule 60 (assign -> id = expression ; .)
    ID              reduce using rule 60 (assign -> id = expression ; .)
    OVAL            reduce using rule 60 (assign -> id = expression ; .)
    TRIO            reduce using rule 60 (assign -> id = expression ; .)
    QUAD            reduce using rule 60 (assign -> id = expression ; .)
    ARC             reduce using rule 60 (assign -> id = expression ; .)
    END             reduce using rule 60 (assign -> id = expression ; .)
    }               reduce using rule 60 (assign -> id = expression ; .)


state 139

    (44) maincalling -> insertEra . callingA
    (47) callingA -> . callingB
    (48) callingA -> . empty
    (49) callingB -> . exp checkParam callingC
    (134) empty -> .
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    )               reduce using rule 134 (empty -> .)
    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    var_cte                        shift and go to state 44
    callID                         shift and go to state 6
    callingA                       shift and go to state 168
    callingB                       shift and go to state 169
    exp                            shift and go to state 170
    factor                         shift and go to state 48
    id                             shift and go to state 46
    empty                          shift and go to state 167

state 140

    (43) calling2 -> ( maincalling . )

    )               shift and go to state 171


state 141

    (42) calling -> # callID calling2 ; .

    MOD             reduce using rule 42 (calling -> # callID calling2 ; .)
    IF              reduce using rule 42 (calling -> # callID calling2 ; .)
    INPUT           reduce using rule 42 (calling -> # callID calling2 ; .)
    ECHO            reduce using rule 42 (calling -> # callID calling2 ; .)
    WHILE           reduce using rule 42 (calling -> # callID calling2 ; .)
    REPLAY          reduce using rule 42 (calling -> # callID calling2 ; .)
    SAMPLE          reduce using rule 42 (calling -> # callID calling2 ; .)
    #               reduce using rule 42 (calling -> # callID calling2 ; .)
    ARR             reduce using rule 42 (calling -> # callID calling2 ; .)
    MAT             reduce using rule 42 (calling -> # callID calling2 ; .)
    RAND            reduce using rule 42 (calling -> # callID calling2 ; .)
    RETURN          reduce using rule 42 (calling -> # callID calling2 ; .)
    ID              reduce using rule 42 (calling -> # callID calling2 ; .)
    OVAL            reduce using rule 42 (calling -> # callID calling2 ; .)
    TRIO            reduce using rule 42 (calling -> # callID calling2 ; .)
    QUAD            reduce using rule 42 (calling -> # callID calling2 ; .)
    ARC             reduce using rule 42 (calling -> # callID calling2 ; .)
    END             reduce using rule 42 (calling -> # callID calling2 ; .)
    }               reduce using rule 42 (calling -> # callID calling2 ; .)


state 142

    (61) condition -> IF ( expression ) . gotoFalse block conditionA continueGo
    (126) gotoFalse -> .

    {               reduce using rule 126 (gotoFalse -> .)

    gotoFalse                      shift and go to state 172

state 143

    (71) writeB -> , . writeA
    (69) writeA -> . expression
    (70) writeA -> . CTE_STRING
    (87) expression -> . exp = = exp
    (88) expression -> . exp < > exp
    (89) expression -> . exp < = exp
    (90) expression -> . exp > = exp
    (91) expression -> . exp > exp
    (92) expression -> . exp < exp
    (93) expression -> . exp AND exp
    (94) expression -> . exp OR exp
    (95) expression -> . exp empty
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    CTE_STRING      shift and go to state 99
    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 82
    factor                         shift and go to state 48
    writeA                         shift and go to state 173
    expression                     shift and go to state 100
    id                             shift and go to state 46

state 144

    (68) write -> ECHO ( writeA writeB . ) ;

    )               shift and go to state 174


state 145

    (72) writeB -> empty .

    )               reduce using rule 72 (writeB -> empty .)


state 146

    (81) commandA -> OFF move exp . ;
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ;               shift and go to state 175
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 147

    (80) commandA -> ON move exp . CTE_INTEGER color ;
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 176
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 148

    (67) read -> INPUT typeDim ID # . ;

    ;               shift and go to state 177


state 149

    (36) id -> ID initdim [ sumdim . exp ] [ sumdim exp ]
    (37) id -> ID initdim [ sumdim . exp ]
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 178
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 150

    (73) array -> ARR typeDim ID [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 179


state 151

    (74) matrix -> MAT typeDim ID [ . CTE_INTEGER ] [ CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 180


state 152

    (29) moduleID -> ID .

    (               reduce using rule 29 (moduleID -> ID .)
    {               reduce using rule 29 (moduleID -> ID .)


state 153

    (26) module -> MOD typeMod # moduleID . addMod insertQuadMod moduleA endMod
    (25) addMod -> .

    (               reduce using rule 25 (addMod -> .)
    {               reduce using rule 25 (addMod -> .)

    addMod                         shift and go to state 181

state 154

    (64) random -> RAND typeRand ID CTE_INTEGER ; .

    MOD             reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    IF              reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    INPUT           reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    ECHO            reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    WHILE           reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    REPLAY          reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    SAMPLE          reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    #               reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    ARR             reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    MAT             reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    RAND            reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    RETURN          reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    ID              reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    OVAL            reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    TRIO            reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    QUAD            reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    ARC             reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    END             reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)
    }               reduce using rule 64 (random -> RAND typeRand ID CTE_INTEGER ; .)


state 155

    (93) expression -> exp AND exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 93 (expression -> exp AND exp .)
    )               reduce using rule 93 (expression -> exp AND exp .)
    ;               reduce using rule 93 (expression -> exp AND exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 156

    (89) expression -> exp < = . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 182
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 157

    (88) expression -> exp < > . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 183
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 158

    (92) expression -> exp < exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 92 (expression -> exp < exp .)
    )               reduce using rule 92 (expression -> exp < exp .)
    ;               reduce using rule 92 (expression -> exp < exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 159

    (87) expression -> exp = = . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 184
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 160

    (94) expression -> exp OR exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 94 (expression -> exp OR exp .)
    )               reduce using rule 94 (expression -> exp OR exp .)
    ;               reduce using rule 94 (expression -> exp OR exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 161

    (90) expression -> exp > = . exp
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 185
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 162

    (91) expression -> exp > exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 91 (expression -> exp > exp .)
    )               reduce using rule 91 (expression -> exp > exp .)
    ;               reduce using rule 91 (expression -> exp > exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 163

    (78) command -> figure exp exp color ; .

    SAMPLE          reduce using rule 78 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 78 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 78 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 78 (command -> figure exp exp color ; .)
    ARC             reduce using rule 78 (command -> figure exp exp color ; .)
    ]               reduce using rule 78 (command -> figure exp exp color ; .)
    IF              reduce using rule 78 (command -> figure exp exp color ; .)
    INPUT           reduce using rule 78 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 78 (command -> figure exp exp color ; .)
    WHILE           reduce using rule 78 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 78 (command -> figure exp exp color ; .)
    #               reduce using rule 78 (command -> figure exp exp color ; .)
    ARR             reduce using rule 78 (command -> figure exp exp color ; .)
    MAT             reduce using rule 78 (command -> figure exp exp color ; .)
    RAND            reduce using rule 78 (command -> figure exp exp color ; .)
    RETURN          reduce using rule 78 (command -> figure exp exp color ; .)
    ID              reduce using rule 78 (command -> figure exp exp color ; .)
    }               reduce using rule 78 (command -> figure exp exp color ; .)
    MOD             reduce using rule 78 (command -> figure exp exp color ; .)
    END             reduce using rule 78 (command -> figure exp exp color ; .)


state 164

    (82) cycle -> WHILE gotoW ( expression ) . gotoFalse block continueGoW
    (126) gotoFalse -> .

    {               reduce using rule 126 (gotoFalse -> .)

    gotoFalse                      shift and go to state 186

state 165

    (83) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA . ] ;

    ]               shift and go to state 187


state 166

    (84) repeatA -> command . repeatB
    (85) repeatB -> . repeatA
    (86) repeatB -> . empty
    (84) repeatA -> . command repeatB
    (134) empty -> .
    (78) command -> . figure exp exp color ;
    (79) command -> . SAMPLE commandA
    (104) figure -> . OVAL
    (105) figure -> . TRIO
    (106) figure -> . QUAD
    (107) figure -> . ARC

    ]               reduce using rule 134 (empty -> .)
    SAMPLE          shift and go to state 25
    OVAL            shift and go to state 9
    TRIO            shift and go to state 20
    QUAD            shift and go to state 12
    ARC             shift and go to state 36

    figure                         shift and go to state 5
    repeatA                        shift and go to state 188
    repeatB                        shift and go to state 189
    command                        shift and go to state 166
    empty                          shift and go to state 190

state 167

    (48) callingA -> empty .

    )               reduce using rule 48 (callingA -> empty .)


state 168

    (44) maincalling -> insertEra callingA .

    )               reduce using rule 44 (maincalling -> insertEra callingA .)


state 169

    (47) callingA -> callingB .

    )               reduce using rule 47 (callingA -> callingB .)


state 170

    (49) callingB -> exp . checkParam callingC
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp
    (50) checkParam -> .

    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88
    ,               reduce using rule 50 (checkParam -> .)
    )               reduce using rule 50 (checkParam -> .)

    checkParam                     shift and go to state 191

state 171

    (43) calling2 -> ( maincalling ) .

    ;               reduce using rule 43 (calling2 -> ( maincalling ) .)
    =               reduce using rule 43 (calling2 -> ( maincalling ) .)
    +               reduce using rule 43 (calling2 -> ( maincalling ) .)
    -               reduce using rule 43 (calling2 -> ( maincalling ) .)
    *               reduce using rule 43 (calling2 -> ( maincalling ) .)
    /               reduce using rule 43 (calling2 -> ( maincalling ) .)
    (               reduce using rule 43 (calling2 -> ( maincalling ) .)
    CTE_INTEGER     reduce using rule 43 (calling2 -> ( maincalling ) .)
    CTE_FLOAT       reduce using rule 43 (calling2 -> ( maincalling ) .)
    TRUE            reduce using rule 43 (calling2 -> ( maincalling ) .)
    FALSE           reduce using rule 43 (calling2 -> ( maincalling ) .)
    ID              reduce using rule 43 (calling2 -> ( maincalling ) .)
    <               reduce using rule 43 (calling2 -> ( maincalling ) .)
    >               reduce using rule 43 (calling2 -> ( maincalling ) .)
    AND             reduce using rule 43 (calling2 -> ( maincalling ) .)
    OR              reduce using rule 43 (calling2 -> ( maincalling ) .)
    )               reduce using rule 43 (calling2 -> ( maincalling ) .)
    RED             reduce using rule 43 (calling2 -> ( maincalling ) .)
    YELLOW          reduce using rule 43 (calling2 -> ( maincalling ) .)
    BLUE            reduce using rule 43 (calling2 -> ( maincalling ) .)
    GREEN           reduce using rule 43 (calling2 -> ( maincalling ) .)
    BLACK           reduce using rule 43 (calling2 -> ( maincalling ) .)
    WHITE           reduce using rule 43 (calling2 -> ( maincalling ) .)
    ORANGE          reduce using rule 43 (calling2 -> ( maincalling ) .)
    PURPLE          reduce using rule 43 (calling2 -> ( maincalling ) .)
    CYAN            reduce using rule 43 (calling2 -> ( maincalling ) .)
    ,               reduce using rule 43 (calling2 -> ( maincalling ) .)
    ]               reduce using rule 43 (calling2 -> ( maincalling ) .)


state 172

    (61) condition -> IF ( expression ) gotoFalse . block conditionA continueGo
    (54) block -> . { blockA

    {               shift and go to state 192

    block                          shift and go to state 193

state 173

    (71) writeB -> , writeA .

    )               reduce using rule 71 (writeB -> , writeA .)


state 174

    (68) write -> ECHO ( writeA writeB ) . ;

    ;               shift and go to state 194


state 175

    (81) commandA -> OFF move exp ; .

    MOD             reduce using rule 81 (commandA -> OFF move exp ; .)
    IF              reduce using rule 81 (commandA -> OFF move exp ; .)
    INPUT           reduce using rule 81 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 81 (commandA -> OFF move exp ; .)
    WHILE           reduce using rule 81 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 81 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 81 (commandA -> OFF move exp ; .)
    #               reduce using rule 81 (commandA -> OFF move exp ; .)
    ARR             reduce using rule 81 (commandA -> OFF move exp ; .)
    MAT             reduce using rule 81 (commandA -> OFF move exp ; .)
    RAND            reduce using rule 81 (commandA -> OFF move exp ; .)
    RETURN          reduce using rule 81 (commandA -> OFF move exp ; .)
    ID              reduce using rule 81 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 81 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 81 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 81 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 81 (commandA -> OFF move exp ; .)
    END             reduce using rule 81 (commandA -> OFF move exp ; .)
    ]               reduce using rule 81 (commandA -> OFF move exp ; .)
    }               reduce using rule 81 (commandA -> OFF move exp ; .)


state 176

    (80) commandA -> ON move exp CTE_INTEGER . color ;
    (112) color -> . RED
    (113) color -> . YELLOW
    (114) color -> . BLUE
    (115) color -> . GREEN
    (116) color -> . BLACK
    (117) color -> . WHITE
    (118) color -> . ORANGE
    (119) color -> . PURPLE
    (120) color -> . CYAN

    RED             shift and go to state 134
    YELLOW          shift and go to state 129
    BLUE            shift and go to state 125
    GREEN           shift and go to state 128
    BLACK           shift and go to state 132
    WHITE           shift and go to state 133
    ORANGE          shift and go to state 131
    PURPLE          shift and go to state 127
    CYAN            shift and go to state 130

    color                          shift and go to state 195

state 177

    (67) read -> INPUT typeDim ID # ; .

    IF              reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    INPUT           reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    ECHO            reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    WHILE           reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    REPLAY          reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    SAMPLE          reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    #               reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    ARR             reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    MAT             reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    RAND            reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    RETURN          reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    ID              reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    OVAL            reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    TRIO            reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    QUAD            reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    ARC             reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    }               reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    MOD             reduce using rule 67 (read -> INPUT typeDim ID # ; .)
    END             reduce using rule 67 (read -> INPUT typeDim ID # ; .)


state 178

    (36) id -> ID initdim [ sumdim exp . ] [ sumdim exp ]
    (37) id -> ID initdim [ sumdim exp . ]
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ]               shift and go to state 196
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 179

    (73) array -> ARR typeDim ID [ CTE_INTEGER . ] ;

    ]               shift and go to state 197


state 180

    (74) matrix -> MAT typeDim ID [ CTE_INTEGER . ] [ CTE_INTEGER ] ;

    ]               shift and go to state 198


state 181

    (26) module -> MOD typeMod # moduleID addMod . insertQuadMod moduleA endMod
    (132) insertQuadMod -> .

    (               reduce using rule 132 (insertQuadMod -> .)
    {               reduce using rule 132 (insertQuadMod -> .)

    insertQuadMod                  shift and go to state 199

state 182

    (89) expression -> exp < = exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 89 (expression -> exp < = exp .)
    )               reduce using rule 89 (expression -> exp < = exp .)
    ;               reduce using rule 89 (expression -> exp < = exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 183

    (88) expression -> exp < > exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 88 (expression -> exp < > exp .)
    )               reduce using rule 88 (expression -> exp < > exp .)
    ;               reduce using rule 88 (expression -> exp < > exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 184

    (87) expression -> exp = = exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 87 (expression -> exp = = exp .)
    )               reduce using rule 87 (expression -> exp = = exp .)
    ;               reduce using rule 87 (expression -> exp = = exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 185

    (90) expression -> exp > = exp .
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ,               reduce using rule 90 (expression -> exp > = exp .)
    )               reduce using rule 90 (expression -> exp > = exp .)
    ;               reduce using rule 90 (expression -> exp > = exp .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 186

    (82) cycle -> WHILE gotoW ( expression ) gotoFalse . block continueGoW
    (54) block -> . { blockA

    {               shift and go to state 192

    block                          shift and go to state 200

state 187

    (83) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] . ;

    ;               shift and go to state 201


state 188

    (85) repeatB -> repeatA .

    ]               reduce using rule 85 (repeatB -> repeatA .)


state 189

    (84) repeatA -> command repeatB .

    ]               reduce using rule 84 (repeatA -> command repeatB .)


state 190

    (86) repeatB -> empty .

    ]               reduce using rule 86 (repeatB -> empty .)


state 191

    (49) callingB -> exp checkParam . callingC
    (51) callingC -> . , sumXparam callingB
    (52) callingC -> . empty
    (134) empty -> .

    ,               shift and go to state 202
    )               reduce using rule 134 (empty -> .)

    callingC                       shift and go to state 203
    empty                          shift and go to state 204

state 192

    (54) block -> { . blockA
    (55) blockA -> . blockB }
    (56) blockA -> . }
    (57) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . random
    (20) statute -> . return
    (60) assign -> . id = expression ;
    (61) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (67) read -> . INPUT typeDim ID # ;
    (68) write -> . ECHO ( writeA writeB ) ;
    (82) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (83) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (78) command -> . figure exp exp color ;
    (79) command -> . SAMPLE commandA
    (42) calling -> . # callID calling2 ;
    (73) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (74) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (64) random -> . RAND typeRand ID CTE_INTEGER ;
    (101) return -> . RETURN exp ;
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (104) figure -> . OVAL
    (105) figure -> . TRIO
    (106) figure -> . QUAD
    (107) figure -> . ARC
    (45) callID -> . ID

    }               shift and go to state 206
    IF              shift and go to state 19
    INPUT           shift and go to state 28
    ECHO            shift and go to state 24
    WHILE           shift and go to state 10
    REPLAY          shift and go to state 11
    SAMPLE          shift and go to state 25
    #               shift and go to state 16
    ARR             shift and go to state 33
    MAT             shift and go to state 34
    RAND            shift and go to state 3
    RETURN          shift and go to state 4
    ID              shift and go to state 29
    OVAL            shift and go to state 9
    TRIO            shift and go to state 20
    QUAD            shift and go to state 12
    ARC             shift and go to state 36

    figure                         shift and go to state 5
    callID                         shift and go to state 6
    random                         shift and go to state 7
    array                          shift and go to state 14
    id                             shift and go to state 15
    matrix                         shift and go to state 17
    write                          shift and go to state 18
    command                        shift and go to state 37
    repeat                         shift and go to state 21
    return                         shift and go to state 13
    read                           shift and go to state 23
    condition                      shift and go to state 30
    cycle                          shift and go to state 31
    statute                        shift and go to state 205
    calling                        shift and go to state 35
    blockB                         shift and go to state 207
    blockA                         shift and go to state 208
    assign                         shift and go to state 39

state 193

    (61) condition -> IF ( expression ) gotoFalse block . conditionA continueGo
    (62) conditionA -> . ELSE gotoE block
    (63) conditionA -> . empty
    (134) empty -> .

    ELSE            shift and go to state 211
    MOD             reduce using rule 134 (empty -> .)
    IF              reduce using rule 134 (empty -> .)
    INPUT           reduce using rule 134 (empty -> .)
    ECHO            reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    REPLAY          reduce using rule 134 (empty -> .)
    SAMPLE          reduce using rule 134 (empty -> .)
    #               reduce using rule 134 (empty -> .)
    ARR             reduce using rule 134 (empty -> .)
    MAT             reduce using rule 134 (empty -> .)
    RAND            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    OVAL            reduce using rule 134 (empty -> .)
    TRIO            reduce using rule 134 (empty -> .)
    QUAD            reduce using rule 134 (empty -> .)
    ARC             reduce using rule 134 (empty -> .)
    END             reduce using rule 134 (empty -> .)
    }               reduce using rule 134 (empty -> .)

    conditionA                     shift and go to state 209
    empty                          shift and go to state 210

state 194

    (68) write -> ECHO ( writeA writeB ) ; .

    MOD             reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    IF              reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    INPUT           reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    ECHO            reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    WHILE           reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    REPLAY          reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    SAMPLE          reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    #               reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    ARR             reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    MAT             reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    RAND            reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    RETURN          reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    ID              reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    OVAL            reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    TRIO            reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    QUAD            reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    ARC             reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    END             reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)
    }               reduce using rule 68 (write -> ECHO ( writeA writeB ) ; .)


state 195

    (80) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 212


state 196

    (36) id -> ID initdim [ sumdim exp ] . [ sumdim exp ]
    (37) id -> ID initdim [ sumdim exp ] .

    [               shift and go to state 213
    +               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    -               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    *               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    /               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    )               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    ;               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    ,               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    ]               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    RED             reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    YELLOW          reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    BLUE            reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    GREEN           reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    BLACK           reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    WHITE           reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    ORANGE          reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    PURPLE          reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    CYAN            reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    =               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    (               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    TRUE            reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    FALSE           reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    ID              reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    <               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    >               reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    AND             reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)
    OR              reduce using rule 37 (id -> ID initdim [ sumdim exp ] .)


state 197

    (73) array -> ARR typeDim ID [ CTE_INTEGER ] . ;

    ;               shift and go to state 214


state 198

    (74) matrix -> MAT typeDim ID [ CTE_INTEGER ] . [ CTE_INTEGER ] ;

    [               shift and go to state 215


state 199

    (26) module -> MOD typeMod # moduleID addMod insertQuadMod . moduleA endMod
    (27) moduleA -> . ( vars ) block
    (28) moduleA -> . block
    (54) block -> . { blockA

    (               shift and go to state 216
    {               shift and go to state 192

    block                          shift and go to state 217
    moduleA                        shift and go to state 218

state 200

    (82) cycle -> WHILE gotoW ( expression ) gotoFalse block . continueGoW
    (131) continueGoW -> .

    MOD             reduce using rule 131 (continueGoW -> .)
    IF              reduce using rule 131 (continueGoW -> .)
    INPUT           reduce using rule 131 (continueGoW -> .)
    ECHO            reduce using rule 131 (continueGoW -> .)
    WHILE           reduce using rule 131 (continueGoW -> .)
    REPLAY          reduce using rule 131 (continueGoW -> .)
    SAMPLE          reduce using rule 131 (continueGoW -> .)
    #               reduce using rule 131 (continueGoW -> .)
    ARR             reduce using rule 131 (continueGoW -> .)
    MAT             reduce using rule 131 (continueGoW -> .)
    RAND            reduce using rule 131 (continueGoW -> .)
    RETURN          reduce using rule 131 (continueGoW -> .)
    ID              reduce using rule 131 (continueGoW -> .)
    OVAL            reduce using rule 131 (continueGoW -> .)
    TRIO            reduce using rule 131 (continueGoW -> .)
    QUAD            reduce using rule 131 (continueGoW -> .)
    ARC             reduce using rule 131 (continueGoW -> .)
    END             reduce using rule 131 (continueGoW -> .)
    }               reduce using rule 131 (continueGoW -> .)

    continueGoW                    shift and go to state 219

state 201

    (83) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .

    MOD             reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    IF              reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    INPUT           reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ECHO            reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHILE           reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    REPLAY          reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    SAMPLE          reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    #               reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARR             reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MAT             reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    RAND            reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    RETURN          reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ID              reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    OVAL            reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    TRIO            reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    QUAD            reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARC             reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    END             reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    }               reduce using rule 83 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)


state 202

    (51) callingC -> , . sumXparam callingB
    (53) sumXparam -> .

    (               reduce using rule 53 (sumXparam -> .)
    CTE_INTEGER     reduce using rule 53 (sumXparam -> .)
    CTE_FLOAT       reduce using rule 53 (sumXparam -> .)
    TRUE            reduce using rule 53 (sumXparam -> .)
    FALSE           reduce using rule 53 (sumXparam -> .)
    ID              reduce using rule 53 (sumXparam -> .)

    sumXparam                      shift and go to state 220

state 203

    (49) callingB -> exp checkParam callingC .

    )               reduce using rule 49 (callingB -> exp checkParam callingC .)


state 204

    (52) callingC -> empty .

    )               reduce using rule 52 (callingC -> empty .)


state 205

    (57) blockB -> statute . blockC
    (58) blockC -> . blockB
    (59) blockC -> . empty
    (57) blockB -> . statute blockC
    (134) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . random
    (20) statute -> . return
    (60) assign -> . id = expression ;
    (61) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (67) read -> . INPUT typeDim ID # ;
    (68) write -> . ECHO ( writeA writeB ) ;
    (82) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (83) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (78) command -> . figure exp exp color ;
    (79) command -> . SAMPLE commandA
    (42) calling -> . # callID calling2 ;
    (73) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (74) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (64) random -> . RAND typeRand ID CTE_INTEGER ;
    (101) return -> . RETURN exp ;
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (104) figure -> . OVAL
    (105) figure -> . TRIO
    (106) figure -> . QUAD
    (107) figure -> . ARC
    (45) callID -> . ID

    }               reduce using rule 134 (empty -> .)
    IF              shift and go to state 19
    INPUT           shift and go to state 28
    ECHO            shift and go to state 24
    WHILE           shift and go to state 10
    REPLAY          shift and go to state 11
    SAMPLE          shift and go to state 25
    #               shift and go to state 16
    ARR             shift and go to state 33
    MAT             shift and go to state 34
    RAND            shift and go to state 3
    RETURN          shift and go to state 4
    ID              shift and go to state 29
    OVAL            shift and go to state 9
    TRIO            shift and go to state 20
    QUAD            shift and go to state 12
    ARC             shift and go to state 36

    figure                         shift and go to state 5
    callID                         shift and go to state 6
    random                         shift and go to state 7
    array                          shift and go to state 14
    id                             shift and go to state 15
    matrix                         shift and go to state 17
    write                          shift and go to state 18
    command                        shift and go to state 37
    empty                          shift and go to state 221
    repeat                         shift and go to state 21
    return                         shift and go to state 13
    read                           shift and go to state 23
    condition                      shift and go to state 30
    cycle                          shift and go to state 31
    statute                        shift and go to state 205
    calling                        shift and go to state 35
    blockC                         shift and go to state 222
    blockB                         shift and go to state 223
    assign                         shift and go to state 39

state 206

    (56) blockA -> } .

    ELSE            reduce using rule 56 (blockA -> } .)
    MOD             reduce using rule 56 (blockA -> } .)
    IF              reduce using rule 56 (blockA -> } .)
    INPUT           reduce using rule 56 (blockA -> } .)
    ECHO            reduce using rule 56 (blockA -> } .)
    WHILE           reduce using rule 56 (blockA -> } .)
    REPLAY          reduce using rule 56 (blockA -> } .)
    SAMPLE          reduce using rule 56 (blockA -> } .)
    #               reduce using rule 56 (blockA -> } .)
    ARR             reduce using rule 56 (blockA -> } .)
    MAT             reduce using rule 56 (blockA -> } .)
    RAND            reduce using rule 56 (blockA -> } .)
    RETURN          reduce using rule 56 (blockA -> } .)
    ID              reduce using rule 56 (blockA -> } .)
    OVAL            reduce using rule 56 (blockA -> } .)
    TRIO            reduce using rule 56 (blockA -> } .)
    QUAD            reduce using rule 56 (blockA -> } .)
    ARC             reduce using rule 56 (blockA -> } .)
    END             reduce using rule 56 (blockA -> } .)
    }               reduce using rule 56 (blockA -> } .)


state 207

    (55) blockA -> blockB . }

    }               shift and go to state 224


state 208

    (54) block -> { blockA .

    MOD             reduce using rule 54 (block -> { blockA .)
    IF              reduce using rule 54 (block -> { blockA .)
    INPUT           reduce using rule 54 (block -> { blockA .)
    ECHO            reduce using rule 54 (block -> { blockA .)
    WHILE           reduce using rule 54 (block -> { blockA .)
    REPLAY          reduce using rule 54 (block -> { blockA .)
    SAMPLE          reduce using rule 54 (block -> { blockA .)
    #               reduce using rule 54 (block -> { blockA .)
    ARR             reduce using rule 54 (block -> { blockA .)
    MAT             reduce using rule 54 (block -> { blockA .)
    RAND            reduce using rule 54 (block -> { blockA .)
    RETURN          reduce using rule 54 (block -> { blockA .)
    ID              reduce using rule 54 (block -> { blockA .)
    OVAL            reduce using rule 54 (block -> { blockA .)
    TRIO            reduce using rule 54 (block -> { blockA .)
    QUAD            reduce using rule 54 (block -> { blockA .)
    ARC             reduce using rule 54 (block -> { blockA .)
    END             reduce using rule 54 (block -> { blockA .)
    }               reduce using rule 54 (block -> { blockA .)
    ELSE            reduce using rule 54 (block -> { blockA .)


state 209

    (61) condition -> IF ( expression ) gotoFalse block conditionA . continueGo
    (130) continueGo -> .

    MOD             reduce using rule 130 (continueGo -> .)
    IF              reduce using rule 130 (continueGo -> .)
    INPUT           reduce using rule 130 (continueGo -> .)
    ECHO            reduce using rule 130 (continueGo -> .)
    WHILE           reduce using rule 130 (continueGo -> .)
    REPLAY          reduce using rule 130 (continueGo -> .)
    SAMPLE          reduce using rule 130 (continueGo -> .)
    #               reduce using rule 130 (continueGo -> .)
    ARR             reduce using rule 130 (continueGo -> .)
    MAT             reduce using rule 130 (continueGo -> .)
    RAND            reduce using rule 130 (continueGo -> .)
    RETURN          reduce using rule 130 (continueGo -> .)
    ID              reduce using rule 130 (continueGo -> .)
    OVAL            reduce using rule 130 (continueGo -> .)
    TRIO            reduce using rule 130 (continueGo -> .)
    QUAD            reduce using rule 130 (continueGo -> .)
    ARC             reduce using rule 130 (continueGo -> .)
    END             reduce using rule 130 (continueGo -> .)
    }               reduce using rule 130 (continueGo -> .)

    continueGo                     shift and go to state 225

state 210

    (63) conditionA -> empty .

    MOD             reduce using rule 63 (conditionA -> empty .)
    IF              reduce using rule 63 (conditionA -> empty .)
    INPUT           reduce using rule 63 (conditionA -> empty .)
    ECHO            reduce using rule 63 (conditionA -> empty .)
    WHILE           reduce using rule 63 (conditionA -> empty .)
    REPLAY          reduce using rule 63 (conditionA -> empty .)
    SAMPLE          reduce using rule 63 (conditionA -> empty .)
    #               reduce using rule 63 (conditionA -> empty .)
    ARR             reduce using rule 63 (conditionA -> empty .)
    MAT             reduce using rule 63 (conditionA -> empty .)
    RAND            reduce using rule 63 (conditionA -> empty .)
    RETURN          reduce using rule 63 (conditionA -> empty .)
    ID              reduce using rule 63 (conditionA -> empty .)
    OVAL            reduce using rule 63 (conditionA -> empty .)
    TRIO            reduce using rule 63 (conditionA -> empty .)
    QUAD            reduce using rule 63 (conditionA -> empty .)
    ARC             reduce using rule 63 (conditionA -> empty .)
    END             reduce using rule 63 (conditionA -> empty .)
    }               reduce using rule 63 (conditionA -> empty .)


state 211

    (62) conditionA -> ELSE . gotoE block
    (127) gotoE -> .

    {               reduce using rule 127 (gotoE -> .)

    gotoE                          shift and go to state 226

state 212

    (80) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    INPUT           reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHILE           reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARR             reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    MAT             reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    RAND            reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    RETURN          reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 80 (commandA -> ON move exp CTE_INTEGER color ; .)


state 213

    (36) id -> ID initdim [ sumdim exp ] [ . sumdim exp ]
    (41) sumdim -> .

    (               reduce using rule 41 (sumdim -> .)
    CTE_INTEGER     reduce using rule 41 (sumdim -> .)
    CTE_FLOAT       reduce using rule 41 (sumdim -> .)
    TRUE            reduce using rule 41 (sumdim -> .)
    FALSE           reduce using rule 41 (sumdim -> .)
    ID              reduce using rule 41 (sumdim -> .)

    sumdim                         shift and go to state 227

state 214

    (73) array -> ARR typeDim ID [ CTE_INTEGER ] ; .

    MOD             reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    IF              reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    INPUT           reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    #               reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    RAND            reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    RETURN          reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ID              reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    END             reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    }               reduce using rule 73 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)


state 215

    (74) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 228


state 216

    (27) moduleA -> ( . vars ) block
    (30) vars -> . type ID varsA
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . BOOL

    INT             shift and go to state 231
    FLOAT           shift and go to state 230
    BOOL            shift and go to state 232

    type                           shift and go to state 233
    vars                           shift and go to state 229

state 217

    (28) moduleA -> block .

    MOD             reduce using rule 28 (moduleA -> block .)
    IF              reduce using rule 28 (moduleA -> block .)
    INPUT           reduce using rule 28 (moduleA -> block .)
    ECHO            reduce using rule 28 (moduleA -> block .)
    WHILE           reduce using rule 28 (moduleA -> block .)
    REPLAY          reduce using rule 28 (moduleA -> block .)
    SAMPLE          reduce using rule 28 (moduleA -> block .)
    #               reduce using rule 28 (moduleA -> block .)
    ARR             reduce using rule 28 (moduleA -> block .)
    MAT             reduce using rule 28 (moduleA -> block .)
    RAND            reduce using rule 28 (moduleA -> block .)
    RETURN          reduce using rule 28 (moduleA -> block .)
    ID              reduce using rule 28 (moduleA -> block .)
    OVAL            reduce using rule 28 (moduleA -> block .)
    TRIO            reduce using rule 28 (moduleA -> block .)
    QUAD            reduce using rule 28 (moduleA -> block .)
    ARC             reduce using rule 28 (moduleA -> block .)
    END             reduce using rule 28 (moduleA -> block .)


state 218

    (26) module -> MOD typeMod # moduleID addMod insertQuadMod moduleA . endMod
    (133) endMod -> .

    MOD             reduce using rule 133 (endMod -> .)
    IF              reduce using rule 133 (endMod -> .)
    INPUT           reduce using rule 133 (endMod -> .)
    ECHO            reduce using rule 133 (endMod -> .)
    WHILE           reduce using rule 133 (endMod -> .)
    REPLAY          reduce using rule 133 (endMod -> .)
    SAMPLE          reduce using rule 133 (endMod -> .)
    #               reduce using rule 133 (endMod -> .)
    ARR             reduce using rule 133 (endMod -> .)
    MAT             reduce using rule 133 (endMod -> .)
    RAND            reduce using rule 133 (endMod -> .)
    RETURN          reduce using rule 133 (endMod -> .)
    ID              reduce using rule 133 (endMod -> .)
    OVAL            reduce using rule 133 (endMod -> .)
    TRIO            reduce using rule 133 (endMod -> .)
    QUAD            reduce using rule 133 (endMod -> .)
    ARC             reduce using rule 133 (endMod -> .)
    END             reduce using rule 133 (endMod -> .)

    endMod                         shift and go to state 234

state 219

    (82) cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .

    MOD             reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    IF              reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    INPUT           reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ECHO            reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHILE           reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    REPLAY          reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    SAMPLE          reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    #               reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARR             reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    MAT             reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    RAND            reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    RETURN          reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ID              reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    OVAL            reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    TRIO            reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    QUAD            reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARC             reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    END             reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    }               reduce using rule 82 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)


state 220

    (51) callingC -> , sumXparam . callingB
    (49) callingB -> . exp checkParam callingC
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    var_cte                        shift and go to state 44
    callID                         shift and go to state 6
    callingB                       shift and go to state 235
    exp                            shift and go to state 170
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 221

    (59) blockC -> empty .

    }               reduce using rule 59 (blockC -> empty .)


state 222

    (57) blockB -> statute blockC .

    }               reduce using rule 57 (blockB -> statute blockC .)


state 223

    (58) blockC -> blockB .

    }               reduce using rule 58 (blockC -> blockB .)


state 224

    (55) blockA -> blockB } .

    ELSE            reduce using rule 55 (blockA -> blockB } .)
    MOD             reduce using rule 55 (blockA -> blockB } .)
    IF              reduce using rule 55 (blockA -> blockB } .)
    INPUT           reduce using rule 55 (blockA -> blockB } .)
    ECHO            reduce using rule 55 (blockA -> blockB } .)
    WHILE           reduce using rule 55 (blockA -> blockB } .)
    REPLAY          reduce using rule 55 (blockA -> blockB } .)
    SAMPLE          reduce using rule 55 (blockA -> blockB } .)
    #               reduce using rule 55 (blockA -> blockB } .)
    ARR             reduce using rule 55 (blockA -> blockB } .)
    MAT             reduce using rule 55 (blockA -> blockB } .)
    RAND            reduce using rule 55 (blockA -> blockB } .)
    RETURN          reduce using rule 55 (blockA -> blockB } .)
    ID              reduce using rule 55 (blockA -> blockB } .)
    OVAL            reduce using rule 55 (blockA -> blockB } .)
    TRIO            reduce using rule 55 (blockA -> blockB } .)
    QUAD            reduce using rule 55 (blockA -> blockB } .)
    ARC             reduce using rule 55 (blockA -> blockB } .)
    END             reduce using rule 55 (blockA -> blockB } .)
    }               reduce using rule 55 (blockA -> blockB } .)


state 225

    (61) condition -> IF ( expression ) gotoFalse block conditionA continueGo .

    MOD             reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    IF              reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    INPUT           reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ECHO            reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHILE           reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    REPLAY          reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    SAMPLE          reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    #               reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARR             reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MAT             reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    RAND            reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    RETURN          reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ID              reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    OVAL            reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    TRIO            reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    QUAD            reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARC             reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    END             reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    }               reduce using rule 61 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)


state 226

    (62) conditionA -> ELSE gotoE . block
    (54) block -> . { blockA

    {               shift and go to state 192

    block                          shift and go to state 236

state 227

    (36) id -> ID initdim [ sumdim exp ] [ sumdim . exp ]
    (96) exp -> . exp + exp
    (97) exp -> . exp - exp
    (98) exp -> . exp * exp
    (99) exp -> . exp / exp
    (100) exp -> . factor empty
    (102) factor -> . ( expression )
    (103) factor -> . var_cte
    (121) var_cte -> . id
    (122) var_cte -> . CTE_INTEGER
    (123) var_cte -> . CTE_FLOAT
    (124) var_cte -> . TRUE
    (125) var_cte -> . FALSE
    (36) id -> . ID initdim [ sumdim exp ] [ sumdim exp ]
    (37) id -> . ID initdim [ sumdim exp ]
    (38) id -> . callID initdim # calling2
    (39) id -> . ID initdim empty
    (45) callID -> . ID

    (               shift and go to state 47
    CTE_INTEGER     shift and go to state 49
    CTE_FLOAT       shift and go to state 51
    TRUE            shift and go to state 45
    FALSE           shift and go to state 50
    ID              shift and go to state 29

    callID                         shift and go to state 6
    var_cte                        shift and go to state 44
    exp                            shift and go to state 237
    factor                         shift and go to state 48
    id                             shift and go to state 46

state 228

    (74) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER . ] ;

    ]               shift and go to state 238


state 229

    (27) moduleA -> ( vars . ) block

    )               shift and go to state 239


state 230

    (34) type -> FLOAT .

    ID              reduce using rule 34 (type -> FLOAT .)


state 231

    (33) type -> INT .

    ID              reduce using rule 33 (type -> INT .)


state 232

    (35) type -> BOOL .

    ID              reduce using rule 35 (type -> BOOL .)


state 233

    (30) vars -> type . ID varsA

    ID              shift and go to state 240


state 234

    (26) module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .

    MOD             reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    IF              reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    INPUT           reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ECHO            reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    WHILE           reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    REPLAY          reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    SAMPLE          reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    #               reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ARR             reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    MAT             reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    RAND            reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    RETURN          reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ID              reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    OVAL            reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    TRIO            reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    QUAD            reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ARC             reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    END             reduce using rule 26 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)


state 235

    (51) callingC -> , sumXparam callingB .

    )               reduce using rule 51 (callingC -> , sumXparam callingB .)


state 236

    (62) conditionA -> ELSE gotoE block .

    MOD             reduce using rule 62 (conditionA -> ELSE gotoE block .)
    IF              reduce using rule 62 (conditionA -> ELSE gotoE block .)
    INPUT           reduce using rule 62 (conditionA -> ELSE gotoE block .)
    ECHO            reduce using rule 62 (conditionA -> ELSE gotoE block .)
    WHILE           reduce using rule 62 (conditionA -> ELSE gotoE block .)
    REPLAY          reduce using rule 62 (conditionA -> ELSE gotoE block .)
    SAMPLE          reduce using rule 62 (conditionA -> ELSE gotoE block .)
    #               reduce using rule 62 (conditionA -> ELSE gotoE block .)
    ARR             reduce using rule 62 (conditionA -> ELSE gotoE block .)
    MAT             reduce using rule 62 (conditionA -> ELSE gotoE block .)
    RAND            reduce using rule 62 (conditionA -> ELSE gotoE block .)
    RETURN          reduce using rule 62 (conditionA -> ELSE gotoE block .)
    ID              reduce using rule 62 (conditionA -> ELSE gotoE block .)
    OVAL            reduce using rule 62 (conditionA -> ELSE gotoE block .)
    TRIO            reduce using rule 62 (conditionA -> ELSE gotoE block .)
    QUAD            reduce using rule 62 (conditionA -> ELSE gotoE block .)
    ARC             reduce using rule 62 (conditionA -> ELSE gotoE block .)
    END             reduce using rule 62 (conditionA -> ELSE gotoE block .)
    }               reduce using rule 62 (conditionA -> ELSE gotoE block .)


state 237

    (36) id -> ID initdim [ sumdim exp ] [ sumdim exp . ]
    (96) exp -> exp . + exp
    (97) exp -> exp . - exp
    (98) exp -> exp . * exp
    (99) exp -> exp . / exp

    ]               shift and go to state 241
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 238

    (74) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] . ;

    ;               shift and go to state 242


state 239

    (27) moduleA -> ( vars ) . block
    (54) block -> . { blockA

    {               shift and go to state 192

    block                          shift and go to state 243

state 240

    (30) vars -> type ID . varsA
    (31) varsA -> . , vars
    (32) varsA -> . empty
    (134) empty -> .

    ,               shift and go to state 245
    )               reduce using rule 134 (empty -> .)

    varsA                          shift and go to state 244
    empty                          shift and go to state 246

state 241

    (36) id -> ID initdim [ sumdim exp ] [ sumdim exp ] .

    +               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    -               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    *               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    /               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    )               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    ;               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    ,               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    ]               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    RED             reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    YELLOW          reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    BLUE            reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    GREEN           reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    BLACK           reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    WHITE           reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    ORANGE          reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    PURPLE          reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    CYAN            reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    =               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    (               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    TRUE            reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    FALSE           reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    ID              reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    <               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    >               reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    AND             reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)
    OR              reduce using rule 36 (id -> ID initdim [ sumdim exp ] [ sumdim exp ] .)


state 242

    (74) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .

    MOD             reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    IF              reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    INPUT           reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    #               reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    RAND            reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    RETURN          reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ID              reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    END             reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    }               reduce using rule 74 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)


state 243

    (27) moduleA -> ( vars ) block .

    MOD             reduce using rule 27 (moduleA -> ( vars ) block .)
    IF              reduce using rule 27 (moduleA -> ( vars ) block .)
    INPUT           reduce using rule 27 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 27 (moduleA -> ( vars ) block .)
    WHILE           reduce using rule 27 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 27 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 27 (moduleA -> ( vars ) block .)
    #               reduce using rule 27 (moduleA -> ( vars ) block .)
    ARR             reduce using rule 27 (moduleA -> ( vars ) block .)
    MAT             reduce using rule 27 (moduleA -> ( vars ) block .)
    RAND            reduce using rule 27 (moduleA -> ( vars ) block .)
    RETURN          reduce using rule 27 (moduleA -> ( vars ) block .)
    ID              reduce using rule 27 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 27 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 27 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 27 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 27 (moduleA -> ( vars ) block .)
    END             reduce using rule 27 (moduleA -> ( vars ) block .)


state 244

    (30) vars -> type ID varsA .

    )               reduce using rule 30 (vars -> type ID varsA .)


state 245

    (31) varsA -> , . vars
    (30) vars -> . type ID varsA
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . BOOL

    INT             shift and go to state 231
    FLOAT           shift and go to state 230
    BOOL            shift and go to state 232

    type                           shift and go to state 233
    vars                           shift and go to state 247

state 246

    (32) varsA -> empty .

    )               reduce using rule 32 (varsA -> empty .)


state 247

    (31) varsA -> , vars .

    )               reduce using rule 31 (varsA -> , vars .)

