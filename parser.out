Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> write
Rule 12    statute -> repeat
Rule 13    statute -> command
Rule 14    statute -> calling
Rule 15    statute -> pipeline
Rule 16    statute -> screen
Rule 17    module -> MOD # ID moduleA
Rule 18    moduleA -> ( vars ) block
Rule 19    moduleA -> block
Rule 20    vars -> type ID varsA
Rule 21    varsA -> , vars
Rule 22    varsA -> empty
Rule 23    type -> INT
Rule 24    type -> FLOAT
Rule 25    type -> BOOL
Rule 26    calling -> # ID ( callingA
Rule 27    callingA -> callingB ) ;
Rule 28    callingA -> ) ;
Rule 29    callingB -> expression callingC
Rule 30    callingC -> , callingB
Rule 31    callingC -> empty
Rule 32    block -> { blockA
Rule 33    blockA -> blockB }
Rule 34    blockA -> }
Rule 35    blockB -> statute blockC
Rule 36    blockC -> blockB
Rule 37    blockC -> empty
Rule 38    assign -> ID = expression ;
Rule 39    condition -> IF ( expression ) block conditionA
Rule 40    conditionA -> ELSE block
Rule 41    conditionA -> empty
Rule 42    write -> ECHO expression ;
Rule 43    write -> " CTE_STRING " ;
Rule 44    pipeline -> PIPE ID pipelineA
Rule 45    pipelineA -> [ pipelineB ] ;
Rule 46    pipelineA -> IN ( var_cte ) ;
Rule 47    pipelineA -> OUT ( ) ;
Rule 48    pipelineA -> COUNT ;
Rule 49    pipelineB -> exp pipelineC
Rule 50    pipelineC -> , pipelineB
Rule 51    pipelineC -> empty
Rule 52    command -> figure exp exp color ;
Rule 53    command -> SAMPLE commandA
Rule 54    commandA -> ON move exp CTE_INTEGER color ;
Rule 55    commandA -> OFF move exp ;
Rule 56    repeat -> REPLAY CTE_INTEGER [ repeatA ] ;
Rule 57    repeatA -> command repeatB
Rule 58    repeatB -> repeatA
Rule 59    repeatB -> empty
Rule 60    expression -> exp = = exp
Rule 61    expression -> exp < > exp
Rule 62    expression -> exp < = exp
Rule 63    expression -> exp > = exp
Rule 64    expression -> exp > exp
Rule 65    expression -> exp < exp
Rule 66    expression -> exp AND exp
Rule 67    expression -> exp OR exp
Rule 68    expression -> exp empty
Rule 69    exp -> exp + exp
Rule 70    exp -> exp - exp
Rule 71    exp -> exp * exp
Rule 72    exp -> exp / exp
Rule 73    exp -> factor empty
Rule 74    factor -> ( expression )
Rule 75    factor -> var_cte
Rule 76    figure -> OVAL
Rule 77    figure -> TRIO
Rule 78    figure -> QUAD
Rule 79    figure -> ARC
Rule 80    move -> UP
Rule 81    move -> DOWN
Rule 82    move -> LEFT
Rule 83    move -> RIGHT
Rule 84    color -> RED
Rule 85    color -> YELLOW
Rule 86    color -> BLUE
Rule 87    color -> GREEN
Rule 88    color -> BLACK
Rule 89    color -> ORANGE
Rule 90    color -> PURPLE
Rule 91    color -> CYAN
Rule 92    screen -> WHERE
Rule 93    screen -> CLEAR
Rule 94    var_cte -> ID
Rule 95    var_cte -> CTE_INTEGER
Rule 96    var_cte -> CTE_FLOAT
Rule 97    var_cte -> TRUE
Rule 98    var_cte -> FALSE
Rule 99    empty -> <empty>

Terminals, with rules where they appear

"                    : 43 43
#                    : 17 26
(                    : 18 26 39 46 47 74
)                    : 18 27 28 39 46 47 74
*                    : 71
+                    : 69
,                    : 21 30 50
-                    : 70
/                    : 72
;                    : 27 28 38 42 43 45 46 47 48 52 54 55 56
<                    : 61 62 65
=                    : 38 60 60 62 63
>                    : 61 63 64
AND                  : 66
ARC                  : 79
BLACK                : 88
BLUE                 : 86
BOOL                 : 25
CLEAR                : 93
COUNT                : 48
CTE_FLOAT            : 96
CTE_INTEGER          : 54 56 95
CTE_STRING           : 43
CYAN                 : 91
DOWN                 : 81
ECHO                 : 42
ELSE                 : 40
END                  : 2 3
FALSE                : 98
FLOAT                : 24
GREEN                : 87
ID                   : 17 20 26 38 44 94
IF                   : 39
IN                   : 46
INIT                 : 1
INT                  : 23
LEFT                 : 82
MOD                  : 17
OFF                  : 55
ON                   : 54
OR                   : 67
ORANGE               : 89
OUT                  : 47
OVAL                 : 76
PIPE                 : 44
PURPLE               : 90
QUAD                 : 78
RED                  : 84
REPLAY               : 56
RIGHT                : 83
SAMPLE               : 53
TRIO                 : 77
TRUE                 : 97
UP                   : 80
WHERE                : 92
YELLOW               : 85
[                    : 45 56
]                    : 45 56
error                : 
{                    : 32
}                    : 33 34

Nonterminals, with rules where they appear

assign               : 9
block                : 18 19 39 40
blockA               : 32
blockB               : 33 36
blockC               : 35
calling              : 14
callingA             : 26
callingB             : 27 30
callingC             : 29
color                : 52 54
command              : 13 57
commandA             : 53
condition            : 10
conditionA           : 39
empty                : 6 22 31 37 41 51 59 68 73
exp                  : 49 52 52 54 55 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 69 69 70 70 71 71 72 72
expression           : 29 38 39 42 74
factor               : 73
figure               : 52
module               : 8
moduleA              : 17
move                 : 54 55
pipeline             : 15
pipelineA            : 44
pipelineB            : 45 50
pipelineC            : 49
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
repeat               : 12
repeatA              : 56 58
repeatB              : 57
screen               : 16
statute              : 7 35
type                 : 20
var_cte              : 46 75
vars                 : 18 21
varsA                : 20
workspace            : 4
write                : 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . repeat
    (13) statute -> . command
    (14) statute -> . calling
    (15) statute -> . pipeline
    (16) statute -> . screen
    (17) module -> . MOD # ID moduleA
    (38) assign -> . ID = expression ;
    (39) condition -> . IF ( expression ) block conditionA
    (42) write -> . ECHO expression ;
    (43) write -> . " CTE_STRING " ;
    (56) repeat -> . REPLAY CTE_INTEGER [ repeatA ] ;
    (52) command -> . figure exp exp color ;
    (53) command -> . SAMPLE commandA
    (26) calling -> . # ID ( callingA
    (44) pipeline -> . PIPE ID pipelineA
    (92) screen -> . WHERE
    (93) screen -> . CLEAR
    (76) figure -> . OVAL
    (77) figure -> . TRIO
    (78) figure -> . QUAD
    (79) figure -> . ARC

    END             shift and go to state 15
    MOD             shift and go to state 32
    ID              shift and go to state 22
    IF              shift and go to state 23
    ECHO            shift and go to state 17
    "               shift and go to state 9
    REPLAY          shift and go to state 5
    SAMPLE          shift and go to state 18
    #               shift and go to state 8
    PIPE            shift and go to state 7
    WHERE           shift and go to state 27
    CLEAR           shift and go to state 12
    OVAL            shift and go to state 6
    TRIO            shift and go to state 13
    QUAD            shift and go to state 21
    ARC             shift and go to state 28

    figure                         shift and go to state 3
    module                         shift and go to state 4
    write                          shift and go to state 10
    condition                      shift and go to state 11
    repeat                         shift and go to state 14
    screen                         shift and go to state 16
    programB                       shift and go to state 20
    statute                        shift and go to state 24
    pipeline                       shift and go to state 25
    calling                        shift and go to state 26
    command                        shift and go to state 29
    workspace                      shift and go to state 30
    assign                         shift and go to state 31
    programA                       shift and go to state 19

state 2

    (0) S' -> program .



state 3

    (52) command -> figure . exp exp color ;
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 38
    factor                         shift and go to state 39

state 4

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    "               reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    PIPE            reduce using rule 8 (workspace -> module .)
    WHERE           reduce using rule 8 (workspace -> module .)
    CLEAR           reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 5

    (56) repeat -> REPLAY . CTE_INTEGER [ repeatA ] ;

    CTE_INTEGER     shift and go to state 42


state 6

    (76) figure -> OVAL .

    (               reduce using rule 76 (figure -> OVAL .)
    ID              reduce using rule 76 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 76 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 76 (figure -> OVAL .)
    TRUE            reduce using rule 76 (figure -> OVAL .)
    FALSE           reduce using rule 76 (figure -> OVAL .)


state 7

    (44) pipeline -> PIPE . ID pipelineA

    ID              shift and go to state 43


state 8

    (26) calling -> # . ID ( callingA

    ID              shift and go to state 44


state 9

    (43) write -> " . CTE_STRING " ;

    CTE_STRING      shift and go to state 45


state 10

    (11) statute -> write .

    ID              reduce using rule 11 (statute -> write .)
    IF              reduce using rule 11 (statute -> write .)
    ECHO            reduce using rule 11 (statute -> write .)
    "               reduce using rule 11 (statute -> write .)
    REPLAY          reduce using rule 11 (statute -> write .)
    SAMPLE          reduce using rule 11 (statute -> write .)
    #               reduce using rule 11 (statute -> write .)
    PIPE            reduce using rule 11 (statute -> write .)
    WHERE           reduce using rule 11 (statute -> write .)
    CLEAR           reduce using rule 11 (statute -> write .)
    OVAL            reduce using rule 11 (statute -> write .)
    TRIO            reduce using rule 11 (statute -> write .)
    QUAD            reduce using rule 11 (statute -> write .)
    ARC             reduce using rule 11 (statute -> write .)
    }               reduce using rule 11 (statute -> write .)
    MOD             reduce using rule 11 (statute -> write .)
    END             reduce using rule 11 (statute -> write .)


state 11

    (10) statute -> condition .

    ID              reduce using rule 10 (statute -> condition .)
    IF              reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    "               reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    PIPE            reduce using rule 10 (statute -> condition .)
    WHERE           reduce using rule 10 (statute -> condition .)
    CLEAR           reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)
    MOD             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)


state 12

    (93) screen -> CLEAR .

    ID              reduce using rule 93 (screen -> CLEAR .)
    IF              reduce using rule 93 (screen -> CLEAR .)
    ECHO            reduce using rule 93 (screen -> CLEAR .)
    "               reduce using rule 93 (screen -> CLEAR .)
    REPLAY          reduce using rule 93 (screen -> CLEAR .)
    SAMPLE          reduce using rule 93 (screen -> CLEAR .)
    #               reduce using rule 93 (screen -> CLEAR .)
    PIPE            reduce using rule 93 (screen -> CLEAR .)
    WHERE           reduce using rule 93 (screen -> CLEAR .)
    CLEAR           reduce using rule 93 (screen -> CLEAR .)
    OVAL            reduce using rule 93 (screen -> CLEAR .)
    TRIO            reduce using rule 93 (screen -> CLEAR .)
    QUAD            reduce using rule 93 (screen -> CLEAR .)
    ARC             reduce using rule 93 (screen -> CLEAR .)
    }               reduce using rule 93 (screen -> CLEAR .)
    MOD             reduce using rule 93 (screen -> CLEAR .)
    END             reduce using rule 93 (screen -> CLEAR .)


state 13

    (77) figure -> TRIO .

    (               reduce using rule 77 (figure -> TRIO .)
    ID              reduce using rule 77 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 77 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 77 (figure -> TRIO .)
    TRUE            reduce using rule 77 (figure -> TRIO .)
    FALSE           reduce using rule 77 (figure -> TRIO .)


state 14

    (12) statute -> repeat .

    ID              reduce using rule 12 (statute -> repeat .)
    IF              reduce using rule 12 (statute -> repeat .)
    ECHO            reduce using rule 12 (statute -> repeat .)
    "               reduce using rule 12 (statute -> repeat .)
    REPLAY          reduce using rule 12 (statute -> repeat .)
    SAMPLE          reduce using rule 12 (statute -> repeat .)
    #               reduce using rule 12 (statute -> repeat .)
    PIPE            reduce using rule 12 (statute -> repeat .)
    WHERE           reduce using rule 12 (statute -> repeat .)
    CLEAR           reduce using rule 12 (statute -> repeat .)
    OVAL            reduce using rule 12 (statute -> repeat .)
    TRIO            reduce using rule 12 (statute -> repeat .)
    QUAD            reduce using rule 12 (statute -> repeat .)
    ARC             reduce using rule 12 (statute -> repeat .)
    }               reduce using rule 12 (statute -> repeat .)
    MOD             reduce using rule 12 (statute -> repeat .)
    END             reduce using rule 12 (statute -> repeat .)


state 15

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 16

    (16) statute -> screen .

    ID              reduce using rule 16 (statute -> screen .)
    IF              reduce using rule 16 (statute -> screen .)
    ECHO            reduce using rule 16 (statute -> screen .)
    "               reduce using rule 16 (statute -> screen .)
    REPLAY          reduce using rule 16 (statute -> screen .)
    SAMPLE          reduce using rule 16 (statute -> screen .)
    #               reduce using rule 16 (statute -> screen .)
    PIPE            reduce using rule 16 (statute -> screen .)
    WHERE           reduce using rule 16 (statute -> screen .)
    CLEAR           reduce using rule 16 (statute -> screen .)
    OVAL            reduce using rule 16 (statute -> screen .)
    TRIO            reduce using rule 16 (statute -> screen .)
    QUAD            reduce using rule 16 (statute -> screen .)
    ARC             reduce using rule 16 (statute -> screen .)
    }               reduce using rule 16 (statute -> screen .)
    MOD             reduce using rule 16 (statute -> screen .)
    END             reduce using rule 16 (statute -> screen .)


state 17

    (42) write -> ECHO . expression ;
    (60) expression -> . exp = = exp
    (61) expression -> . exp < > exp
    (62) expression -> . exp < = exp
    (63) expression -> . exp > = exp
    (64) expression -> . exp > exp
    (65) expression -> . exp < exp
    (66) expression -> . exp AND exp
    (67) expression -> . exp OR exp
    (68) expression -> . exp empty
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    expression                     shift and go to state 47
    exp                            shift and go to state 46
    factor                         shift and go to state 39

state 18

    (53) command -> SAMPLE . commandA
    (54) commandA -> . ON move exp CTE_INTEGER color ;
    (55) commandA -> . OFF move exp ;

    ON              shift and go to state 50
    OFF             shift and go to state 49

    commandA                       shift and go to state 48

state 19

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 20

    (2) programA -> programB . END

    END             shift and go to state 51


state 21

    (78) figure -> QUAD .

    (               reduce using rule 78 (figure -> QUAD .)
    ID              reduce using rule 78 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 78 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 78 (figure -> QUAD .)
    TRUE            reduce using rule 78 (figure -> QUAD .)
    FALSE           reduce using rule 78 (figure -> QUAD .)


state 22

    (38) assign -> ID . = expression ;

    =               shift and go to state 52


state 23

    (39) condition -> IF . ( expression ) block conditionA

    (               shift and go to state 53


state 24

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    "               reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    PIPE            reduce using rule 7 (workspace -> statute .)
    WHERE           reduce using rule 7 (workspace -> statute .)
    CLEAR           reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 25

    (15) statute -> pipeline .

    ID              reduce using rule 15 (statute -> pipeline .)
    IF              reduce using rule 15 (statute -> pipeline .)
    ECHO            reduce using rule 15 (statute -> pipeline .)
    "               reduce using rule 15 (statute -> pipeline .)
    REPLAY          reduce using rule 15 (statute -> pipeline .)
    SAMPLE          reduce using rule 15 (statute -> pipeline .)
    #               reduce using rule 15 (statute -> pipeline .)
    PIPE            reduce using rule 15 (statute -> pipeline .)
    WHERE           reduce using rule 15 (statute -> pipeline .)
    CLEAR           reduce using rule 15 (statute -> pipeline .)
    OVAL            reduce using rule 15 (statute -> pipeline .)
    TRIO            reduce using rule 15 (statute -> pipeline .)
    QUAD            reduce using rule 15 (statute -> pipeline .)
    ARC             reduce using rule 15 (statute -> pipeline .)
    }               reduce using rule 15 (statute -> pipeline .)
    MOD             reduce using rule 15 (statute -> pipeline .)
    END             reduce using rule 15 (statute -> pipeline .)


state 26

    (14) statute -> calling .

    ID              reduce using rule 14 (statute -> calling .)
    IF              reduce using rule 14 (statute -> calling .)
    ECHO            reduce using rule 14 (statute -> calling .)
    "               reduce using rule 14 (statute -> calling .)
    REPLAY          reduce using rule 14 (statute -> calling .)
    SAMPLE          reduce using rule 14 (statute -> calling .)
    #               reduce using rule 14 (statute -> calling .)
    PIPE            reduce using rule 14 (statute -> calling .)
    WHERE           reduce using rule 14 (statute -> calling .)
    CLEAR           reduce using rule 14 (statute -> calling .)
    OVAL            reduce using rule 14 (statute -> calling .)
    TRIO            reduce using rule 14 (statute -> calling .)
    QUAD            reduce using rule 14 (statute -> calling .)
    ARC             reduce using rule 14 (statute -> calling .)
    }               reduce using rule 14 (statute -> calling .)
    MOD             reduce using rule 14 (statute -> calling .)
    END             reduce using rule 14 (statute -> calling .)


state 27

    (92) screen -> WHERE .

    ID              reduce using rule 92 (screen -> WHERE .)
    IF              reduce using rule 92 (screen -> WHERE .)
    ECHO            reduce using rule 92 (screen -> WHERE .)
    "               reduce using rule 92 (screen -> WHERE .)
    REPLAY          reduce using rule 92 (screen -> WHERE .)
    SAMPLE          reduce using rule 92 (screen -> WHERE .)
    #               reduce using rule 92 (screen -> WHERE .)
    PIPE            reduce using rule 92 (screen -> WHERE .)
    WHERE           reduce using rule 92 (screen -> WHERE .)
    CLEAR           reduce using rule 92 (screen -> WHERE .)
    OVAL            reduce using rule 92 (screen -> WHERE .)
    TRIO            reduce using rule 92 (screen -> WHERE .)
    QUAD            reduce using rule 92 (screen -> WHERE .)
    ARC             reduce using rule 92 (screen -> WHERE .)
    }               reduce using rule 92 (screen -> WHERE .)
    MOD             reduce using rule 92 (screen -> WHERE .)
    END             reduce using rule 92 (screen -> WHERE .)


state 28

    (79) figure -> ARC .

    (               reduce using rule 79 (figure -> ARC .)
    ID              reduce using rule 79 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 79 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 79 (figure -> ARC .)
    TRUE            reduce using rule 79 (figure -> ARC .)
    FALSE           reduce using rule 79 (figure -> ARC .)


state 29

    (13) statute -> command .

    ID              reduce using rule 13 (statute -> command .)
    IF              reduce using rule 13 (statute -> command .)
    ECHO            reduce using rule 13 (statute -> command .)
    "               reduce using rule 13 (statute -> command .)
    REPLAY          reduce using rule 13 (statute -> command .)
    SAMPLE          reduce using rule 13 (statute -> command .)
    #               reduce using rule 13 (statute -> command .)
    PIPE            reduce using rule 13 (statute -> command .)
    WHERE           reduce using rule 13 (statute -> command .)
    CLEAR           reduce using rule 13 (statute -> command .)
    OVAL            reduce using rule 13 (statute -> command .)
    TRIO            reduce using rule 13 (statute -> command .)
    QUAD            reduce using rule 13 (statute -> command .)
    ARC             reduce using rule 13 (statute -> command .)
    }               reduce using rule 13 (statute -> command .)
    MOD             reduce using rule 13 (statute -> command .)
    END             reduce using rule 13 (statute -> command .)


state 30

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (99) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . repeat
    (13) statute -> . command
    (14) statute -> . calling
    (15) statute -> . pipeline
    (16) statute -> . screen
    (17) module -> . MOD # ID moduleA
    (38) assign -> . ID = expression ;
    (39) condition -> . IF ( expression ) block conditionA
    (42) write -> . ECHO expression ;
    (43) write -> . " CTE_STRING " ;
    (56) repeat -> . REPLAY CTE_INTEGER [ repeatA ] ;
    (52) command -> . figure exp exp color ;
    (53) command -> . SAMPLE commandA
    (26) calling -> . # ID ( callingA
    (44) pipeline -> . PIPE ID pipelineA
    (92) screen -> . WHERE
    (93) screen -> . CLEAR
    (76) figure -> . OVAL
    (77) figure -> . TRIO
    (78) figure -> . QUAD
    (79) figure -> . ARC

    END             reduce using rule 99 (empty -> .)
    MOD             shift and go to state 32
    ID              shift and go to state 22
    IF              shift and go to state 23
    ECHO            shift and go to state 17
    "               shift and go to state 9
    REPLAY          shift and go to state 5
    SAMPLE          shift and go to state 18
    #               shift and go to state 8
    PIPE            shift and go to state 7
    WHERE           shift and go to state 27
    CLEAR           shift and go to state 12
    OVAL            shift and go to state 6
    TRIO            shift and go to state 13
    QUAD            shift and go to state 21
    ARC             shift and go to state 28

    figure                         shift and go to state 3
    module                         shift and go to state 4
    write                          shift and go to state 10
    condition                      shift and go to state 11
    empty                          shift and go to state 54
    repeat                         shift and go to state 14
    screen                         shift and go to state 16
    programB                       shift and go to state 55
    programC                       shift and go to state 56
    statute                        shift and go to state 24
    pipeline                       shift and go to state 25
    calling                        shift and go to state 26
    command                        shift and go to state 29
    workspace                      shift and go to state 30
    assign                         shift and go to state 31

state 31

    (9) statute -> assign .

    ID              reduce using rule 9 (statute -> assign .)
    IF              reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    "               reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    PIPE            reduce using rule 9 (statute -> assign .)
    WHERE           reduce using rule 9 (statute -> assign .)
    CLEAR           reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)
    MOD             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)


state 32

    (17) module -> MOD . # ID moduleA

    #               shift and go to state 57


state 33

    (96) var_cte -> CTE_FLOAT .

    =               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 96 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 96 (var_cte -> CTE_FLOAT .)
    +               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 96 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 96 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 96 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 96 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 96 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 96 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 96 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 96 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 96 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 96 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 96 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 96 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 96 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 96 (var_cte -> CTE_FLOAT .)


state 34

    (74) factor -> ( . expression )
    (60) expression -> . exp = = exp
    (61) expression -> . exp < > exp
    (62) expression -> . exp < = exp
    (63) expression -> . exp > = exp
    (64) expression -> . exp > exp
    (65) expression -> . exp < exp
    (66) expression -> . exp AND exp
    (67) expression -> . exp OR exp
    (68) expression -> . exp empty
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    expression                     shift and go to state 58
    exp                            shift and go to state 46
    factor                         shift and go to state 39

state 35

    (75) factor -> var_cte .

    =               reduce using rule 75 (factor -> var_cte .)
    <               reduce using rule 75 (factor -> var_cte .)
    >               reduce using rule 75 (factor -> var_cte .)
    AND             reduce using rule 75 (factor -> var_cte .)
    OR              reduce using rule 75 (factor -> var_cte .)
    +               reduce using rule 75 (factor -> var_cte .)
    -               reduce using rule 75 (factor -> var_cte .)
    *               reduce using rule 75 (factor -> var_cte .)
    /               reduce using rule 75 (factor -> var_cte .)
    ,               reduce using rule 75 (factor -> var_cte .)
    )               reduce using rule 75 (factor -> var_cte .)
    ;               reduce using rule 75 (factor -> var_cte .)
    (               reduce using rule 75 (factor -> var_cte .)
    ID              reduce using rule 75 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 75 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 75 (factor -> var_cte .)
    TRUE            reduce using rule 75 (factor -> var_cte .)
    FALSE           reduce using rule 75 (factor -> var_cte .)
    RED             reduce using rule 75 (factor -> var_cte .)
    YELLOW          reduce using rule 75 (factor -> var_cte .)
    BLUE            reduce using rule 75 (factor -> var_cte .)
    GREEN           reduce using rule 75 (factor -> var_cte .)
    BLACK           reduce using rule 75 (factor -> var_cte .)
    ORANGE          reduce using rule 75 (factor -> var_cte .)
    PURPLE          reduce using rule 75 (factor -> var_cte .)
    CYAN            reduce using rule 75 (factor -> var_cte .)
    ]               reduce using rule 75 (factor -> var_cte .)


state 36

    (95) var_cte -> CTE_INTEGER .

    =               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 95 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 95 (var_cte -> CTE_INTEGER .)
    +               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 95 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 95 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 95 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 95 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 95 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 95 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 95 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 95 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 95 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 95 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 95 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 95 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 95 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 95 (var_cte -> CTE_INTEGER .)


state 37

    (97) var_cte -> TRUE .

    =               reduce using rule 97 (var_cte -> TRUE .)
    <               reduce using rule 97 (var_cte -> TRUE .)
    >               reduce using rule 97 (var_cte -> TRUE .)
    AND             reduce using rule 97 (var_cte -> TRUE .)
    OR              reduce using rule 97 (var_cte -> TRUE .)
    +               reduce using rule 97 (var_cte -> TRUE .)
    -               reduce using rule 97 (var_cte -> TRUE .)
    *               reduce using rule 97 (var_cte -> TRUE .)
    /               reduce using rule 97 (var_cte -> TRUE .)
    )               reduce using rule 97 (var_cte -> TRUE .)
    ;               reduce using rule 97 (var_cte -> TRUE .)
    ,               reduce using rule 97 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 97 (var_cte -> TRUE .)
    ]               reduce using rule 97 (var_cte -> TRUE .)
    (               reduce using rule 97 (var_cte -> TRUE .)
    ID              reduce using rule 97 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 97 (var_cte -> TRUE .)
    TRUE            reduce using rule 97 (var_cte -> TRUE .)
    FALSE           reduce using rule 97 (var_cte -> TRUE .)
    RED             reduce using rule 97 (var_cte -> TRUE .)
    YELLOW          reduce using rule 97 (var_cte -> TRUE .)
    BLUE            reduce using rule 97 (var_cte -> TRUE .)
    GREEN           reduce using rule 97 (var_cte -> TRUE .)
    BLACK           reduce using rule 97 (var_cte -> TRUE .)
    ORANGE          reduce using rule 97 (var_cte -> TRUE .)
    PURPLE          reduce using rule 97 (var_cte -> TRUE .)
    CYAN            reduce using rule 97 (var_cte -> TRUE .)


state 38

    (52) command -> figure exp . exp color ;
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62
    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 63
    factor                         shift and go to state 39

state 39

    (73) exp -> factor . empty
    (99) empty -> .

    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    CTE_INTEGER     reduce using rule 99 (empty -> .)
    CTE_FLOAT       reduce using rule 99 (empty -> .)
    TRUE            reduce using rule 99 (empty -> .)
    FALSE           reduce using rule 99 (empty -> .)
    =               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    RED             reduce using rule 99 (empty -> .)
    YELLOW          reduce using rule 99 (empty -> .)
    BLUE            reduce using rule 99 (empty -> .)
    GREEN           reduce using rule 99 (empty -> .)
    BLACK           reduce using rule 99 (empty -> .)
    ORANGE          reduce using rule 99 (empty -> .)
    PURPLE          reduce using rule 99 (empty -> .)
    CYAN            reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)
    ]               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 64

state 40

    (98) var_cte -> FALSE .

    =               reduce using rule 98 (var_cte -> FALSE .)
    <               reduce using rule 98 (var_cte -> FALSE .)
    >               reduce using rule 98 (var_cte -> FALSE .)
    AND             reduce using rule 98 (var_cte -> FALSE .)
    OR              reduce using rule 98 (var_cte -> FALSE .)
    +               reduce using rule 98 (var_cte -> FALSE .)
    -               reduce using rule 98 (var_cte -> FALSE .)
    *               reduce using rule 98 (var_cte -> FALSE .)
    /               reduce using rule 98 (var_cte -> FALSE .)
    )               reduce using rule 98 (var_cte -> FALSE .)
    ;               reduce using rule 98 (var_cte -> FALSE .)
    ,               reduce using rule 98 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 98 (var_cte -> FALSE .)
    ]               reduce using rule 98 (var_cte -> FALSE .)
    (               reduce using rule 98 (var_cte -> FALSE .)
    ID              reduce using rule 98 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 98 (var_cte -> FALSE .)
    TRUE            reduce using rule 98 (var_cte -> FALSE .)
    FALSE           reduce using rule 98 (var_cte -> FALSE .)
    RED             reduce using rule 98 (var_cte -> FALSE .)
    YELLOW          reduce using rule 98 (var_cte -> FALSE .)
    BLUE            reduce using rule 98 (var_cte -> FALSE .)
    GREEN           reduce using rule 98 (var_cte -> FALSE .)
    BLACK           reduce using rule 98 (var_cte -> FALSE .)
    ORANGE          reduce using rule 98 (var_cte -> FALSE .)
    PURPLE          reduce using rule 98 (var_cte -> FALSE .)
    CYAN            reduce using rule 98 (var_cte -> FALSE .)


state 41

    (94) var_cte -> ID .

    =               reduce using rule 94 (var_cte -> ID .)
    <               reduce using rule 94 (var_cte -> ID .)
    >               reduce using rule 94 (var_cte -> ID .)
    AND             reduce using rule 94 (var_cte -> ID .)
    OR              reduce using rule 94 (var_cte -> ID .)
    +               reduce using rule 94 (var_cte -> ID .)
    -               reduce using rule 94 (var_cte -> ID .)
    *               reduce using rule 94 (var_cte -> ID .)
    /               reduce using rule 94 (var_cte -> ID .)
    )               reduce using rule 94 (var_cte -> ID .)
    ;               reduce using rule 94 (var_cte -> ID .)
    ,               reduce using rule 94 (var_cte -> ID .)
    CTE_INTEGER     reduce using rule 94 (var_cte -> ID .)
    ]               reduce using rule 94 (var_cte -> ID .)
    (               reduce using rule 94 (var_cte -> ID .)
    ID              reduce using rule 94 (var_cte -> ID .)
    CTE_FLOAT       reduce using rule 94 (var_cte -> ID .)
    TRUE            reduce using rule 94 (var_cte -> ID .)
    FALSE           reduce using rule 94 (var_cte -> ID .)
    RED             reduce using rule 94 (var_cte -> ID .)
    YELLOW          reduce using rule 94 (var_cte -> ID .)
    BLUE            reduce using rule 94 (var_cte -> ID .)
    GREEN           reduce using rule 94 (var_cte -> ID .)
    BLACK           reduce using rule 94 (var_cte -> ID .)
    ORANGE          reduce using rule 94 (var_cte -> ID .)
    PURPLE          reduce using rule 94 (var_cte -> ID .)
    CYAN            reduce using rule 94 (var_cte -> ID .)


state 42

    (56) repeat -> REPLAY CTE_INTEGER . [ repeatA ] ;

    [               shift and go to state 65


state 43

    (44) pipeline -> PIPE ID . pipelineA
    (45) pipelineA -> . [ pipelineB ] ;
    (46) pipelineA -> . IN ( var_cte ) ;
    (47) pipelineA -> . OUT ( ) ;
    (48) pipelineA -> . COUNT ;

    [               shift and go to state 69
    IN              shift and go to state 67
    OUT             shift and go to state 70
    COUNT           shift and go to state 66

    pipelineA                      shift and go to state 68

state 44

    (26) calling -> # ID . ( callingA

    (               shift and go to state 71


state 45

    (43) write -> " CTE_STRING . " ;

    "               shift and go to state 72


state 46

    (60) expression -> exp . = = exp
    (61) expression -> exp . < > exp
    (62) expression -> exp . < = exp
    (63) expression -> exp . > = exp
    (64) expression -> exp . > exp
    (65) expression -> exp . < exp
    (66) expression -> exp . AND exp
    (67) expression -> exp . OR exp
    (68) expression -> exp . empty
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp
    (99) empty -> .

    =               shift and go to state 75
    <               shift and go to state 74
    >               shift and go to state 78
    AND             shift and go to state 73
    OR              shift and go to state 76
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 77

state 47

    (42) write -> ECHO expression . ;

    ;               shift and go to state 79


state 48

    (53) command -> SAMPLE commandA .

    ID              reduce using rule 53 (command -> SAMPLE commandA .)
    IF              reduce using rule 53 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 53 (command -> SAMPLE commandA .)
    "               reduce using rule 53 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 53 (command -> SAMPLE commandA .)
    SAMPLE          reduce using rule 53 (command -> SAMPLE commandA .)
    #               reduce using rule 53 (command -> SAMPLE commandA .)
    PIPE            reduce using rule 53 (command -> SAMPLE commandA .)
    WHERE           reduce using rule 53 (command -> SAMPLE commandA .)
    CLEAR           reduce using rule 53 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 53 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 53 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 53 (command -> SAMPLE commandA .)
    ARC             reduce using rule 53 (command -> SAMPLE commandA .)
    }               reduce using rule 53 (command -> SAMPLE commandA .)
    MOD             reduce using rule 53 (command -> SAMPLE commandA .)
    END             reduce using rule 53 (command -> SAMPLE commandA .)
    ]               reduce using rule 53 (command -> SAMPLE commandA .)


state 49

    (55) commandA -> OFF . move exp ;
    (80) move -> . UP
    (81) move -> . DOWN
    (82) move -> . LEFT
    (83) move -> . RIGHT

    UP              shift and go to state 82
    DOWN            shift and go to state 83
    LEFT            shift and go to state 84
    RIGHT           shift and go to state 80

    move                           shift and go to state 81

state 50

    (54) commandA -> ON . move exp CTE_INTEGER color ;
    (80) move -> . UP
    (81) move -> . DOWN
    (82) move -> . LEFT
    (83) move -> . RIGHT

    UP              shift and go to state 82
    DOWN            shift and go to state 83
    LEFT            shift and go to state 84
    RIGHT           shift and go to state 80

    move                           shift and go to state 85

state 51

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 52

    (38) assign -> ID = . expression ;
    (60) expression -> . exp = = exp
    (61) expression -> . exp < > exp
    (62) expression -> . exp < = exp
    (63) expression -> . exp > = exp
    (64) expression -> . exp > exp
    (65) expression -> . exp < exp
    (66) expression -> . exp AND exp
    (67) expression -> . exp OR exp
    (68) expression -> . exp empty
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    expression                     shift and go to state 86
    exp                            shift and go to state 46
    factor                         shift and go to state 39

state 53

    (39) condition -> IF ( . expression ) block conditionA
    (60) expression -> . exp = = exp
    (61) expression -> . exp < > exp
    (62) expression -> . exp < = exp
    (63) expression -> . exp > = exp
    (64) expression -> . exp > exp
    (65) expression -> . exp < exp
    (66) expression -> . exp AND exp
    (67) expression -> . exp OR exp
    (68) expression -> . exp empty
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 46
    factor                         shift and go to state 39
    expression                     shift and go to state 87

state 54

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 55

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 56

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 57

    (17) module -> MOD # . ID moduleA

    ID              shift and go to state 88


state 58

    (74) factor -> ( expression . )

    )               shift and go to state 89


state 59

    (69) exp -> exp + . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 90
    factor                         shift and go to state 39

state 60

    (71) exp -> exp * . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 91
    factor                         shift and go to state 39

state 61

    (70) exp -> exp - . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 92
    factor                         shift and go to state 39

state 62

    (72) exp -> exp / . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 93
    factor                         shift and go to state 39

state 63

    (52) command -> figure exp exp . color ;
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp
    (84) color -> . RED
    (85) color -> . YELLOW
    (86) color -> . BLUE
    (87) color -> . GREEN
    (88) color -> . BLACK
    (89) color -> . ORANGE
    (90) color -> . PURPLE
    (91) color -> . CYAN

    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62
    RED             shift and go to state 102
    YELLOW          shift and go to state 98
    BLUE            shift and go to state 94
    GREEN           shift and go to state 97
    BLACK           shift and go to state 101
    ORANGE          shift and go to state 100
    PURPLE          shift and go to state 96
    CYAN            shift and go to state 99

    color                          shift and go to state 95

state 64

    (73) exp -> factor empty .

    =               reduce using rule 73 (exp -> factor empty .)
    <               reduce using rule 73 (exp -> factor empty .)
    >               reduce using rule 73 (exp -> factor empty .)
    AND             reduce using rule 73 (exp -> factor empty .)
    OR              reduce using rule 73 (exp -> factor empty .)
    +               reduce using rule 73 (exp -> factor empty .)
    -               reduce using rule 73 (exp -> factor empty .)
    *               reduce using rule 73 (exp -> factor empty .)
    /               reduce using rule 73 (exp -> factor empty .)
    ;               reduce using rule 73 (exp -> factor empty .)
    (               reduce using rule 73 (exp -> factor empty .)
    ID              reduce using rule 73 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 73 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 73 (exp -> factor empty .)
    TRUE            reduce using rule 73 (exp -> factor empty .)
    FALSE           reduce using rule 73 (exp -> factor empty .)
    )               reduce using rule 73 (exp -> factor empty .)
    RED             reduce using rule 73 (exp -> factor empty .)
    YELLOW          reduce using rule 73 (exp -> factor empty .)
    BLUE            reduce using rule 73 (exp -> factor empty .)
    GREEN           reduce using rule 73 (exp -> factor empty .)
    BLACK           reduce using rule 73 (exp -> factor empty .)
    ORANGE          reduce using rule 73 (exp -> factor empty .)
    PURPLE          reduce using rule 73 (exp -> factor empty .)
    CYAN            reduce using rule 73 (exp -> factor empty .)
    ,               reduce using rule 73 (exp -> factor empty .)
    ]               reduce using rule 73 (exp -> factor empty .)


state 65

    (56) repeat -> REPLAY CTE_INTEGER [ . repeatA ] ;
    (57) repeatA -> . command repeatB
    (52) command -> . figure exp exp color ;
    (53) command -> . SAMPLE commandA
    (76) figure -> . OVAL
    (77) figure -> . TRIO
    (78) figure -> . QUAD
    (79) figure -> . ARC

    SAMPLE          shift and go to state 18
    OVAL            shift and go to state 6
    TRIO            shift and go to state 13
    QUAD            shift and go to state 21
    ARC             shift and go to state 28

    figure                         shift and go to state 3
    repeatA                        shift and go to state 103
    command                        shift and go to state 104

state 66

    (48) pipelineA -> COUNT . ;

    ;               shift and go to state 105


state 67

    (46) pipelineA -> IN . ( var_cte ) ;

    (               shift and go to state 106


state 68

    (44) pipeline -> PIPE ID pipelineA .

    MOD             reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    ID              reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    IF              reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    ECHO            reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    "               reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    REPLAY          reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    SAMPLE          reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    #               reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    PIPE            reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    WHERE           reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    CLEAR           reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    OVAL            reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    TRIO            reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    QUAD            reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    ARC             reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    END             reduce using rule 44 (pipeline -> PIPE ID pipelineA .)
    }               reduce using rule 44 (pipeline -> PIPE ID pipelineA .)


state 69

    (45) pipelineA -> [ . pipelineB ] ;
    (49) pipelineB -> . exp pipelineC
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    pipelineB                      shift and go to state 107
    exp                            shift and go to state 108
    factor                         shift and go to state 39

state 70

    (47) pipelineA -> OUT . ( ) ;

    (               shift and go to state 109


state 71

    (26) calling -> # ID ( . callingA
    (27) callingA -> . callingB ) ;
    (28) callingA -> . ) ;
    (29) callingB -> . expression callingC
    (60) expression -> . exp = = exp
    (61) expression -> . exp < > exp
    (62) expression -> . exp < = exp
    (63) expression -> . exp > = exp
    (64) expression -> . exp > exp
    (65) expression -> . exp < exp
    (66) expression -> . exp AND exp
    (67) expression -> . exp OR exp
    (68) expression -> . exp empty
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    )               shift and go to state 110
    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    callingA                       shift and go to state 111
    callingB                       shift and go to state 112
    exp                            shift and go to state 46
    factor                         shift and go to state 39
    expression                     shift and go to state 113

state 72

    (43) write -> " CTE_STRING " . ;

    ;               shift and go to state 114


state 73

    (66) expression -> exp AND . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 115
    factor                         shift and go to state 39

state 74

    (61) expression -> exp < . > exp
    (62) expression -> exp < . = exp
    (65) expression -> exp < . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    >               shift and go to state 118
    =               shift and go to state 117
    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 116
    factor                         shift and go to state 39

state 75

    (60) expression -> exp = . = exp

    =               shift and go to state 119


state 76

    (67) expression -> exp OR . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 120
    factor                         shift and go to state 39

state 77

    (68) expression -> exp empty .

    ,               reduce using rule 68 (expression -> exp empty .)
    )               reduce using rule 68 (expression -> exp empty .)
    ;               reduce using rule 68 (expression -> exp empty .)


state 78

    (63) expression -> exp > . = exp
    (64) expression -> exp > . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    =               shift and go to state 122
    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 121
    factor                         shift and go to state 39

state 79

    (42) write -> ECHO expression ; .

    ID              reduce using rule 42 (write -> ECHO expression ; .)
    IF              reduce using rule 42 (write -> ECHO expression ; .)
    ECHO            reduce using rule 42 (write -> ECHO expression ; .)
    "               reduce using rule 42 (write -> ECHO expression ; .)
    REPLAY          reduce using rule 42 (write -> ECHO expression ; .)
    SAMPLE          reduce using rule 42 (write -> ECHO expression ; .)
    #               reduce using rule 42 (write -> ECHO expression ; .)
    PIPE            reduce using rule 42 (write -> ECHO expression ; .)
    WHERE           reduce using rule 42 (write -> ECHO expression ; .)
    CLEAR           reduce using rule 42 (write -> ECHO expression ; .)
    OVAL            reduce using rule 42 (write -> ECHO expression ; .)
    TRIO            reduce using rule 42 (write -> ECHO expression ; .)
    QUAD            reduce using rule 42 (write -> ECHO expression ; .)
    ARC             reduce using rule 42 (write -> ECHO expression ; .)
    }               reduce using rule 42 (write -> ECHO expression ; .)
    MOD             reduce using rule 42 (write -> ECHO expression ; .)
    END             reduce using rule 42 (write -> ECHO expression ; .)


state 80

    (83) move -> RIGHT .

    (               reduce using rule 83 (move -> RIGHT .)
    ID              reduce using rule 83 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 83 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 83 (move -> RIGHT .)
    TRUE            reduce using rule 83 (move -> RIGHT .)
    FALSE           reduce using rule 83 (move -> RIGHT .)


state 81

    (55) commandA -> OFF move . exp ;
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 123
    factor                         shift and go to state 39

state 82

    (80) move -> UP .

    (               reduce using rule 80 (move -> UP .)
    ID              reduce using rule 80 (move -> UP .)
    CTE_INTEGER     reduce using rule 80 (move -> UP .)
    CTE_FLOAT       reduce using rule 80 (move -> UP .)
    TRUE            reduce using rule 80 (move -> UP .)
    FALSE           reduce using rule 80 (move -> UP .)


state 83

    (81) move -> DOWN .

    (               reduce using rule 81 (move -> DOWN .)
    ID              reduce using rule 81 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 81 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 81 (move -> DOWN .)
    TRUE            reduce using rule 81 (move -> DOWN .)
    FALSE           reduce using rule 81 (move -> DOWN .)


state 84

    (82) move -> LEFT .

    (               reduce using rule 82 (move -> LEFT .)
    ID              reduce using rule 82 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 82 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 82 (move -> LEFT .)
    TRUE            reduce using rule 82 (move -> LEFT .)
    FALSE           reduce using rule 82 (move -> LEFT .)


state 85

    (54) commandA -> ON move . exp CTE_INTEGER color ;
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 124
    factor                         shift and go to state 39

state 86

    (38) assign -> ID = expression . ;

    ;               shift and go to state 125


state 87

    (39) condition -> IF ( expression . ) block conditionA

    )               shift and go to state 126


state 88

    (17) module -> MOD # ID . moduleA
    (18) moduleA -> . ( vars ) block
    (19) moduleA -> . block
    (32) block -> . { blockA

    (               shift and go to state 127
    {               shift and go to state 129

    block                          shift and go to state 128
    moduleA                        shift and go to state 130

state 89

    (74) factor -> ( expression ) .

    =               reduce using rule 74 (factor -> ( expression ) .)
    <               reduce using rule 74 (factor -> ( expression ) .)
    >               reduce using rule 74 (factor -> ( expression ) .)
    AND             reduce using rule 74 (factor -> ( expression ) .)
    OR              reduce using rule 74 (factor -> ( expression ) .)
    +               reduce using rule 74 (factor -> ( expression ) .)
    -               reduce using rule 74 (factor -> ( expression ) .)
    *               reduce using rule 74 (factor -> ( expression ) .)
    /               reduce using rule 74 (factor -> ( expression ) .)
    ,               reduce using rule 74 (factor -> ( expression ) .)
    )               reduce using rule 74 (factor -> ( expression ) .)
    ;               reduce using rule 74 (factor -> ( expression ) .)
    (               reduce using rule 74 (factor -> ( expression ) .)
    ID              reduce using rule 74 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 74 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 74 (factor -> ( expression ) .)
    TRUE            reduce using rule 74 (factor -> ( expression ) .)
    FALSE           reduce using rule 74 (factor -> ( expression ) .)
    RED             reduce using rule 74 (factor -> ( expression ) .)
    YELLOW          reduce using rule 74 (factor -> ( expression ) .)
    BLUE            reduce using rule 74 (factor -> ( expression ) .)
    GREEN           reduce using rule 74 (factor -> ( expression ) .)
    BLACK           reduce using rule 74 (factor -> ( expression ) .)
    ORANGE          reduce using rule 74 (factor -> ( expression ) .)
    PURPLE          reduce using rule 74 (factor -> ( expression ) .)
    CYAN            reduce using rule 74 (factor -> ( expression ) .)
    ]               reduce using rule 74 (factor -> ( expression ) .)


state 90

    (69) exp -> exp + exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    =               reduce using rule 69 (exp -> exp + exp .)
    <               reduce using rule 69 (exp -> exp + exp .)
    >               reduce using rule 69 (exp -> exp + exp .)
    AND             reduce using rule 69 (exp -> exp + exp .)
    OR              reduce using rule 69 (exp -> exp + exp .)
    +               reduce using rule 69 (exp -> exp + exp .)
    -               reduce using rule 69 (exp -> exp + exp .)
    ;               reduce using rule 69 (exp -> exp + exp .)
    (               reduce using rule 69 (exp -> exp + exp .)
    ID              reduce using rule 69 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 69 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 69 (exp -> exp + exp .)
    TRUE            reduce using rule 69 (exp -> exp + exp .)
    FALSE           reduce using rule 69 (exp -> exp + exp .)
    )               reduce using rule 69 (exp -> exp + exp .)
    RED             reduce using rule 69 (exp -> exp + exp .)
    YELLOW          reduce using rule 69 (exp -> exp + exp .)
    BLUE            reduce using rule 69 (exp -> exp + exp .)
    GREEN           reduce using rule 69 (exp -> exp + exp .)
    BLACK           reduce using rule 69 (exp -> exp + exp .)
    ORANGE          reduce using rule 69 (exp -> exp + exp .)
    PURPLE          reduce using rule 69 (exp -> exp + exp .)
    CYAN            reduce using rule 69 (exp -> exp + exp .)
    ,               reduce using rule 69 (exp -> exp + exp .)
    ]               reduce using rule 69 (exp -> exp + exp .)
    *               shift and go to state 60
    /               shift and go to state 62

  ! *               [ reduce using rule 69 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 69 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 59 ]
  ! -               [ shift and go to state 61 ]


state 91

    (71) exp -> exp * exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    =               reduce using rule 71 (exp -> exp * exp .)
    <               reduce using rule 71 (exp -> exp * exp .)
    >               reduce using rule 71 (exp -> exp * exp .)
    AND             reduce using rule 71 (exp -> exp * exp .)
    OR              reduce using rule 71 (exp -> exp * exp .)
    +               reduce using rule 71 (exp -> exp * exp .)
    -               reduce using rule 71 (exp -> exp * exp .)
    *               reduce using rule 71 (exp -> exp * exp .)
    /               reduce using rule 71 (exp -> exp * exp .)
    ;               reduce using rule 71 (exp -> exp * exp .)
    (               reduce using rule 71 (exp -> exp * exp .)
    ID              reduce using rule 71 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 71 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 71 (exp -> exp * exp .)
    TRUE            reduce using rule 71 (exp -> exp * exp .)
    FALSE           reduce using rule 71 (exp -> exp * exp .)
    )               reduce using rule 71 (exp -> exp * exp .)
    RED             reduce using rule 71 (exp -> exp * exp .)
    YELLOW          reduce using rule 71 (exp -> exp * exp .)
    BLUE            reduce using rule 71 (exp -> exp * exp .)
    GREEN           reduce using rule 71 (exp -> exp * exp .)
    BLACK           reduce using rule 71 (exp -> exp * exp .)
    ORANGE          reduce using rule 71 (exp -> exp * exp .)
    PURPLE          reduce using rule 71 (exp -> exp * exp .)
    CYAN            reduce using rule 71 (exp -> exp * exp .)
    ,               reduce using rule 71 (exp -> exp * exp .)
    ]               reduce using rule 71 (exp -> exp * exp .)

  ! +               [ shift and go to state 59 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 60 ]
  ! /               [ shift and go to state 62 ]


state 92

    (70) exp -> exp - exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    =               reduce using rule 70 (exp -> exp - exp .)
    <               reduce using rule 70 (exp -> exp - exp .)
    >               reduce using rule 70 (exp -> exp - exp .)
    AND             reduce using rule 70 (exp -> exp - exp .)
    OR              reduce using rule 70 (exp -> exp - exp .)
    +               reduce using rule 70 (exp -> exp - exp .)
    -               reduce using rule 70 (exp -> exp - exp .)
    ;               reduce using rule 70 (exp -> exp - exp .)
    (               reduce using rule 70 (exp -> exp - exp .)
    ID              reduce using rule 70 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 70 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 70 (exp -> exp - exp .)
    TRUE            reduce using rule 70 (exp -> exp - exp .)
    FALSE           reduce using rule 70 (exp -> exp - exp .)
    )               reduce using rule 70 (exp -> exp - exp .)
    RED             reduce using rule 70 (exp -> exp - exp .)
    YELLOW          reduce using rule 70 (exp -> exp - exp .)
    BLUE            reduce using rule 70 (exp -> exp - exp .)
    GREEN           reduce using rule 70 (exp -> exp - exp .)
    BLACK           reduce using rule 70 (exp -> exp - exp .)
    ORANGE          reduce using rule 70 (exp -> exp - exp .)
    PURPLE          reduce using rule 70 (exp -> exp - exp .)
    CYAN            reduce using rule 70 (exp -> exp - exp .)
    ,               reduce using rule 70 (exp -> exp - exp .)
    ]               reduce using rule 70 (exp -> exp - exp .)
    *               shift and go to state 60
    /               shift and go to state 62

  ! *               [ reduce using rule 70 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 70 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 59 ]
  ! -               [ shift and go to state 61 ]


state 93

    (72) exp -> exp / exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    =               reduce using rule 72 (exp -> exp / exp .)
    <               reduce using rule 72 (exp -> exp / exp .)
    >               reduce using rule 72 (exp -> exp / exp .)
    AND             reduce using rule 72 (exp -> exp / exp .)
    OR              reduce using rule 72 (exp -> exp / exp .)
    +               reduce using rule 72 (exp -> exp / exp .)
    -               reduce using rule 72 (exp -> exp / exp .)
    *               reduce using rule 72 (exp -> exp / exp .)
    /               reduce using rule 72 (exp -> exp / exp .)
    ;               reduce using rule 72 (exp -> exp / exp .)
    (               reduce using rule 72 (exp -> exp / exp .)
    ID              reduce using rule 72 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 72 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 72 (exp -> exp / exp .)
    TRUE            reduce using rule 72 (exp -> exp / exp .)
    FALSE           reduce using rule 72 (exp -> exp / exp .)
    )               reduce using rule 72 (exp -> exp / exp .)
    RED             reduce using rule 72 (exp -> exp / exp .)
    YELLOW          reduce using rule 72 (exp -> exp / exp .)
    BLUE            reduce using rule 72 (exp -> exp / exp .)
    GREEN           reduce using rule 72 (exp -> exp / exp .)
    BLACK           reduce using rule 72 (exp -> exp / exp .)
    ORANGE          reduce using rule 72 (exp -> exp / exp .)
    PURPLE          reduce using rule 72 (exp -> exp / exp .)
    CYAN            reduce using rule 72 (exp -> exp / exp .)
    ,               reduce using rule 72 (exp -> exp / exp .)
    ]               reduce using rule 72 (exp -> exp / exp .)

  ! +               [ shift and go to state 59 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 60 ]
  ! /               [ shift and go to state 62 ]


state 94

    (86) color -> BLUE .

    ;               reduce using rule 86 (color -> BLUE .)


state 95

    (52) command -> figure exp exp color . ;

    ;               shift and go to state 131


state 96

    (90) color -> PURPLE .

    ;               reduce using rule 90 (color -> PURPLE .)


state 97

    (87) color -> GREEN .

    ;               reduce using rule 87 (color -> GREEN .)


state 98

    (85) color -> YELLOW .

    ;               reduce using rule 85 (color -> YELLOW .)


state 99

    (91) color -> CYAN .

    ;               reduce using rule 91 (color -> CYAN .)


state 100

    (89) color -> ORANGE .

    ;               reduce using rule 89 (color -> ORANGE .)


state 101

    (88) color -> BLACK .

    ;               reduce using rule 88 (color -> BLACK .)


state 102

    (84) color -> RED .

    ;               reduce using rule 84 (color -> RED .)


state 103

    (56) repeat -> REPLAY CTE_INTEGER [ repeatA . ] ;

    ]               shift and go to state 132


state 104

    (57) repeatA -> command . repeatB
    (58) repeatB -> . repeatA
    (59) repeatB -> . empty
    (57) repeatA -> . command repeatB
    (99) empty -> .
    (52) command -> . figure exp exp color ;
    (53) command -> . SAMPLE commandA
    (76) figure -> . OVAL
    (77) figure -> . TRIO
    (78) figure -> . QUAD
    (79) figure -> . ARC

    ]               reduce using rule 99 (empty -> .)
    SAMPLE          shift and go to state 18
    OVAL            shift and go to state 6
    TRIO            shift and go to state 13
    QUAD            shift and go to state 21
    ARC             shift and go to state 28

    figure                         shift and go to state 3
    repeatA                        shift and go to state 133
    repeatB                        shift and go to state 134
    command                        shift and go to state 104
    empty                          shift and go to state 135

state 105

    (48) pipelineA -> COUNT ; .

    MOD             reduce using rule 48 (pipelineA -> COUNT ; .)
    ID              reduce using rule 48 (pipelineA -> COUNT ; .)
    IF              reduce using rule 48 (pipelineA -> COUNT ; .)
    ECHO            reduce using rule 48 (pipelineA -> COUNT ; .)
    "               reduce using rule 48 (pipelineA -> COUNT ; .)
    REPLAY          reduce using rule 48 (pipelineA -> COUNT ; .)
    SAMPLE          reduce using rule 48 (pipelineA -> COUNT ; .)
    #               reduce using rule 48 (pipelineA -> COUNT ; .)
    PIPE            reduce using rule 48 (pipelineA -> COUNT ; .)
    WHERE           reduce using rule 48 (pipelineA -> COUNT ; .)
    CLEAR           reduce using rule 48 (pipelineA -> COUNT ; .)
    OVAL            reduce using rule 48 (pipelineA -> COUNT ; .)
    TRIO            reduce using rule 48 (pipelineA -> COUNT ; .)
    QUAD            reduce using rule 48 (pipelineA -> COUNT ; .)
    ARC             reduce using rule 48 (pipelineA -> COUNT ; .)
    END             reduce using rule 48 (pipelineA -> COUNT ; .)
    }               reduce using rule 48 (pipelineA -> COUNT ; .)


state 106

    (46) pipelineA -> IN ( . var_cte ) ;
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 136

state 107

    (45) pipelineA -> [ pipelineB . ] ;

    ]               shift and go to state 137


state 108

    (49) pipelineB -> exp . pipelineC
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp
    (50) pipelineC -> . , pipelineB
    (51) pipelineC -> . empty
    (99) empty -> .

    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62
    ,               shift and go to state 138
    ]               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 140
    pipelineC                      shift and go to state 139

state 109

    (47) pipelineA -> OUT ( . ) ;

    )               shift and go to state 141


state 110

    (28) callingA -> ) . ;

    ;               shift and go to state 142


state 111

    (26) calling -> # ID ( callingA .

    ID              reduce using rule 26 (calling -> # ID ( callingA .)
    IF              reduce using rule 26 (calling -> # ID ( callingA .)
    ECHO            reduce using rule 26 (calling -> # ID ( callingA .)
    "               reduce using rule 26 (calling -> # ID ( callingA .)
    REPLAY          reduce using rule 26 (calling -> # ID ( callingA .)
    SAMPLE          reduce using rule 26 (calling -> # ID ( callingA .)
    #               reduce using rule 26 (calling -> # ID ( callingA .)
    PIPE            reduce using rule 26 (calling -> # ID ( callingA .)
    WHERE           reduce using rule 26 (calling -> # ID ( callingA .)
    CLEAR           reduce using rule 26 (calling -> # ID ( callingA .)
    OVAL            reduce using rule 26 (calling -> # ID ( callingA .)
    TRIO            reduce using rule 26 (calling -> # ID ( callingA .)
    QUAD            reduce using rule 26 (calling -> # ID ( callingA .)
    ARC             reduce using rule 26 (calling -> # ID ( callingA .)
    }               reduce using rule 26 (calling -> # ID ( callingA .)
    MOD             reduce using rule 26 (calling -> # ID ( callingA .)
    END             reduce using rule 26 (calling -> # ID ( callingA .)


state 112

    (27) callingA -> callingB . ) ;

    )               shift and go to state 143


state 113

    (29) callingB -> expression . callingC
    (30) callingC -> . , callingB
    (31) callingC -> . empty
    (99) empty -> .

    ,               shift and go to state 145
    )               reduce using rule 99 (empty -> .)

    callingC                       shift and go to state 144
    empty                          shift and go to state 146

state 114

    (43) write -> " CTE_STRING " ; .

    ID              reduce using rule 43 (write -> " CTE_STRING " ; .)
    IF              reduce using rule 43 (write -> " CTE_STRING " ; .)
    ECHO            reduce using rule 43 (write -> " CTE_STRING " ; .)
    "               reduce using rule 43 (write -> " CTE_STRING " ; .)
    REPLAY          reduce using rule 43 (write -> " CTE_STRING " ; .)
    SAMPLE          reduce using rule 43 (write -> " CTE_STRING " ; .)
    #               reduce using rule 43 (write -> " CTE_STRING " ; .)
    PIPE            reduce using rule 43 (write -> " CTE_STRING " ; .)
    WHERE           reduce using rule 43 (write -> " CTE_STRING " ; .)
    CLEAR           reduce using rule 43 (write -> " CTE_STRING " ; .)
    OVAL            reduce using rule 43 (write -> " CTE_STRING " ; .)
    TRIO            reduce using rule 43 (write -> " CTE_STRING " ; .)
    QUAD            reduce using rule 43 (write -> " CTE_STRING " ; .)
    ARC             reduce using rule 43 (write -> " CTE_STRING " ; .)
    }               reduce using rule 43 (write -> " CTE_STRING " ; .)
    MOD             reduce using rule 43 (write -> " CTE_STRING " ; .)
    END             reduce using rule 43 (write -> " CTE_STRING " ; .)


state 115

    (66) expression -> exp AND exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 66 (expression -> exp AND exp .)
    )               reduce using rule 66 (expression -> exp AND exp .)
    ;               reduce using rule 66 (expression -> exp AND exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 116

    (65) expression -> exp < exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 65 (expression -> exp < exp .)
    )               reduce using rule 65 (expression -> exp < exp .)
    ;               reduce using rule 65 (expression -> exp < exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 117

    (62) expression -> exp < = . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 147
    factor                         shift and go to state 39

state 118

    (61) expression -> exp < > . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 148
    factor                         shift and go to state 39

state 119

    (60) expression -> exp = = . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 149
    factor                         shift and go to state 39

state 120

    (67) expression -> exp OR exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 67 (expression -> exp OR exp .)
    )               reduce using rule 67 (expression -> exp OR exp .)
    ;               reduce using rule 67 (expression -> exp OR exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 121

    (64) expression -> exp > exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 64 (expression -> exp > exp .)
    )               reduce using rule 64 (expression -> exp > exp .)
    ;               reduce using rule 64 (expression -> exp > exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 122

    (63) expression -> exp > = . exp
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    exp                            shift and go to state 150
    factor                         shift and go to state 39

state 123

    (55) commandA -> OFF move exp . ;
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ;               shift and go to state 151
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 124

    (54) commandA -> ON move exp . CTE_INTEGER color ;
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 152
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 125

    (38) assign -> ID = expression ; .

    ID              reduce using rule 38 (assign -> ID = expression ; .)
    IF              reduce using rule 38 (assign -> ID = expression ; .)
    ECHO            reduce using rule 38 (assign -> ID = expression ; .)
    "               reduce using rule 38 (assign -> ID = expression ; .)
    REPLAY          reduce using rule 38 (assign -> ID = expression ; .)
    SAMPLE          reduce using rule 38 (assign -> ID = expression ; .)
    #               reduce using rule 38 (assign -> ID = expression ; .)
    PIPE            reduce using rule 38 (assign -> ID = expression ; .)
    WHERE           reduce using rule 38 (assign -> ID = expression ; .)
    CLEAR           reduce using rule 38 (assign -> ID = expression ; .)
    OVAL            reduce using rule 38 (assign -> ID = expression ; .)
    TRIO            reduce using rule 38 (assign -> ID = expression ; .)
    QUAD            reduce using rule 38 (assign -> ID = expression ; .)
    ARC             reduce using rule 38 (assign -> ID = expression ; .)
    }               reduce using rule 38 (assign -> ID = expression ; .)
    MOD             reduce using rule 38 (assign -> ID = expression ; .)
    END             reduce using rule 38 (assign -> ID = expression ; .)


state 126

    (39) condition -> IF ( expression ) . block conditionA
    (32) block -> . { blockA

    {               shift and go to state 129

    block                          shift and go to state 153

state 127

    (18) moduleA -> ( . vars ) block
    (20) vars -> . type ID varsA
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOL

    INT             shift and go to state 156
    FLOAT           shift and go to state 155
    BOOL            shift and go to state 157

    type                           shift and go to state 158
    vars                           shift and go to state 154

state 128

    (19) moduleA -> block .

    MOD             reduce using rule 19 (moduleA -> block .)
    ID              reduce using rule 19 (moduleA -> block .)
    IF              reduce using rule 19 (moduleA -> block .)
    ECHO            reduce using rule 19 (moduleA -> block .)
    "               reduce using rule 19 (moduleA -> block .)
    REPLAY          reduce using rule 19 (moduleA -> block .)
    SAMPLE          reduce using rule 19 (moduleA -> block .)
    #               reduce using rule 19 (moduleA -> block .)
    PIPE            reduce using rule 19 (moduleA -> block .)
    WHERE           reduce using rule 19 (moduleA -> block .)
    CLEAR           reduce using rule 19 (moduleA -> block .)
    OVAL            reduce using rule 19 (moduleA -> block .)
    TRIO            reduce using rule 19 (moduleA -> block .)
    QUAD            reduce using rule 19 (moduleA -> block .)
    ARC             reduce using rule 19 (moduleA -> block .)
    END             reduce using rule 19 (moduleA -> block .)


state 129

    (32) block -> { . blockA
    (33) blockA -> . blockB }
    (34) blockA -> . }
    (35) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . repeat
    (13) statute -> . command
    (14) statute -> . calling
    (15) statute -> . pipeline
    (16) statute -> . screen
    (38) assign -> . ID = expression ;
    (39) condition -> . IF ( expression ) block conditionA
    (42) write -> . ECHO expression ;
    (43) write -> . " CTE_STRING " ;
    (56) repeat -> . REPLAY CTE_INTEGER [ repeatA ] ;
    (52) command -> . figure exp exp color ;
    (53) command -> . SAMPLE commandA
    (26) calling -> . # ID ( callingA
    (44) pipeline -> . PIPE ID pipelineA
    (92) screen -> . WHERE
    (93) screen -> . CLEAR
    (76) figure -> . OVAL
    (77) figure -> . TRIO
    (78) figure -> . QUAD
    (79) figure -> . ARC

    }               shift and go to state 160
    ID              shift and go to state 22
    IF              shift and go to state 23
    ECHO            shift and go to state 17
    "               shift and go to state 9
    REPLAY          shift and go to state 5
    SAMPLE          shift and go to state 18
    #               shift and go to state 8
    PIPE            shift and go to state 7
    WHERE           shift and go to state 27
    CLEAR           shift and go to state 12
    OVAL            shift and go to state 6
    TRIO            shift and go to state 13
    QUAD            shift and go to state 21
    ARC             shift and go to state 28

    figure                         shift and go to state 3
    blockA                         shift and go to state 162
    write                          shift and go to state 10
    command                        shift and go to state 29
    repeat                         shift and go to state 14
    screen                         shift and go to state 16
    condition                      shift and go to state 11
    statute                        shift and go to state 159
    pipeline                       shift and go to state 25
    calling                        shift and go to state 26
    blockB                         shift and go to state 161
    assign                         shift and go to state 31

state 130

    (17) module -> MOD # ID moduleA .

    MOD             reduce using rule 17 (module -> MOD # ID moduleA .)
    ID              reduce using rule 17 (module -> MOD # ID moduleA .)
    IF              reduce using rule 17 (module -> MOD # ID moduleA .)
    ECHO            reduce using rule 17 (module -> MOD # ID moduleA .)
    "               reduce using rule 17 (module -> MOD # ID moduleA .)
    REPLAY          reduce using rule 17 (module -> MOD # ID moduleA .)
    SAMPLE          reduce using rule 17 (module -> MOD # ID moduleA .)
    #               reduce using rule 17 (module -> MOD # ID moduleA .)
    PIPE            reduce using rule 17 (module -> MOD # ID moduleA .)
    WHERE           reduce using rule 17 (module -> MOD # ID moduleA .)
    CLEAR           reduce using rule 17 (module -> MOD # ID moduleA .)
    OVAL            reduce using rule 17 (module -> MOD # ID moduleA .)
    TRIO            reduce using rule 17 (module -> MOD # ID moduleA .)
    QUAD            reduce using rule 17 (module -> MOD # ID moduleA .)
    ARC             reduce using rule 17 (module -> MOD # ID moduleA .)
    END             reduce using rule 17 (module -> MOD # ID moduleA .)


state 131

    (52) command -> figure exp exp color ; .

    ID              reduce using rule 52 (command -> figure exp exp color ; .)
    IF              reduce using rule 52 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 52 (command -> figure exp exp color ; .)
    "               reduce using rule 52 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 52 (command -> figure exp exp color ; .)
    SAMPLE          reduce using rule 52 (command -> figure exp exp color ; .)
    #               reduce using rule 52 (command -> figure exp exp color ; .)
    PIPE            reduce using rule 52 (command -> figure exp exp color ; .)
    WHERE           reduce using rule 52 (command -> figure exp exp color ; .)
    CLEAR           reduce using rule 52 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 52 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 52 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 52 (command -> figure exp exp color ; .)
    ARC             reduce using rule 52 (command -> figure exp exp color ; .)
    }               reduce using rule 52 (command -> figure exp exp color ; .)
    MOD             reduce using rule 52 (command -> figure exp exp color ; .)
    END             reduce using rule 52 (command -> figure exp exp color ; .)
    ]               reduce using rule 52 (command -> figure exp exp color ; .)


state 132

    (56) repeat -> REPLAY CTE_INTEGER [ repeatA ] . ;

    ;               shift and go to state 163


state 133

    (58) repeatB -> repeatA .

    ]               reduce using rule 58 (repeatB -> repeatA .)


state 134

    (57) repeatA -> command repeatB .

    ]               reduce using rule 57 (repeatA -> command repeatB .)


state 135

    (59) repeatB -> empty .

    ]               reduce using rule 59 (repeatB -> empty .)


state 136

    (46) pipelineA -> IN ( var_cte . ) ;

    )               shift and go to state 164


state 137

    (45) pipelineA -> [ pipelineB ] . ;

    ;               shift and go to state 165


state 138

    (50) pipelineC -> , . pipelineB
    (49) pipelineB -> . exp pipelineC
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    pipelineB                      shift and go to state 166
    exp                            shift and go to state 108
    factor                         shift and go to state 39

state 139

    (49) pipelineB -> exp pipelineC .

    ]               reduce using rule 49 (pipelineB -> exp pipelineC .)


state 140

    (51) pipelineC -> empty .

    ]               reduce using rule 51 (pipelineC -> empty .)


state 141

    (47) pipelineA -> OUT ( ) . ;

    ;               shift and go to state 167


state 142

    (28) callingA -> ) ; .

    MOD             reduce using rule 28 (callingA -> ) ; .)
    ID              reduce using rule 28 (callingA -> ) ; .)
    IF              reduce using rule 28 (callingA -> ) ; .)
    ECHO            reduce using rule 28 (callingA -> ) ; .)
    "               reduce using rule 28 (callingA -> ) ; .)
    REPLAY          reduce using rule 28 (callingA -> ) ; .)
    SAMPLE          reduce using rule 28 (callingA -> ) ; .)
    #               reduce using rule 28 (callingA -> ) ; .)
    PIPE            reduce using rule 28 (callingA -> ) ; .)
    WHERE           reduce using rule 28 (callingA -> ) ; .)
    CLEAR           reduce using rule 28 (callingA -> ) ; .)
    OVAL            reduce using rule 28 (callingA -> ) ; .)
    TRIO            reduce using rule 28 (callingA -> ) ; .)
    QUAD            reduce using rule 28 (callingA -> ) ; .)
    ARC             reduce using rule 28 (callingA -> ) ; .)
    END             reduce using rule 28 (callingA -> ) ; .)
    }               reduce using rule 28 (callingA -> ) ; .)


state 143

    (27) callingA -> callingB ) . ;

    ;               shift and go to state 168


state 144

    (29) callingB -> expression callingC .

    )               reduce using rule 29 (callingB -> expression callingC .)


state 145

    (30) callingC -> , . callingB
    (29) callingB -> . expression callingC
    (60) expression -> . exp = = exp
    (61) expression -> . exp < > exp
    (62) expression -> . exp < = exp
    (63) expression -> . exp > = exp
    (64) expression -> . exp > exp
    (65) expression -> . exp < exp
    (66) expression -> . exp AND exp
    (67) expression -> . exp OR exp
    (68) expression -> . exp empty
    (69) exp -> . exp + exp
    (70) exp -> . exp - exp
    (71) exp -> . exp * exp
    (72) exp -> . exp / exp
    (73) exp -> . factor empty
    (74) factor -> . ( expression )
    (75) factor -> . var_cte
    (94) var_cte -> . ID
    (95) var_cte -> . CTE_INTEGER
    (96) var_cte -> . CTE_FLOAT
    (97) var_cte -> . TRUE
    (98) var_cte -> . FALSE

    (               shift and go to state 34
    ID              shift and go to state 41
    CTE_INTEGER     shift and go to state 36
    CTE_FLOAT       shift and go to state 33
    TRUE            shift and go to state 37
    FALSE           shift and go to state 40

    var_cte                        shift and go to state 35
    callingB                       shift and go to state 169
    exp                            shift and go to state 46
    factor                         shift and go to state 39
    expression                     shift and go to state 113

state 146

    (31) callingC -> empty .

    )               reduce using rule 31 (callingC -> empty .)


state 147

    (62) expression -> exp < = exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 62 (expression -> exp < = exp .)
    )               reduce using rule 62 (expression -> exp < = exp .)
    ;               reduce using rule 62 (expression -> exp < = exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 148

    (61) expression -> exp < > exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 61 (expression -> exp < > exp .)
    )               reduce using rule 61 (expression -> exp < > exp .)
    ;               reduce using rule 61 (expression -> exp < > exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 149

    (60) expression -> exp = = exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 60 (expression -> exp = = exp .)
    )               reduce using rule 60 (expression -> exp = = exp .)
    ;               reduce using rule 60 (expression -> exp = = exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 150

    (63) expression -> exp > = exp .
    (69) exp -> exp . + exp
    (70) exp -> exp . - exp
    (71) exp -> exp . * exp
    (72) exp -> exp . / exp

    ,               reduce using rule 63 (expression -> exp > = exp .)
    )               reduce using rule 63 (expression -> exp > = exp .)
    ;               reduce using rule 63 (expression -> exp > = exp .)
    +               shift and go to state 59
    -               shift and go to state 61
    *               shift and go to state 60
    /               shift and go to state 62


state 151

    (55) commandA -> OFF move exp ; .

    MOD             reduce using rule 55 (commandA -> OFF move exp ; .)
    ID              reduce using rule 55 (commandA -> OFF move exp ; .)
    IF              reduce using rule 55 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 55 (commandA -> OFF move exp ; .)
    "               reduce using rule 55 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 55 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 55 (commandA -> OFF move exp ; .)
    #               reduce using rule 55 (commandA -> OFF move exp ; .)
    PIPE            reduce using rule 55 (commandA -> OFF move exp ; .)
    WHERE           reduce using rule 55 (commandA -> OFF move exp ; .)
    CLEAR           reduce using rule 55 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 55 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 55 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 55 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 55 (commandA -> OFF move exp ; .)
    END             reduce using rule 55 (commandA -> OFF move exp ; .)
    ]               reduce using rule 55 (commandA -> OFF move exp ; .)
    }               reduce using rule 55 (commandA -> OFF move exp ; .)


state 152

    (54) commandA -> ON move exp CTE_INTEGER . color ;
    (84) color -> . RED
    (85) color -> . YELLOW
    (86) color -> . BLUE
    (87) color -> . GREEN
    (88) color -> . BLACK
    (89) color -> . ORANGE
    (90) color -> . PURPLE
    (91) color -> . CYAN

    RED             shift and go to state 102
    YELLOW          shift and go to state 98
    BLUE            shift and go to state 94
    GREEN           shift and go to state 97
    BLACK           shift and go to state 101
    ORANGE          shift and go to state 100
    PURPLE          shift and go to state 96
    CYAN            shift and go to state 99

    color                          shift and go to state 170

state 153

    (39) condition -> IF ( expression ) block . conditionA
    (40) conditionA -> . ELSE block
    (41) conditionA -> . empty
    (99) empty -> .

    ELSE            shift and go to state 172
    MOD             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    ECHO            reduce using rule 99 (empty -> .)
    "               reduce using rule 99 (empty -> .)
    REPLAY          reduce using rule 99 (empty -> .)
    SAMPLE          reduce using rule 99 (empty -> .)
    #               reduce using rule 99 (empty -> .)
    PIPE            reduce using rule 99 (empty -> .)
    WHERE           reduce using rule 99 (empty -> .)
    CLEAR           reduce using rule 99 (empty -> .)
    OVAL            reduce using rule 99 (empty -> .)
    TRIO            reduce using rule 99 (empty -> .)
    QUAD            reduce using rule 99 (empty -> .)
    ARC             reduce using rule 99 (empty -> .)
    END             reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 173
    conditionA                     shift and go to state 171

state 154

    (18) moduleA -> ( vars . ) block

    )               shift and go to state 174


state 155

    (24) type -> FLOAT .

    ID              reduce using rule 24 (type -> FLOAT .)


state 156

    (23) type -> INT .

    ID              reduce using rule 23 (type -> INT .)


state 157

    (25) type -> BOOL .

    ID              reduce using rule 25 (type -> BOOL .)


state 158

    (20) vars -> type . ID varsA

    ID              shift and go to state 175


state 159

    (35) blockB -> statute . blockC
    (36) blockC -> . blockB
    (37) blockC -> . empty
    (35) blockB -> . statute blockC
    (99) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . repeat
    (13) statute -> . command
    (14) statute -> . calling
    (15) statute -> . pipeline
    (16) statute -> . screen
    (38) assign -> . ID = expression ;
    (39) condition -> . IF ( expression ) block conditionA
    (42) write -> . ECHO expression ;
    (43) write -> . " CTE_STRING " ;
    (56) repeat -> . REPLAY CTE_INTEGER [ repeatA ] ;
    (52) command -> . figure exp exp color ;
    (53) command -> . SAMPLE commandA
    (26) calling -> . # ID ( callingA
    (44) pipeline -> . PIPE ID pipelineA
    (92) screen -> . WHERE
    (93) screen -> . CLEAR
    (76) figure -> . OVAL
    (77) figure -> . TRIO
    (78) figure -> . QUAD
    (79) figure -> . ARC

    }               reduce using rule 99 (empty -> .)
    ID              shift and go to state 22
    IF              shift and go to state 23
    ECHO            shift and go to state 17
    "               shift and go to state 9
    REPLAY          shift and go to state 5
    SAMPLE          shift and go to state 18
    #               shift and go to state 8
    PIPE            shift and go to state 7
    WHERE           shift and go to state 27
    CLEAR           shift and go to state 12
    OVAL            shift and go to state 6
    TRIO            shift and go to state 13
    QUAD            shift and go to state 21
    ARC             shift and go to state 28

    figure                         shift and go to state 3
    write                          shift and go to state 10
    command                        shift and go to state 29
    empty                          shift and go to state 176
    repeat                         shift and go to state 14
    screen                         shift and go to state 16
    condition                      shift and go to state 11
    statute                        shift and go to state 159
    pipeline                       shift and go to state 25
    calling                        shift and go to state 26
    blockC                         shift and go to state 177
    blockB                         shift and go to state 178
    assign                         shift and go to state 31

state 160

    (34) blockA -> } .

    MOD             reduce using rule 34 (blockA -> } .)
    ID              reduce using rule 34 (blockA -> } .)
    IF              reduce using rule 34 (blockA -> } .)
    ECHO            reduce using rule 34 (blockA -> } .)
    "               reduce using rule 34 (blockA -> } .)
    REPLAY          reduce using rule 34 (blockA -> } .)
    SAMPLE          reduce using rule 34 (blockA -> } .)
    #               reduce using rule 34 (blockA -> } .)
    PIPE            reduce using rule 34 (blockA -> } .)
    WHERE           reduce using rule 34 (blockA -> } .)
    CLEAR           reduce using rule 34 (blockA -> } .)
    OVAL            reduce using rule 34 (blockA -> } .)
    TRIO            reduce using rule 34 (blockA -> } .)
    QUAD            reduce using rule 34 (blockA -> } .)
    ARC             reduce using rule 34 (blockA -> } .)
    END             reduce using rule 34 (blockA -> } .)
    ELSE            reduce using rule 34 (blockA -> } .)
    }               reduce using rule 34 (blockA -> } .)


state 161

    (33) blockA -> blockB . }

    }               shift and go to state 179


state 162

    (32) block -> { blockA .

    ELSE            reduce using rule 32 (block -> { blockA .)
    MOD             reduce using rule 32 (block -> { blockA .)
    ID              reduce using rule 32 (block -> { blockA .)
    IF              reduce using rule 32 (block -> { blockA .)
    ECHO            reduce using rule 32 (block -> { blockA .)
    "               reduce using rule 32 (block -> { blockA .)
    REPLAY          reduce using rule 32 (block -> { blockA .)
    SAMPLE          reduce using rule 32 (block -> { blockA .)
    #               reduce using rule 32 (block -> { blockA .)
    PIPE            reduce using rule 32 (block -> { blockA .)
    WHERE           reduce using rule 32 (block -> { blockA .)
    CLEAR           reduce using rule 32 (block -> { blockA .)
    OVAL            reduce using rule 32 (block -> { blockA .)
    TRIO            reduce using rule 32 (block -> { blockA .)
    QUAD            reduce using rule 32 (block -> { blockA .)
    ARC             reduce using rule 32 (block -> { blockA .)
    END             reduce using rule 32 (block -> { blockA .)
    }               reduce using rule 32 (block -> { blockA .)


state 163

    (56) repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .

    MOD             reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    ID              reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    IF              reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    ECHO            reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    "               reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    REPLAY          reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    SAMPLE          reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    #               reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    PIPE            reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    WHERE           reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    CLEAR           reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    OVAL            reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    TRIO            reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    QUAD            reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    ARC             reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    END             reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)
    }               reduce using rule 56 (repeat -> REPLAY CTE_INTEGER [ repeatA ] ; .)


state 164

    (46) pipelineA -> IN ( var_cte ) . ;

    ;               shift and go to state 180


state 165

    (45) pipelineA -> [ pipelineB ] ; .

    MOD             reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    ID              reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    IF              reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    ECHO            reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    "               reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    REPLAY          reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    SAMPLE          reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    #               reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    PIPE            reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    WHERE           reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    CLEAR           reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    OVAL            reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    TRIO            reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    QUAD            reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    ARC             reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    END             reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)
    }               reduce using rule 45 (pipelineA -> [ pipelineB ] ; .)


state 166

    (50) pipelineC -> , pipelineB .

    ]               reduce using rule 50 (pipelineC -> , pipelineB .)


state 167

    (47) pipelineA -> OUT ( ) ; .

    MOD             reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    ID              reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    IF              reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    ECHO            reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    "               reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    REPLAY          reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    SAMPLE          reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    #               reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    PIPE            reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    WHERE           reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    CLEAR           reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    OVAL            reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    TRIO            reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    QUAD            reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    ARC             reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    END             reduce using rule 47 (pipelineA -> OUT ( ) ; .)
    }               reduce using rule 47 (pipelineA -> OUT ( ) ; .)


state 168

    (27) callingA -> callingB ) ; .

    MOD             reduce using rule 27 (callingA -> callingB ) ; .)
    ID              reduce using rule 27 (callingA -> callingB ) ; .)
    IF              reduce using rule 27 (callingA -> callingB ) ; .)
    ECHO            reduce using rule 27 (callingA -> callingB ) ; .)
    "               reduce using rule 27 (callingA -> callingB ) ; .)
    REPLAY          reduce using rule 27 (callingA -> callingB ) ; .)
    SAMPLE          reduce using rule 27 (callingA -> callingB ) ; .)
    #               reduce using rule 27 (callingA -> callingB ) ; .)
    PIPE            reduce using rule 27 (callingA -> callingB ) ; .)
    WHERE           reduce using rule 27 (callingA -> callingB ) ; .)
    CLEAR           reduce using rule 27 (callingA -> callingB ) ; .)
    OVAL            reduce using rule 27 (callingA -> callingB ) ; .)
    TRIO            reduce using rule 27 (callingA -> callingB ) ; .)
    QUAD            reduce using rule 27 (callingA -> callingB ) ; .)
    ARC             reduce using rule 27 (callingA -> callingB ) ; .)
    END             reduce using rule 27 (callingA -> callingB ) ; .)
    }               reduce using rule 27 (callingA -> callingB ) ; .)


state 169

    (30) callingC -> , callingB .

    )               reduce using rule 30 (callingC -> , callingB .)


state 170

    (54) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 181


state 171

    (39) condition -> IF ( expression ) block conditionA .

    MOD             reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    ID              reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    IF              reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    ECHO            reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    "               reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    REPLAY          reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    SAMPLE          reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    #               reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    PIPE            reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    WHERE           reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    CLEAR           reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    OVAL            reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    TRIO            reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    QUAD            reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    ARC             reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    END             reduce using rule 39 (condition -> IF ( expression ) block conditionA .)
    }               reduce using rule 39 (condition -> IF ( expression ) block conditionA .)


state 172

    (40) conditionA -> ELSE . block
    (32) block -> . { blockA

    {               shift and go to state 129

    block                          shift and go to state 182

state 173

    (41) conditionA -> empty .

    MOD             reduce using rule 41 (conditionA -> empty .)
    ID              reduce using rule 41 (conditionA -> empty .)
    IF              reduce using rule 41 (conditionA -> empty .)
    ECHO            reduce using rule 41 (conditionA -> empty .)
    "               reduce using rule 41 (conditionA -> empty .)
    REPLAY          reduce using rule 41 (conditionA -> empty .)
    SAMPLE          reduce using rule 41 (conditionA -> empty .)
    #               reduce using rule 41 (conditionA -> empty .)
    PIPE            reduce using rule 41 (conditionA -> empty .)
    WHERE           reduce using rule 41 (conditionA -> empty .)
    CLEAR           reduce using rule 41 (conditionA -> empty .)
    OVAL            reduce using rule 41 (conditionA -> empty .)
    TRIO            reduce using rule 41 (conditionA -> empty .)
    QUAD            reduce using rule 41 (conditionA -> empty .)
    ARC             reduce using rule 41 (conditionA -> empty .)
    END             reduce using rule 41 (conditionA -> empty .)
    }               reduce using rule 41 (conditionA -> empty .)


state 174

    (18) moduleA -> ( vars ) . block
    (32) block -> . { blockA

    {               shift and go to state 129

    block                          shift and go to state 183

state 175

    (20) vars -> type ID . varsA
    (21) varsA -> . , vars
    (22) varsA -> . empty
    (99) empty -> .

    ,               shift and go to state 185
    )               reduce using rule 99 (empty -> .)

    varsA                          shift and go to state 184
    empty                          shift and go to state 186

state 176

    (37) blockC -> empty .

    }               reduce using rule 37 (blockC -> empty .)


state 177

    (35) blockB -> statute blockC .

    }               reduce using rule 35 (blockB -> statute blockC .)


state 178

    (36) blockC -> blockB .

    }               reduce using rule 36 (blockC -> blockB .)


state 179

    (33) blockA -> blockB } .

    MOD             reduce using rule 33 (blockA -> blockB } .)
    ID              reduce using rule 33 (blockA -> blockB } .)
    IF              reduce using rule 33 (blockA -> blockB } .)
    ECHO            reduce using rule 33 (blockA -> blockB } .)
    "               reduce using rule 33 (blockA -> blockB } .)
    REPLAY          reduce using rule 33 (blockA -> blockB } .)
    SAMPLE          reduce using rule 33 (blockA -> blockB } .)
    #               reduce using rule 33 (blockA -> blockB } .)
    PIPE            reduce using rule 33 (blockA -> blockB } .)
    WHERE           reduce using rule 33 (blockA -> blockB } .)
    CLEAR           reduce using rule 33 (blockA -> blockB } .)
    OVAL            reduce using rule 33 (blockA -> blockB } .)
    TRIO            reduce using rule 33 (blockA -> blockB } .)
    QUAD            reduce using rule 33 (blockA -> blockB } .)
    ARC             reduce using rule 33 (blockA -> blockB } .)
    END             reduce using rule 33 (blockA -> blockB } .)
    ELSE            reduce using rule 33 (blockA -> blockB } .)
    }               reduce using rule 33 (blockA -> blockB } .)


state 180

    (46) pipelineA -> IN ( var_cte ) ; .

    MOD             reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    ID              reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    IF              reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    ECHO            reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    "               reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    REPLAY          reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    SAMPLE          reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    #               reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    PIPE            reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    WHERE           reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    CLEAR           reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    OVAL            reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    TRIO            reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    QUAD            reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    ARC             reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    END             reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)
    }               reduce using rule 46 (pipelineA -> IN ( var_cte ) ; .)


state 181

    (54) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    "               reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    PIPE            reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHERE           reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    CLEAR           reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 54 (commandA -> ON move exp CTE_INTEGER color ; .)


state 182

    (40) conditionA -> ELSE block .

    MOD             reduce using rule 40 (conditionA -> ELSE block .)
    ID              reduce using rule 40 (conditionA -> ELSE block .)
    IF              reduce using rule 40 (conditionA -> ELSE block .)
    ECHO            reduce using rule 40 (conditionA -> ELSE block .)
    "               reduce using rule 40 (conditionA -> ELSE block .)
    REPLAY          reduce using rule 40 (conditionA -> ELSE block .)
    SAMPLE          reduce using rule 40 (conditionA -> ELSE block .)
    #               reduce using rule 40 (conditionA -> ELSE block .)
    PIPE            reduce using rule 40 (conditionA -> ELSE block .)
    WHERE           reduce using rule 40 (conditionA -> ELSE block .)
    CLEAR           reduce using rule 40 (conditionA -> ELSE block .)
    OVAL            reduce using rule 40 (conditionA -> ELSE block .)
    TRIO            reduce using rule 40 (conditionA -> ELSE block .)
    QUAD            reduce using rule 40 (conditionA -> ELSE block .)
    ARC             reduce using rule 40 (conditionA -> ELSE block .)
    END             reduce using rule 40 (conditionA -> ELSE block .)
    }               reduce using rule 40 (conditionA -> ELSE block .)


state 183

    (18) moduleA -> ( vars ) block .

    MOD             reduce using rule 18 (moduleA -> ( vars ) block .)
    ID              reduce using rule 18 (moduleA -> ( vars ) block .)
    IF              reduce using rule 18 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 18 (moduleA -> ( vars ) block .)
    "               reduce using rule 18 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 18 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 18 (moduleA -> ( vars ) block .)
    #               reduce using rule 18 (moduleA -> ( vars ) block .)
    PIPE            reduce using rule 18 (moduleA -> ( vars ) block .)
    WHERE           reduce using rule 18 (moduleA -> ( vars ) block .)
    CLEAR           reduce using rule 18 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 18 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 18 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 18 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 18 (moduleA -> ( vars ) block .)
    END             reduce using rule 18 (moduleA -> ( vars ) block .)


state 184

    (20) vars -> type ID varsA .

    )               reduce using rule 20 (vars -> type ID varsA .)


state 185

    (21) varsA -> , . vars
    (20) vars -> . type ID varsA
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOL

    INT             shift and go to state 156
    FLOAT           shift and go to state 155
    BOOL            shift and go to state 157

    type                           shift and go to state 158
    vars                           shift and go to state 187

state 186

    (22) varsA -> empty .

    )               reduce using rule 22 (varsA -> empty .)


state 187

    (21) varsA -> , vars .

    )               reduce using rule 21 (varsA -> , vars .)

