Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> write
Rule 12    statute -> cycle
Rule 13    statute -> repeat
Rule 14    statute -> command
Rule 15    statute -> calling
Rule 16    statute -> array
Rule 17    statute -> matrix
Rule 18    statute -> screen
Rule 19    module -> MOD # moduleID insertQuadMod moduleA endMod
Rule 20    moduleA -> ( vars ) block
Rule 21    moduleA -> block
Rule 22    moduleID -> ID
Rule 23    vars -> type ID varsA
Rule 24    varsA -> , vars
Rule 25    varsA -> empty
Rule 26    type -> INT
Rule 27    type -> FLOAT
Rule 28    type -> BOOL
Rule 29    id -> ID [ sumdim exp ] [ sumdim exp ]
Rule 30    id -> ID [ sumdim exp ]
Rule 31    id -> ID
Rule 32    sumdim -> <empty>
Rule 33    calling -> # callID ( insertEra callingA
Rule 34    callID -> ID
Rule 35    insertEra -> <empty>
Rule 36    callingA -> callingB ) ;
Rule 37    callingA -> ) ;
Rule 38    callingB -> expression checkParam callingC
Rule 39    checkParam -> <empty>
Rule 40    callingC -> , sumXparam callingB
Rule 41    callingC -> empty
Rule 42    sumXparam -> <empty>
Rule 43    block -> { blockA
Rule 44    blockA -> blockB }
Rule 45    blockA -> }
Rule 46    blockB -> statute blockC
Rule 47    blockC -> blockB
Rule 48    blockC -> empty
Rule 49    assign -> id = expression ;
Rule 50    condition -> IF ( expression ) gotoFalse block conditionA continueGo
Rule 51    conditionA -> ELSE gotoE block
Rule 52    conditionA -> empty
Rule 53    write -> ECHO writeA ;
Rule 54    writeA -> expression
Rule 55    writeA -> CTE_STRING
Rule 56    array -> ARR typeDim ID [ CTE_INTEGER ] ;
Rule 57    matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
Rule 58    typeDim -> INT
Rule 59    typeDim -> FLOAT
Rule 60    typeDim -> BOOL
Rule 61    command -> figure exp exp color ;
Rule 62    command -> SAMPLE commandA
Rule 63    commandA -> ON move exp CTE_INTEGER color ;
Rule 64    commandA -> OFF move exp ;
Rule 65    cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW
Rule 66    repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ;
Rule 67    repeatA -> command repeatB
Rule 68    repeatB -> repeatA
Rule 69    repeatB -> empty
Rule 70    expression -> exp = = exp
Rule 71    expression -> exp < > exp
Rule 72    expression -> exp < = exp
Rule 73    expression -> exp > = exp
Rule 74    expression -> exp > exp
Rule 75    expression -> exp < exp
Rule 76    expression -> exp AND exp
Rule 77    expression -> exp OR exp
Rule 78    expression -> exp empty
Rule 79    exp -> exp + exp
Rule 80    exp -> exp - exp
Rule 81    exp -> exp * exp
Rule 82    exp -> exp / exp
Rule 83    exp -> factor empty
Rule 84    factor -> ( expression )
Rule 85    factor -> var_cte
Rule 86    figure -> OVAL
Rule 87    figure -> TRIO
Rule 88    figure -> QUAD
Rule 89    figure -> ARC
Rule 90    move -> UP
Rule 91    move -> DOWN
Rule 92    move -> LEFT
Rule 93    move -> RIGHT
Rule 94    color -> RED
Rule 95    color -> YELLOW
Rule 96    color -> BLUE
Rule 97    color -> GREEN
Rule 98    color -> BLACK
Rule 99    color -> WHITE
Rule 100   color -> ORANGE
Rule 101   color -> PURPLE
Rule 102   color -> CYAN
Rule 103   screen -> WHERE
Rule 104   screen -> CLEAR
Rule 105   var_cte -> id
Rule 106   var_cte -> CTE_INTEGER
Rule 107   var_cte -> CTE_FLOAT
Rule 108   var_cte -> TRUE
Rule 109   var_cte -> FALSE
Rule 110   gotoFalse -> <empty>
Rule 111   gotoE -> <empty>
Rule 112   gotoW -> <empty>
Rule 113   gotoR -> <empty>
Rule 114   continueGo -> <empty>
Rule 115   continueGoW -> <empty>
Rule 116   insertQuadMod -> <empty>
Rule 117   endMod -> <empty>
Rule 118   empty -> <empty>

Terminals, with rules where they appear

#                    : 19 33
(                    : 20 33 50 65 84
)                    : 20 36 37 50 65 84
*                    : 81
+                    : 79
,                    : 24 40
-                    : 80
/                    : 82
;                    : 36 37 49 53 56 57 61 63 64 66
<                    : 71 72 75
=                    : 49 70 70 72 73
>                    : 71 73 74
AND                  : 76
ARC                  : 89
ARR                  : 56
BLACK                : 98
BLUE                 : 96
BOOL                 : 28 60
CLEAR                : 104
CTE_FLOAT            : 107
CTE_INTEGER          : 56 57 57 63 66 106
CTE_STRING           : 55
CYAN                 : 102
DOWN                 : 91
ECHO                 : 53
ELSE                 : 51
END                  : 2 3
FALSE                : 109
FLOAT                : 27 59
GREEN                : 97
ID                   : 22 23 29 30 31 34 56 57
IF                   : 50
INIT                 : 1
INT                  : 26 58
LEFT                 : 92
MAT                  : 57
MOD                  : 19
OFF                  : 64
ON                   : 63
OR                   : 77
ORANGE               : 100
OVAL                 : 86
PURPLE               : 101
QUAD                 : 88
RED                  : 94
REPLAY               : 66
RIGHT                : 93
SAMPLE               : 62
TRIO                 : 87
TRUE                 : 108
UP                   : 90
WHERE                : 103
WHILE                : 65
WHITE                : 99
YELLOW               : 95
[                    : 29 29 30 56 57 57 66
]                    : 29 29 30 56 57 57 66
error                : 
{                    : 43
}                    : 44 45

Nonterminals, with rules where they appear

array                : 16
assign               : 9
block                : 20 21 50 51 65
blockA               : 43
blockB               : 44 47
blockC               : 46
callID               : 33
calling              : 15
callingA             : 33
callingB             : 36 40
callingC             : 38
checkParam           : 38
color                : 61 63
command              : 14 67
commandA             : 62
condition            : 10
conditionA           : 50
continueGo           : 50
continueGoW          : 65
cycle                : 12
empty                : 6 25 41 48 52 69 78 83
endMod               : 19
exp                  : 29 29 30 61 61 63 64 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 79 79 80 80 81 81 82 82
expression           : 38 49 50 54 65 84
factor               : 83
figure               : 61
gotoE                : 51
gotoFalse            : 50 65
gotoR                : 66
gotoW                : 65
id                   : 49 105
insertEra            : 33
insertQuadMod        : 19
matrix               : 17
module               : 8
moduleA              : 19
moduleID             : 19
move                 : 63 64
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
repeat               : 13
repeatA              : 66 68
repeatB              : 67
screen               : 18
statute              : 7 46
sumXparam            : 40
sumdim               : 29 29 30
type                 : 23
typeDim              : 56 57
var_cte              : 85
vars                 : 20 24
varsA                : 23
workspace            : 4
write                : 11
writeA               : 53

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . screen
    (19) module -> . MOD # moduleID insertQuadMod moduleA endMod
    (49) assign -> . id = expression ;
    (50) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (53) write -> . ECHO writeA ;
    (65) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (66) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (61) command -> . figure exp exp color ;
    (62) command -> . SAMPLE commandA
    (33) calling -> . # callID ( insertEra callingA
    (56) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (57) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (103) screen -> . WHERE
    (104) screen -> . CLEAR
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID
    (86) figure -> . OVAL
    (87) figure -> . TRIO
    (88) figure -> . QUAD
    (89) figure -> . ARC

    END             shift and go to state 17
    MOD             shift and go to state 35
    IF              shift and go to state 13
    ECHO            shift and go to state 19
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 20
    #               shift and go to state 10
    ARR             shift and go to state 28
    MAT             shift and go to state 29
    WHERE           shift and go to state 31
    CLEAR           shift and go to state 14
    ID              shift and go to state 24
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 23
    ARC             shift and go to state 32

    figure                         shift and go to state 3
    module                         shift and go to state 4
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    condition                      shift and go to state 25
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    programA                       shift and go to state 21
    programB                       shift and go to state 22
    cycle                          shift and go to state 26
    statute                        shift and go to state 27
    calling                        shift and go to state 30
    command                        shift and go to state 33
    workspace                      shift and go to state 34
    assign                         shift and go to state 36

state 2

    (0) S' -> program .



state 3

    (61) command -> figure . exp exp color ;
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 45
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 4

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    WHILE           reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    ARR             reduce using rule 8 (workspace -> module .)
    MAT             reduce using rule 8 (workspace -> module .)
    WHERE           reduce using rule 8 (workspace -> module .)
    CLEAR           reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 5

    (86) figure -> OVAL .

    (               reduce using rule 86 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 86 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 86 (figure -> OVAL .)
    TRUE            reduce using rule 86 (figure -> OVAL .)
    FALSE           reduce using rule 86 (figure -> OVAL .)
    ID              reduce using rule 86 (figure -> OVAL .)


state 6

    (65) cycle -> WHILE . gotoW ( expression ) gotoFalse block continueGoW
    (112) gotoW -> .

    (               reduce using rule 112 (gotoW -> .)

    gotoW                          shift and go to state 46

state 7

    (66) repeat -> REPLAY . CTE_INTEGER gotoR [ repeatA ] ;

    CTE_INTEGER     shift and go to state 47


state 8

    (16) statute -> array .

    IF              reduce using rule 16 (statute -> array .)
    ECHO            reduce using rule 16 (statute -> array .)
    WHILE           reduce using rule 16 (statute -> array .)
    REPLAY          reduce using rule 16 (statute -> array .)
    SAMPLE          reduce using rule 16 (statute -> array .)
    #               reduce using rule 16 (statute -> array .)
    ARR             reduce using rule 16 (statute -> array .)
    MAT             reduce using rule 16 (statute -> array .)
    WHERE           reduce using rule 16 (statute -> array .)
    CLEAR           reduce using rule 16 (statute -> array .)
    ID              reduce using rule 16 (statute -> array .)
    OVAL            reduce using rule 16 (statute -> array .)
    TRIO            reduce using rule 16 (statute -> array .)
    QUAD            reduce using rule 16 (statute -> array .)
    ARC             reduce using rule 16 (statute -> array .)
    }               reduce using rule 16 (statute -> array .)
    MOD             reduce using rule 16 (statute -> array .)
    END             reduce using rule 16 (statute -> array .)


state 9

    (49) assign -> id . = expression ;

    =               shift and go to state 48


state 10

    (33) calling -> # . callID ( insertEra callingA
    (34) callID -> . ID

    ID              shift and go to state 50

    callID                         shift and go to state 49

state 11

    (17) statute -> matrix .

    IF              reduce using rule 17 (statute -> matrix .)
    ECHO            reduce using rule 17 (statute -> matrix .)
    WHILE           reduce using rule 17 (statute -> matrix .)
    REPLAY          reduce using rule 17 (statute -> matrix .)
    SAMPLE          reduce using rule 17 (statute -> matrix .)
    #               reduce using rule 17 (statute -> matrix .)
    ARR             reduce using rule 17 (statute -> matrix .)
    MAT             reduce using rule 17 (statute -> matrix .)
    WHERE           reduce using rule 17 (statute -> matrix .)
    CLEAR           reduce using rule 17 (statute -> matrix .)
    ID              reduce using rule 17 (statute -> matrix .)
    OVAL            reduce using rule 17 (statute -> matrix .)
    TRIO            reduce using rule 17 (statute -> matrix .)
    QUAD            reduce using rule 17 (statute -> matrix .)
    ARC             reduce using rule 17 (statute -> matrix .)
    }               reduce using rule 17 (statute -> matrix .)
    MOD             reduce using rule 17 (statute -> matrix .)
    END             reduce using rule 17 (statute -> matrix .)


state 12

    (11) statute -> write .

    IF              reduce using rule 11 (statute -> write .)
    ECHO            reduce using rule 11 (statute -> write .)
    WHILE           reduce using rule 11 (statute -> write .)
    REPLAY          reduce using rule 11 (statute -> write .)
    SAMPLE          reduce using rule 11 (statute -> write .)
    #               reduce using rule 11 (statute -> write .)
    ARR             reduce using rule 11 (statute -> write .)
    MAT             reduce using rule 11 (statute -> write .)
    WHERE           reduce using rule 11 (statute -> write .)
    CLEAR           reduce using rule 11 (statute -> write .)
    ID              reduce using rule 11 (statute -> write .)
    OVAL            reduce using rule 11 (statute -> write .)
    TRIO            reduce using rule 11 (statute -> write .)
    QUAD            reduce using rule 11 (statute -> write .)
    ARC             reduce using rule 11 (statute -> write .)
    }               reduce using rule 11 (statute -> write .)
    MOD             reduce using rule 11 (statute -> write .)
    END             reduce using rule 11 (statute -> write .)


state 13

    (50) condition -> IF . ( expression ) gotoFalse block conditionA continueGo

    (               shift and go to state 51


state 14

    (104) screen -> CLEAR .

    IF              reduce using rule 104 (screen -> CLEAR .)
    ECHO            reduce using rule 104 (screen -> CLEAR .)
    WHILE           reduce using rule 104 (screen -> CLEAR .)
    REPLAY          reduce using rule 104 (screen -> CLEAR .)
    SAMPLE          reduce using rule 104 (screen -> CLEAR .)
    #               reduce using rule 104 (screen -> CLEAR .)
    ARR             reduce using rule 104 (screen -> CLEAR .)
    MAT             reduce using rule 104 (screen -> CLEAR .)
    WHERE           reduce using rule 104 (screen -> CLEAR .)
    CLEAR           reduce using rule 104 (screen -> CLEAR .)
    ID              reduce using rule 104 (screen -> CLEAR .)
    OVAL            reduce using rule 104 (screen -> CLEAR .)
    TRIO            reduce using rule 104 (screen -> CLEAR .)
    QUAD            reduce using rule 104 (screen -> CLEAR .)
    ARC             reduce using rule 104 (screen -> CLEAR .)
    }               reduce using rule 104 (screen -> CLEAR .)
    MOD             reduce using rule 104 (screen -> CLEAR .)
    END             reduce using rule 104 (screen -> CLEAR .)


state 15

    (87) figure -> TRIO .

    (               reduce using rule 87 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 87 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 87 (figure -> TRIO .)
    TRUE            reduce using rule 87 (figure -> TRIO .)
    FALSE           reduce using rule 87 (figure -> TRIO .)
    ID              reduce using rule 87 (figure -> TRIO .)


state 16

    (13) statute -> repeat .

    IF              reduce using rule 13 (statute -> repeat .)
    ECHO            reduce using rule 13 (statute -> repeat .)
    WHILE           reduce using rule 13 (statute -> repeat .)
    REPLAY          reduce using rule 13 (statute -> repeat .)
    SAMPLE          reduce using rule 13 (statute -> repeat .)
    #               reduce using rule 13 (statute -> repeat .)
    ARR             reduce using rule 13 (statute -> repeat .)
    MAT             reduce using rule 13 (statute -> repeat .)
    WHERE           reduce using rule 13 (statute -> repeat .)
    CLEAR           reduce using rule 13 (statute -> repeat .)
    ID              reduce using rule 13 (statute -> repeat .)
    OVAL            reduce using rule 13 (statute -> repeat .)
    TRIO            reduce using rule 13 (statute -> repeat .)
    QUAD            reduce using rule 13 (statute -> repeat .)
    ARC             reduce using rule 13 (statute -> repeat .)
    }               reduce using rule 13 (statute -> repeat .)
    MOD             reduce using rule 13 (statute -> repeat .)
    END             reduce using rule 13 (statute -> repeat .)


state 17

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 18

    (18) statute -> screen .

    IF              reduce using rule 18 (statute -> screen .)
    ECHO            reduce using rule 18 (statute -> screen .)
    WHILE           reduce using rule 18 (statute -> screen .)
    REPLAY          reduce using rule 18 (statute -> screen .)
    SAMPLE          reduce using rule 18 (statute -> screen .)
    #               reduce using rule 18 (statute -> screen .)
    ARR             reduce using rule 18 (statute -> screen .)
    MAT             reduce using rule 18 (statute -> screen .)
    WHERE           reduce using rule 18 (statute -> screen .)
    CLEAR           reduce using rule 18 (statute -> screen .)
    ID              reduce using rule 18 (statute -> screen .)
    OVAL            reduce using rule 18 (statute -> screen .)
    TRIO            reduce using rule 18 (statute -> screen .)
    QUAD            reduce using rule 18 (statute -> screen .)
    ARC             reduce using rule 18 (statute -> screen .)
    }               reduce using rule 18 (statute -> screen .)
    MOD             reduce using rule 18 (statute -> screen .)
    END             reduce using rule 18 (statute -> screen .)


state 19

    (53) write -> ECHO . writeA ;
    (54) writeA -> . expression
    (55) writeA -> . CTE_STRING
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    CTE_STRING      shift and go to state 53
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 54
    factor                         shift and go to state 41
    writeA                         shift and go to state 52
    expression                     shift and go to state 55
    id                             shift and go to state 39

state 20

    (62) command -> SAMPLE . commandA
    (63) commandA -> . ON move exp CTE_INTEGER color ;
    (64) commandA -> . OFF move exp ;

    ON              shift and go to state 58
    OFF             shift and go to state 57

    commandA                       shift and go to state 56

state 21

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 22

    (2) programA -> programB . END

    END             shift and go to state 59


state 23

    (88) figure -> QUAD .

    (               reduce using rule 88 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 88 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 88 (figure -> QUAD .)
    TRUE            reduce using rule 88 (figure -> QUAD .)
    FALSE           reduce using rule 88 (figure -> QUAD .)
    ID              reduce using rule 88 (figure -> QUAD .)


state 24

    (29) id -> ID . [ sumdim exp ] [ sumdim exp ]
    (30) id -> ID . [ sumdim exp ]
    (31) id -> ID .

    [               shift and go to state 60
    +               reduce using rule 31 (id -> ID .)
    -               reduce using rule 31 (id -> ID .)
    *               reduce using rule 31 (id -> ID .)
    /               reduce using rule 31 (id -> ID .)
    ;               reduce using rule 31 (id -> ID .)
    )               reduce using rule 31 (id -> ID .)
    ,               reduce using rule 31 (id -> ID .)
    (               reduce using rule 31 (id -> ID .)
    CTE_INTEGER     reduce using rule 31 (id -> ID .)
    CTE_FLOAT       reduce using rule 31 (id -> ID .)
    TRUE            reduce using rule 31 (id -> ID .)
    FALSE           reduce using rule 31 (id -> ID .)
    ID              reduce using rule 31 (id -> ID .)
    =               reduce using rule 31 (id -> ID .)
    <               reduce using rule 31 (id -> ID .)
    >               reduce using rule 31 (id -> ID .)
    AND             reduce using rule 31 (id -> ID .)
    OR              reduce using rule 31 (id -> ID .)
    RED             reduce using rule 31 (id -> ID .)
    YELLOW          reduce using rule 31 (id -> ID .)
    BLUE            reduce using rule 31 (id -> ID .)
    GREEN           reduce using rule 31 (id -> ID .)
    BLACK           reduce using rule 31 (id -> ID .)
    WHITE           reduce using rule 31 (id -> ID .)
    ORANGE          reduce using rule 31 (id -> ID .)
    PURPLE          reduce using rule 31 (id -> ID .)
    CYAN            reduce using rule 31 (id -> ID .)
    ]               reduce using rule 31 (id -> ID .)


state 25

    (10) statute -> condition .

    IF              reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    WHILE           reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    ARR             reduce using rule 10 (statute -> condition .)
    MAT             reduce using rule 10 (statute -> condition .)
    WHERE           reduce using rule 10 (statute -> condition .)
    CLEAR           reduce using rule 10 (statute -> condition .)
    ID              reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)
    MOD             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)


state 26

    (12) statute -> cycle .

    IF              reduce using rule 12 (statute -> cycle .)
    ECHO            reduce using rule 12 (statute -> cycle .)
    WHILE           reduce using rule 12 (statute -> cycle .)
    REPLAY          reduce using rule 12 (statute -> cycle .)
    SAMPLE          reduce using rule 12 (statute -> cycle .)
    #               reduce using rule 12 (statute -> cycle .)
    ARR             reduce using rule 12 (statute -> cycle .)
    MAT             reduce using rule 12 (statute -> cycle .)
    WHERE           reduce using rule 12 (statute -> cycle .)
    CLEAR           reduce using rule 12 (statute -> cycle .)
    ID              reduce using rule 12 (statute -> cycle .)
    OVAL            reduce using rule 12 (statute -> cycle .)
    TRIO            reduce using rule 12 (statute -> cycle .)
    QUAD            reduce using rule 12 (statute -> cycle .)
    ARC             reduce using rule 12 (statute -> cycle .)
    }               reduce using rule 12 (statute -> cycle .)
    MOD             reduce using rule 12 (statute -> cycle .)
    END             reduce using rule 12 (statute -> cycle .)


state 27

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    WHILE           reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    ARR             reduce using rule 7 (workspace -> statute .)
    MAT             reduce using rule 7 (workspace -> statute .)
    WHERE           reduce using rule 7 (workspace -> statute .)
    CLEAR           reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 28

    (56) array -> ARR . typeDim ID [ CTE_INTEGER ] ;
    (58) typeDim -> . INT
    (59) typeDim -> . FLOAT
    (60) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 63

state 29

    (57) matrix -> MAT . typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (58) typeDim -> . INT
    (59) typeDim -> . FLOAT
    (60) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 65

state 30

    (15) statute -> calling .

    IF              reduce using rule 15 (statute -> calling .)
    ECHO            reduce using rule 15 (statute -> calling .)
    WHILE           reduce using rule 15 (statute -> calling .)
    REPLAY          reduce using rule 15 (statute -> calling .)
    SAMPLE          reduce using rule 15 (statute -> calling .)
    #               reduce using rule 15 (statute -> calling .)
    ARR             reduce using rule 15 (statute -> calling .)
    MAT             reduce using rule 15 (statute -> calling .)
    WHERE           reduce using rule 15 (statute -> calling .)
    CLEAR           reduce using rule 15 (statute -> calling .)
    ID              reduce using rule 15 (statute -> calling .)
    OVAL            reduce using rule 15 (statute -> calling .)
    TRIO            reduce using rule 15 (statute -> calling .)
    QUAD            reduce using rule 15 (statute -> calling .)
    ARC             reduce using rule 15 (statute -> calling .)
    }               reduce using rule 15 (statute -> calling .)
    MOD             reduce using rule 15 (statute -> calling .)
    END             reduce using rule 15 (statute -> calling .)


state 31

    (103) screen -> WHERE .

    IF              reduce using rule 103 (screen -> WHERE .)
    ECHO            reduce using rule 103 (screen -> WHERE .)
    WHILE           reduce using rule 103 (screen -> WHERE .)
    REPLAY          reduce using rule 103 (screen -> WHERE .)
    SAMPLE          reduce using rule 103 (screen -> WHERE .)
    #               reduce using rule 103 (screen -> WHERE .)
    ARR             reduce using rule 103 (screen -> WHERE .)
    MAT             reduce using rule 103 (screen -> WHERE .)
    WHERE           reduce using rule 103 (screen -> WHERE .)
    CLEAR           reduce using rule 103 (screen -> WHERE .)
    ID              reduce using rule 103 (screen -> WHERE .)
    OVAL            reduce using rule 103 (screen -> WHERE .)
    TRIO            reduce using rule 103 (screen -> WHERE .)
    QUAD            reduce using rule 103 (screen -> WHERE .)
    ARC             reduce using rule 103 (screen -> WHERE .)
    }               reduce using rule 103 (screen -> WHERE .)
    MOD             reduce using rule 103 (screen -> WHERE .)
    END             reduce using rule 103 (screen -> WHERE .)


state 32

    (89) figure -> ARC .

    (               reduce using rule 89 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 89 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 89 (figure -> ARC .)
    TRUE            reduce using rule 89 (figure -> ARC .)
    FALSE           reduce using rule 89 (figure -> ARC .)
    ID              reduce using rule 89 (figure -> ARC .)


state 33

    (14) statute -> command .

    IF              reduce using rule 14 (statute -> command .)
    ECHO            reduce using rule 14 (statute -> command .)
    WHILE           reduce using rule 14 (statute -> command .)
    REPLAY          reduce using rule 14 (statute -> command .)
    SAMPLE          reduce using rule 14 (statute -> command .)
    #               reduce using rule 14 (statute -> command .)
    ARR             reduce using rule 14 (statute -> command .)
    MAT             reduce using rule 14 (statute -> command .)
    WHERE           reduce using rule 14 (statute -> command .)
    CLEAR           reduce using rule 14 (statute -> command .)
    ID              reduce using rule 14 (statute -> command .)
    OVAL            reduce using rule 14 (statute -> command .)
    TRIO            reduce using rule 14 (statute -> command .)
    QUAD            reduce using rule 14 (statute -> command .)
    ARC             reduce using rule 14 (statute -> command .)
    }               reduce using rule 14 (statute -> command .)
    MOD             reduce using rule 14 (statute -> command .)
    END             reduce using rule 14 (statute -> command .)


state 34

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (118) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . screen
    (19) module -> . MOD # moduleID insertQuadMod moduleA endMod
    (49) assign -> . id = expression ;
    (50) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (53) write -> . ECHO writeA ;
    (65) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (66) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (61) command -> . figure exp exp color ;
    (62) command -> . SAMPLE commandA
    (33) calling -> . # callID ( insertEra callingA
    (56) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (57) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (103) screen -> . WHERE
    (104) screen -> . CLEAR
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID
    (86) figure -> . OVAL
    (87) figure -> . TRIO
    (88) figure -> . QUAD
    (89) figure -> . ARC

    END             reduce using rule 118 (empty -> .)
    MOD             shift and go to state 35
    IF              shift and go to state 13
    ECHO            shift and go to state 19
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 20
    #               shift and go to state 10
    ARR             shift and go to state 28
    MAT             shift and go to state 29
    WHERE           shift and go to state 31
    CLEAR           shift and go to state 14
    ID              shift and go to state 24
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 23
    ARC             shift and go to state 32

    figure                         shift and go to state 3
    module                         shift and go to state 4
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    condition                      shift and go to state 25
    empty                          shift and go to state 66
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    programB                       shift and go to state 67
    programC                       shift and go to state 68
    cycle                          shift and go to state 26
    statute                        shift and go to state 27
    calling                        shift and go to state 30
    command                        shift and go to state 33
    workspace                      shift and go to state 34
    assign                         shift and go to state 36

state 35

    (19) module -> MOD . # moduleID insertQuadMod moduleA endMod

    #               shift and go to state 69


state 36

    (9) statute -> assign .

    IF              reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    WHILE           reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    ARR             reduce using rule 9 (statute -> assign .)
    MAT             reduce using rule 9 (statute -> assign .)
    WHERE           reduce using rule 9 (statute -> assign .)
    CLEAR           reduce using rule 9 (statute -> assign .)
    ID              reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)
    MOD             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)


state 37

    (85) factor -> var_cte .

    =               reduce using rule 85 (factor -> var_cte .)
    <               reduce using rule 85 (factor -> var_cte .)
    >               reduce using rule 85 (factor -> var_cte .)
    AND             reduce using rule 85 (factor -> var_cte .)
    OR              reduce using rule 85 (factor -> var_cte .)
    +               reduce using rule 85 (factor -> var_cte .)
    -               reduce using rule 85 (factor -> var_cte .)
    *               reduce using rule 85 (factor -> var_cte .)
    /               reduce using rule 85 (factor -> var_cte .)
    ;               reduce using rule 85 (factor -> var_cte .)
    )               reduce using rule 85 (factor -> var_cte .)
    ,               reduce using rule 85 (factor -> var_cte .)
    ]               reduce using rule 85 (factor -> var_cte .)
    (               reduce using rule 85 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 85 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 85 (factor -> var_cte .)
    TRUE            reduce using rule 85 (factor -> var_cte .)
    FALSE           reduce using rule 85 (factor -> var_cte .)
    ID              reduce using rule 85 (factor -> var_cte .)
    RED             reduce using rule 85 (factor -> var_cte .)
    YELLOW          reduce using rule 85 (factor -> var_cte .)
    BLUE            reduce using rule 85 (factor -> var_cte .)
    GREEN           reduce using rule 85 (factor -> var_cte .)
    BLACK           reduce using rule 85 (factor -> var_cte .)
    WHITE           reduce using rule 85 (factor -> var_cte .)
    ORANGE          reduce using rule 85 (factor -> var_cte .)
    PURPLE          reduce using rule 85 (factor -> var_cte .)
    CYAN            reduce using rule 85 (factor -> var_cte .)


state 38

    (108) var_cte -> TRUE .

    =               reduce using rule 108 (var_cte -> TRUE .)
    <               reduce using rule 108 (var_cte -> TRUE .)
    >               reduce using rule 108 (var_cte -> TRUE .)
    AND             reduce using rule 108 (var_cte -> TRUE .)
    OR              reduce using rule 108 (var_cte -> TRUE .)
    +               reduce using rule 108 (var_cte -> TRUE .)
    -               reduce using rule 108 (var_cte -> TRUE .)
    *               reduce using rule 108 (var_cte -> TRUE .)
    /               reduce using rule 108 (var_cte -> TRUE .)
    ;               reduce using rule 108 (var_cte -> TRUE .)
    )               reduce using rule 108 (var_cte -> TRUE .)
    ,               reduce using rule 108 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 108 (var_cte -> TRUE .)
    RED             reduce using rule 108 (var_cte -> TRUE .)
    YELLOW          reduce using rule 108 (var_cte -> TRUE .)
    BLUE            reduce using rule 108 (var_cte -> TRUE .)
    GREEN           reduce using rule 108 (var_cte -> TRUE .)
    BLACK           reduce using rule 108 (var_cte -> TRUE .)
    WHITE           reduce using rule 108 (var_cte -> TRUE .)
    ORANGE          reduce using rule 108 (var_cte -> TRUE .)
    PURPLE          reduce using rule 108 (var_cte -> TRUE .)
    CYAN            reduce using rule 108 (var_cte -> TRUE .)
    ]               reduce using rule 108 (var_cte -> TRUE .)
    (               reduce using rule 108 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 108 (var_cte -> TRUE .)
    TRUE            reduce using rule 108 (var_cte -> TRUE .)
    FALSE           reduce using rule 108 (var_cte -> TRUE .)
    ID              reduce using rule 108 (var_cte -> TRUE .)


state 39

    (105) var_cte -> id .

    =               reduce using rule 105 (var_cte -> id .)
    <               reduce using rule 105 (var_cte -> id .)
    >               reduce using rule 105 (var_cte -> id .)
    AND             reduce using rule 105 (var_cte -> id .)
    OR              reduce using rule 105 (var_cte -> id .)
    +               reduce using rule 105 (var_cte -> id .)
    -               reduce using rule 105 (var_cte -> id .)
    *               reduce using rule 105 (var_cte -> id .)
    /               reduce using rule 105 (var_cte -> id .)
    ;               reduce using rule 105 (var_cte -> id .)
    )               reduce using rule 105 (var_cte -> id .)
    ,               reduce using rule 105 (var_cte -> id .)
    CTE_INTEGER     reduce using rule 105 (var_cte -> id .)
    RED             reduce using rule 105 (var_cte -> id .)
    YELLOW          reduce using rule 105 (var_cte -> id .)
    BLUE            reduce using rule 105 (var_cte -> id .)
    GREEN           reduce using rule 105 (var_cte -> id .)
    BLACK           reduce using rule 105 (var_cte -> id .)
    WHITE           reduce using rule 105 (var_cte -> id .)
    ORANGE          reduce using rule 105 (var_cte -> id .)
    PURPLE          reduce using rule 105 (var_cte -> id .)
    CYAN            reduce using rule 105 (var_cte -> id .)
    ]               reduce using rule 105 (var_cte -> id .)
    (               reduce using rule 105 (var_cte -> id .)
    CTE_FLOAT       reduce using rule 105 (var_cte -> id .)
    TRUE            reduce using rule 105 (var_cte -> id .)
    FALSE           reduce using rule 105 (var_cte -> id .)
    ID              reduce using rule 105 (var_cte -> id .)


state 40

    (84) factor -> ( . expression )
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 54
    factor                         shift and go to state 41
    expression                     shift and go to state 70
    id                             shift and go to state 39

state 41

    (83) exp -> factor . empty
    (118) empty -> .

    +               reduce using rule 118 (empty -> .)
    -               reduce using rule 118 (empty -> .)
    *               reduce using rule 118 (empty -> .)
    /               reduce using rule 118 (empty -> .)
    (               reduce using rule 118 (empty -> .)
    CTE_INTEGER     reduce using rule 118 (empty -> .)
    CTE_FLOAT       reduce using rule 118 (empty -> .)
    TRUE            reduce using rule 118 (empty -> .)
    FALSE           reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    =               reduce using rule 118 (empty -> .)
    <               reduce using rule 118 (empty -> .)
    >               reduce using rule 118 (empty -> .)
    AND             reduce using rule 118 (empty -> .)
    OR              reduce using rule 118 (empty -> .)
    ;               reduce using rule 118 (empty -> .)
    )               reduce using rule 118 (empty -> .)
    RED             reduce using rule 118 (empty -> .)
    YELLOW          reduce using rule 118 (empty -> .)
    BLUE            reduce using rule 118 (empty -> .)
    GREEN           reduce using rule 118 (empty -> .)
    BLACK           reduce using rule 118 (empty -> .)
    WHITE           reduce using rule 118 (empty -> .)
    ORANGE          reduce using rule 118 (empty -> .)
    PURPLE          reduce using rule 118 (empty -> .)
    CYAN            reduce using rule 118 (empty -> .)
    ,               reduce using rule 118 (empty -> .)
    ]               reduce using rule 118 (empty -> .)

    empty                          shift and go to state 71

state 42

    (106) var_cte -> CTE_INTEGER .

    =               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 106 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 106 (var_cte -> CTE_INTEGER .)
    +               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 106 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 106 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 106 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 106 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 106 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 106 (var_cte -> CTE_INTEGER .)
    WHITE           reduce using rule 106 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 106 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 106 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 106 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 106 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 106 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 106 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 106 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 106 (var_cte -> CTE_INTEGER .)


state 43

    (109) var_cte -> FALSE .

    =               reduce using rule 109 (var_cte -> FALSE .)
    <               reduce using rule 109 (var_cte -> FALSE .)
    >               reduce using rule 109 (var_cte -> FALSE .)
    AND             reduce using rule 109 (var_cte -> FALSE .)
    OR              reduce using rule 109 (var_cte -> FALSE .)
    +               reduce using rule 109 (var_cte -> FALSE .)
    -               reduce using rule 109 (var_cte -> FALSE .)
    *               reduce using rule 109 (var_cte -> FALSE .)
    /               reduce using rule 109 (var_cte -> FALSE .)
    ;               reduce using rule 109 (var_cte -> FALSE .)
    )               reduce using rule 109 (var_cte -> FALSE .)
    ,               reduce using rule 109 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 109 (var_cte -> FALSE .)
    RED             reduce using rule 109 (var_cte -> FALSE .)
    YELLOW          reduce using rule 109 (var_cte -> FALSE .)
    BLUE            reduce using rule 109 (var_cte -> FALSE .)
    GREEN           reduce using rule 109 (var_cte -> FALSE .)
    BLACK           reduce using rule 109 (var_cte -> FALSE .)
    WHITE           reduce using rule 109 (var_cte -> FALSE .)
    ORANGE          reduce using rule 109 (var_cte -> FALSE .)
    PURPLE          reduce using rule 109 (var_cte -> FALSE .)
    CYAN            reduce using rule 109 (var_cte -> FALSE .)
    ]               reduce using rule 109 (var_cte -> FALSE .)
    (               reduce using rule 109 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 109 (var_cte -> FALSE .)
    TRUE            reduce using rule 109 (var_cte -> FALSE .)
    FALSE           reduce using rule 109 (var_cte -> FALSE .)
    ID              reduce using rule 109 (var_cte -> FALSE .)


state 44

    (107) var_cte -> CTE_FLOAT .

    =               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 107 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 107 (var_cte -> CTE_FLOAT .)
    +               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 107 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 107 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 107 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 107 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 107 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 107 (var_cte -> CTE_FLOAT .)
    WHITE           reduce using rule 107 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 107 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 107 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 107 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 107 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 107 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 107 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 107 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 107 (var_cte -> CTE_FLOAT .)


state 45

    (61) command -> figure exp . exp color ;
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 76
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 46

    (65) cycle -> WHILE gotoW . ( expression ) gotoFalse block continueGoW

    (               shift and go to state 77


state 47

    (66) repeat -> REPLAY CTE_INTEGER . gotoR [ repeatA ] ;
    (113) gotoR -> .

    [               reduce using rule 113 (gotoR -> .)

    gotoR                          shift and go to state 78

state 48

    (49) assign -> id = . expression ;
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 54
    factor                         shift and go to state 41
    expression                     shift and go to state 79
    id                             shift and go to state 39

state 49

    (33) calling -> # callID . ( insertEra callingA

    (               shift and go to state 80


state 50

    (34) callID -> ID .

    (               reduce using rule 34 (callID -> ID .)


state 51

    (50) condition -> IF ( . expression ) gotoFalse block conditionA continueGo
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    exp                            shift and go to state 54
    factor                         shift and go to state 41
    var_cte                        shift and go to state 37
    expression                     shift and go to state 81
    id                             shift and go to state 39

state 52

    (53) write -> ECHO writeA . ;

    ;               shift and go to state 82


state 53

    (55) writeA -> CTE_STRING .

    ;               reduce using rule 55 (writeA -> CTE_STRING .)


state 54

    (70) expression -> exp . = = exp
    (71) expression -> exp . < > exp
    (72) expression -> exp . < = exp
    (73) expression -> exp . > = exp
    (74) expression -> exp . > exp
    (75) expression -> exp . < exp
    (76) expression -> exp . AND exp
    (77) expression -> exp . OR exp
    (78) expression -> exp . empty
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp
    (118) empty -> .

    =               shift and go to state 85
    <               shift and go to state 84
    >               shift and go to state 88
    AND             shift and go to state 83
    OR              shift and go to state 86
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    ;               reduce using rule 118 (empty -> .)
    )               reduce using rule 118 (empty -> .)
    ,               reduce using rule 118 (empty -> .)

    empty                          shift and go to state 87

state 55

    (54) writeA -> expression .

    ;               reduce using rule 54 (writeA -> expression .)


state 56

    (62) command -> SAMPLE commandA .

    SAMPLE          reduce using rule 62 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 62 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 62 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 62 (command -> SAMPLE commandA .)
    ARC             reduce using rule 62 (command -> SAMPLE commandA .)
    ]               reduce using rule 62 (command -> SAMPLE commandA .)
    IF              reduce using rule 62 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 62 (command -> SAMPLE commandA .)
    WHILE           reduce using rule 62 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 62 (command -> SAMPLE commandA .)
    #               reduce using rule 62 (command -> SAMPLE commandA .)
    ARR             reduce using rule 62 (command -> SAMPLE commandA .)
    MAT             reduce using rule 62 (command -> SAMPLE commandA .)
    WHERE           reduce using rule 62 (command -> SAMPLE commandA .)
    CLEAR           reduce using rule 62 (command -> SAMPLE commandA .)
    ID              reduce using rule 62 (command -> SAMPLE commandA .)
    }               reduce using rule 62 (command -> SAMPLE commandA .)
    MOD             reduce using rule 62 (command -> SAMPLE commandA .)
    END             reduce using rule 62 (command -> SAMPLE commandA .)


state 57

    (64) commandA -> OFF . move exp ;
    (90) move -> . UP
    (91) move -> . DOWN
    (92) move -> . LEFT
    (93) move -> . RIGHT

    UP              shift and go to state 91
    DOWN            shift and go to state 92
    LEFT            shift and go to state 93
    RIGHT           shift and go to state 89

    move                           shift and go to state 90

state 58

    (63) commandA -> ON . move exp CTE_INTEGER color ;
    (90) move -> . UP
    (91) move -> . DOWN
    (92) move -> . LEFT
    (93) move -> . RIGHT

    UP              shift and go to state 91
    DOWN            shift and go to state 92
    LEFT            shift and go to state 93
    RIGHT           shift and go to state 89

    move                           shift and go to state 94

state 59

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 60

    (29) id -> ID [ . sumdim exp ] [ sumdim exp ]
    (30) id -> ID [ . sumdim exp ]
    (32) sumdim -> .

    (               reduce using rule 32 (sumdim -> .)
    CTE_INTEGER     reduce using rule 32 (sumdim -> .)
    CTE_FLOAT       reduce using rule 32 (sumdim -> .)
    TRUE            reduce using rule 32 (sumdim -> .)
    FALSE           reduce using rule 32 (sumdim -> .)
    ID              reduce using rule 32 (sumdim -> .)

    sumdim                         shift and go to state 95

state 61

    (58) typeDim -> INT .

    ID              reduce using rule 58 (typeDim -> INT .)


state 62

    (59) typeDim -> FLOAT .

    ID              reduce using rule 59 (typeDim -> FLOAT .)


state 63

    (56) array -> ARR typeDim . ID [ CTE_INTEGER ] ;

    ID              shift and go to state 96


state 64

    (60) typeDim -> BOOL .

    ID              reduce using rule 60 (typeDim -> BOOL .)


state 65

    (57) matrix -> MAT typeDim . ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    ID              shift and go to state 97


state 66

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 67

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 68

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 69

    (19) module -> MOD # . moduleID insertQuadMod moduleA endMod
    (22) moduleID -> . ID

    ID              shift and go to state 98

    moduleID                       shift and go to state 99

state 70

    (84) factor -> ( expression . )

    )               shift and go to state 100


state 71

    (83) exp -> factor empty .

    +               reduce using rule 83 (exp -> factor empty .)
    -               reduce using rule 83 (exp -> factor empty .)
    *               reduce using rule 83 (exp -> factor empty .)
    /               reduce using rule 83 (exp -> factor empty .)
    (               reduce using rule 83 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 83 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 83 (exp -> factor empty .)
    TRUE            reduce using rule 83 (exp -> factor empty .)
    FALSE           reduce using rule 83 (exp -> factor empty .)
    ID              reduce using rule 83 (exp -> factor empty .)
    =               reduce using rule 83 (exp -> factor empty .)
    <               reduce using rule 83 (exp -> factor empty .)
    >               reduce using rule 83 (exp -> factor empty .)
    AND             reduce using rule 83 (exp -> factor empty .)
    OR              reduce using rule 83 (exp -> factor empty .)
    )               reduce using rule 83 (exp -> factor empty .)
    ;               reduce using rule 83 (exp -> factor empty .)
    ,               reduce using rule 83 (exp -> factor empty .)
    RED             reduce using rule 83 (exp -> factor empty .)
    YELLOW          reduce using rule 83 (exp -> factor empty .)
    BLUE            reduce using rule 83 (exp -> factor empty .)
    GREEN           reduce using rule 83 (exp -> factor empty .)
    BLACK           reduce using rule 83 (exp -> factor empty .)
    WHITE           reduce using rule 83 (exp -> factor empty .)
    ORANGE          reduce using rule 83 (exp -> factor empty .)
    PURPLE          reduce using rule 83 (exp -> factor empty .)
    CYAN            reduce using rule 83 (exp -> factor empty .)
    ]               reduce using rule 83 (exp -> factor empty .)


state 72

    (79) exp -> exp + . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 101
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 73

    (81) exp -> exp * . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 102
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 74

    (80) exp -> exp - . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 103
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 75

    (82) exp -> exp / . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 104
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 76

    (61) command -> figure exp exp . color ;
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp
    (94) color -> . RED
    (95) color -> . YELLOW
    (96) color -> . BLUE
    (97) color -> . GREEN
    (98) color -> . BLACK
    (99) color -> . WHITE
    (100) color -> . ORANGE
    (101) color -> . PURPLE
    (102) color -> . CYAN

    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    RED             shift and go to state 114
    YELLOW          shift and go to state 109
    BLUE            shift and go to state 105
    GREEN           shift and go to state 108
    BLACK           shift and go to state 112
    WHITE           shift and go to state 113
    ORANGE          shift and go to state 111
    PURPLE          shift and go to state 107
    CYAN            shift and go to state 110

    color                          shift and go to state 106

state 77

    (65) cycle -> WHILE gotoW ( . expression ) gotoFalse block continueGoW
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 54
    factor                         shift and go to state 41
    expression                     shift and go to state 115
    id                             shift and go to state 39

state 78

    (66) repeat -> REPLAY CTE_INTEGER gotoR . [ repeatA ] ;

    [               shift and go to state 116


state 79

    (49) assign -> id = expression . ;

    ;               shift and go to state 117


state 80

    (33) calling -> # callID ( . insertEra callingA
    (35) insertEra -> .

    )               reduce using rule 35 (insertEra -> .)
    (               reduce using rule 35 (insertEra -> .)
    CTE_INTEGER     reduce using rule 35 (insertEra -> .)
    CTE_FLOAT       reduce using rule 35 (insertEra -> .)
    TRUE            reduce using rule 35 (insertEra -> .)
    FALSE           reduce using rule 35 (insertEra -> .)
    ID              reduce using rule 35 (insertEra -> .)

    insertEra                      shift and go to state 118

state 81

    (50) condition -> IF ( expression . ) gotoFalse block conditionA continueGo

    )               shift and go to state 119


state 82

    (53) write -> ECHO writeA ; .

    IF              reduce using rule 53 (write -> ECHO writeA ; .)
    ECHO            reduce using rule 53 (write -> ECHO writeA ; .)
    WHILE           reduce using rule 53 (write -> ECHO writeA ; .)
    REPLAY          reduce using rule 53 (write -> ECHO writeA ; .)
    SAMPLE          reduce using rule 53 (write -> ECHO writeA ; .)
    #               reduce using rule 53 (write -> ECHO writeA ; .)
    ARR             reduce using rule 53 (write -> ECHO writeA ; .)
    MAT             reduce using rule 53 (write -> ECHO writeA ; .)
    WHERE           reduce using rule 53 (write -> ECHO writeA ; .)
    CLEAR           reduce using rule 53 (write -> ECHO writeA ; .)
    ID              reduce using rule 53 (write -> ECHO writeA ; .)
    OVAL            reduce using rule 53 (write -> ECHO writeA ; .)
    TRIO            reduce using rule 53 (write -> ECHO writeA ; .)
    QUAD            reduce using rule 53 (write -> ECHO writeA ; .)
    ARC             reduce using rule 53 (write -> ECHO writeA ; .)
    }               reduce using rule 53 (write -> ECHO writeA ; .)
    MOD             reduce using rule 53 (write -> ECHO writeA ; .)
    END             reduce using rule 53 (write -> ECHO writeA ; .)


state 83

    (76) expression -> exp AND . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 120
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 84

    (71) expression -> exp < . > exp
    (72) expression -> exp < . = exp
    (75) expression -> exp < . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    >               shift and go to state 122
    =               shift and go to state 121
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 123
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 85

    (70) expression -> exp = . = exp

    =               shift and go to state 124


state 86

    (77) expression -> exp OR . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 125
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 87

    (78) expression -> exp empty .

    ;               reduce using rule 78 (expression -> exp empty .)
    )               reduce using rule 78 (expression -> exp empty .)
    ,               reduce using rule 78 (expression -> exp empty .)


state 88

    (73) expression -> exp > . = exp
    (74) expression -> exp > . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    =               shift and go to state 126
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 127
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 89

    (93) move -> RIGHT .

    (               reduce using rule 93 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 93 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 93 (move -> RIGHT .)
    TRUE            reduce using rule 93 (move -> RIGHT .)
    FALSE           reduce using rule 93 (move -> RIGHT .)
    ID              reduce using rule 93 (move -> RIGHT .)


state 90

    (64) commandA -> OFF move . exp ;
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 128
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 91

    (90) move -> UP .

    (               reduce using rule 90 (move -> UP .)
    CTE_INTEGER     reduce using rule 90 (move -> UP .)
    CTE_FLOAT       reduce using rule 90 (move -> UP .)
    TRUE            reduce using rule 90 (move -> UP .)
    FALSE           reduce using rule 90 (move -> UP .)
    ID              reduce using rule 90 (move -> UP .)


state 92

    (91) move -> DOWN .

    (               reduce using rule 91 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 91 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 91 (move -> DOWN .)
    TRUE            reduce using rule 91 (move -> DOWN .)
    FALSE           reduce using rule 91 (move -> DOWN .)
    ID              reduce using rule 91 (move -> DOWN .)


state 93

    (92) move -> LEFT .

    (               reduce using rule 92 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 92 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 92 (move -> LEFT .)
    TRUE            reduce using rule 92 (move -> LEFT .)
    FALSE           reduce using rule 92 (move -> LEFT .)
    ID              reduce using rule 92 (move -> LEFT .)


state 94

    (63) commandA -> ON move . exp CTE_INTEGER color ;
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 129
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 95

    (29) id -> ID [ sumdim . exp ] [ sumdim exp ]
    (30) id -> ID [ sumdim . exp ]
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 130
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 96

    (56) array -> ARR typeDim ID . [ CTE_INTEGER ] ;

    [               shift and go to state 131


state 97

    (57) matrix -> MAT typeDim ID . [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    [               shift and go to state 132


state 98

    (22) moduleID -> ID .

    (               reduce using rule 22 (moduleID -> ID .)
    {               reduce using rule 22 (moduleID -> ID .)


state 99

    (19) module -> MOD # moduleID . insertQuadMod moduleA endMod
    (116) insertQuadMod -> .

    (               reduce using rule 116 (insertQuadMod -> .)
    {               reduce using rule 116 (insertQuadMod -> .)

    insertQuadMod                  shift and go to state 133

state 100

    (84) factor -> ( expression ) .

    =               reduce using rule 84 (factor -> ( expression ) .)
    <               reduce using rule 84 (factor -> ( expression ) .)
    >               reduce using rule 84 (factor -> ( expression ) .)
    AND             reduce using rule 84 (factor -> ( expression ) .)
    OR              reduce using rule 84 (factor -> ( expression ) .)
    +               reduce using rule 84 (factor -> ( expression ) .)
    -               reduce using rule 84 (factor -> ( expression ) .)
    *               reduce using rule 84 (factor -> ( expression ) .)
    /               reduce using rule 84 (factor -> ( expression ) .)
    ;               reduce using rule 84 (factor -> ( expression ) .)
    )               reduce using rule 84 (factor -> ( expression ) .)
    ,               reduce using rule 84 (factor -> ( expression ) .)
    ]               reduce using rule 84 (factor -> ( expression ) .)
    (               reduce using rule 84 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 84 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 84 (factor -> ( expression ) .)
    TRUE            reduce using rule 84 (factor -> ( expression ) .)
    FALSE           reduce using rule 84 (factor -> ( expression ) .)
    ID              reduce using rule 84 (factor -> ( expression ) .)
    RED             reduce using rule 84 (factor -> ( expression ) .)
    YELLOW          reduce using rule 84 (factor -> ( expression ) .)
    BLUE            reduce using rule 84 (factor -> ( expression ) .)
    GREEN           reduce using rule 84 (factor -> ( expression ) .)
    BLACK           reduce using rule 84 (factor -> ( expression ) .)
    WHITE           reduce using rule 84 (factor -> ( expression ) .)
    ORANGE          reduce using rule 84 (factor -> ( expression ) .)
    PURPLE          reduce using rule 84 (factor -> ( expression ) .)
    CYAN            reduce using rule 84 (factor -> ( expression ) .)


state 101

    (79) exp -> exp + exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    +               reduce using rule 79 (exp -> exp + exp .)
    -               reduce using rule 79 (exp -> exp + exp .)
    (               reduce using rule 79 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 79 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 79 (exp -> exp + exp .)
    TRUE            reduce using rule 79 (exp -> exp + exp .)
    FALSE           reduce using rule 79 (exp -> exp + exp .)
    ID              reduce using rule 79 (exp -> exp + exp .)
    =               reduce using rule 79 (exp -> exp + exp .)
    <               reduce using rule 79 (exp -> exp + exp .)
    >               reduce using rule 79 (exp -> exp + exp .)
    AND             reduce using rule 79 (exp -> exp + exp .)
    OR              reduce using rule 79 (exp -> exp + exp .)
    )               reduce using rule 79 (exp -> exp + exp .)
    ;               reduce using rule 79 (exp -> exp + exp .)
    ,               reduce using rule 79 (exp -> exp + exp .)
    RED             reduce using rule 79 (exp -> exp + exp .)
    YELLOW          reduce using rule 79 (exp -> exp + exp .)
    BLUE            reduce using rule 79 (exp -> exp + exp .)
    GREEN           reduce using rule 79 (exp -> exp + exp .)
    BLACK           reduce using rule 79 (exp -> exp + exp .)
    WHITE           reduce using rule 79 (exp -> exp + exp .)
    ORANGE          reduce using rule 79 (exp -> exp + exp .)
    PURPLE          reduce using rule 79 (exp -> exp + exp .)
    CYAN            reduce using rule 79 (exp -> exp + exp .)
    ]               reduce using rule 79 (exp -> exp + exp .)
    *               shift and go to state 73
    /               shift and go to state 75

  ! *               [ reduce using rule 79 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 79 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]


state 102

    (81) exp -> exp * exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    +               reduce using rule 81 (exp -> exp * exp .)
    -               reduce using rule 81 (exp -> exp * exp .)
    *               reduce using rule 81 (exp -> exp * exp .)
    /               reduce using rule 81 (exp -> exp * exp .)
    (               reduce using rule 81 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 81 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 81 (exp -> exp * exp .)
    TRUE            reduce using rule 81 (exp -> exp * exp .)
    FALSE           reduce using rule 81 (exp -> exp * exp .)
    ID              reduce using rule 81 (exp -> exp * exp .)
    =               reduce using rule 81 (exp -> exp * exp .)
    <               reduce using rule 81 (exp -> exp * exp .)
    >               reduce using rule 81 (exp -> exp * exp .)
    AND             reduce using rule 81 (exp -> exp * exp .)
    OR              reduce using rule 81 (exp -> exp * exp .)
    )               reduce using rule 81 (exp -> exp * exp .)
    ;               reduce using rule 81 (exp -> exp * exp .)
    ,               reduce using rule 81 (exp -> exp * exp .)
    RED             reduce using rule 81 (exp -> exp * exp .)
    YELLOW          reduce using rule 81 (exp -> exp * exp .)
    BLUE            reduce using rule 81 (exp -> exp * exp .)
    GREEN           reduce using rule 81 (exp -> exp * exp .)
    BLACK           reduce using rule 81 (exp -> exp * exp .)
    WHITE           reduce using rule 81 (exp -> exp * exp .)
    ORANGE          reduce using rule 81 (exp -> exp * exp .)
    PURPLE          reduce using rule 81 (exp -> exp * exp .)
    CYAN            reduce using rule 81 (exp -> exp * exp .)
    ]               reduce using rule 81 (exp -> exp * exp .)

  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]
  ! *               [ shift and go to state 73 ]
  ! /               [ shift and go to state 75 ]


state 103

    (80) exp -> exp - exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    +               reduce using rule 80 (exp -> exp - exp .)
    -               reduce using rule 80 (exp -> exp - exp .)
    (               reduce using rule 80 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 80 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 80 (exp -> exp - exp .)
    TRUE            reduce using rule 80 (exp -> exp - exp .)
    FALSE           reduce using rule 80 (exp -> exp - exp .)
    ID              reduce using rule 80 (exp -> exp - exp .)
    =               reduce using rule 80 (exp -> exp - exp .)
    <               reduce using rule 80 (exp -> exp - exp .)
    >               reduce using rule 80 (exp -> exp - exp .)
    AND             reduce using rule 80 (exp -> exp - exp .)
    OR              reduce using rule 80 (exp -> exp - exp .)
    )               reduce using rule 80 (exp -> exp - exp .)
    ;               reduce using rule 80 (exp -> exp - exp .)
    ,               reduce using rule 80 (exp -> exp - exp .)
    RED             reduce using rule 80 (exp -> exp - exp .)
    YELLOW          reduce using rule 80 (exp -> exp - exp .)
    BLUE            reduce using rule 80 (exp -> exp - exp .)
    GREEN           reduce using rule 80 (exp -> exp - exp .)
    BLACK           reduce using rule 80 (exp -> exp - exp .)
    WHITE           reduce using rule 80 (exp -> exp - exp .)
    ORANGE          reduce using rule 80 (exp -> exp - exp .)
    PURPLE          reduce using rule 80 (exp -> exp - exp .)
    CYAN            reduce using rule 80 (exp -> exp - exp .)
    ]               reduce using rule 80 (exp -> exp - exp .)
    *               shift and go to state 73
    /               shift and go to state 75

  ! *               [ reduce using rule 80 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 80 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]


state 104

    (82) exp -> exp / exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    +               reduce using rule 82 (exp -> exp / exp .)
    -               reduce using rule 82 (exp -> exp / exp .)
    *               reduce using rule 82 (exp -> exp / exp .)
    /               reduce using rule 82 (exp -> exp / exp .)
    (               reduce using rule 82 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 82 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 82 (exp -> exp / exp .)
    TRUE            reduce using rule 82 (exp -> exp / exp .)
    FALSE           reduce using rule 82 (exp -> exp / exp .)
    ID              reduce using rule 82 (exp -> exp / exp .)
    =               reduce using rule 82 (exp -> exp / exp .)
    <               reduce using rule 82 (exp -> exp / exp .)
    >               reduce using rule 82 (exp -> exp / exp .)
    AND             reduce using rule 82 (exp -> exp / exp .)
    OR              reduce using rule 82 (exp -> exp / exp .)
    )               reduce using rule 82 (exp -> exp / exp .)
    ;               reduce using rule 82 (exp -> exp / exp .)
    ,               reduce using rule 82 (exp -> exp / exp .)
    RED             reduce using rule 82 (exp -> exp / exp .)
    YELLOW          reduce using rule 82 (exp -> exp / exp .)
    BLUE            reduce using rule 82 (exp -> exp / exp .)
    GREEN           reduce using rule 82 (exp -> exp / exp .)
    BLACK           reduce using rule 82 (exp -> exp / exp .)
    WHITE           reduce using rule 82 (exp -> exp / exp .)
    ORANGE          reduce using rule 82 (exp -> exp / exp .)
    PURPLE          reduce using rule 82 (exp -> exp / exp .)
    CYAN            reduce using rule 82 (exp -> exp / exp .)
    ]               reduce using rule 82 (exp -> exp / exp .)

  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]
  ! *               [ shift and go to state 73 ]
  ! /               [ shift and go to state 75 ]


state 105

    (96) color -> BLUE .

    ;               reduce using rule 96 (color -> BLUE .)


state 106

    (61) command -> figure exp exp color . ;

    ;               shift and go to state 134


state 107

    (101) color -> PURPLE .

    ;               reduce using rule 101 (color -> PURPLE .)


state 108

    (97) color -> GREEN .

    ;               reduce using rule 97 (color -> GREEN .)


state 109

    (95) color -> YELLOW .

    ;               reduce using rule 95 (color -> YELLOW .)


state 110

    (102) color -> CYAN .

    ;               reduce using rule 102 (color -> CYAN .)


state 111

    (100) color -> ORANGE .

    ;               reduce using rule 100 (color -> ORANGE .)


state 112

    (98) color -> BLACK .

    ;               reduce using rule 98 (color -> BLACK .)


state 113

    (99) color -> WHITE .

    ;               reduce using rule 99 (color -> WHITE .)


state 114

    (94) color -> RED .

    ;               reduce using rule 94 (color -> RED .)


state 115

    (65) cycle -> WHILE gotoW ( expression . ) gotoFalse block continueGoW

    )               shift and go to state 135


state 116

    (66) repeat -> REPLAY CTE_INTEGER gotoR [ . repeatA ] ;
    (67) repeatA -> . command repeatB
    (61) command -> . figure exp exp color ;
    (62) command -> . SAMPLE commandA
    (86) figure -> . OVAL
    (87) figure -> . TRIO
    (88) figure -> . QUAD
    (89) figure -> . ARC

    SAMPLE          shift and go to state 20
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 23
    ARC             shift and go to state 32

    figure                         shift and go to state 3
    repeatA                        shift and go to state 136
    command                        shift and go to state 137

state 117

    (49) assign -> id = expression ; .

    IF              reduce using rule 49 (assign -> id = expression ; .)
    ECHO            reduce using rule 49 (assign -> id = expression ; .)
    WHILE           reduce using rule 49 (assign -> id = expression ; .)
    REPLAY          reduce using rule 49 (assign -> id = expression ; .)
    SAMPLE          reduce using rule 49 (assign -> id = expression ; .)
    #               reduce using rule 49 (assign -> id = expression ; .)
    ARR             reduce using rule 49 (assign -> id = expression ; .)
    MAT             reduce using rule 49 (assign -> id = expression ; .)
    WHERE           reduce using rule 49 (assign -> id = expression ; .)
    CLEAR           reduce using rule 49 (assign -> id = expression ; .)
    ID              reduce using rule 49 (assign -> id = expression ; .)
    OVAL            reduce using rule 49 (assign -> id = expression ; .)
    TRIO            reduce using rule 49 (assign -> id = expression ; .)
    QUAD            reduce using rule 49 (assign -> id = expression ; .)
    ARC             reduce using rule 49 (assign -> id = expression ; .)
    }               reduce using rule 49 (assign -> id = expression ; .)
    MOD             reduce using rule 49 (assign -> id = expression ; .)
    END             reduce using rule 49 (assign -> id = expression ; .)


state 118

    (33) calling -> # callID ( insertEra . callingA
    (36) callingA -> . callingB ) ;
    (37) callingA -> . ) ;
    (38) callingB -> . expression checkParam callingC
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    )               shift and go to state 138
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    factor                         shift and go to state 41
    var_cte                        shift and go to state 37
    callingA                       shift and go to state 139
    callingB                       shift and go to state 140
    exp                            shift and go to state 54
    expression                     shift and go to state 141
    id                             shift and go to state 39

state 119

    (50) condition -> IF ( expression ) . gotoFalse block conditionA continueGo
    (110) gotoFalse -> .

    {               reduce using rule 110 (gotoFalse -> .)

    gotoFalse                      shift and go to state 142

state 120

    (76) expression -> exp AND exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 76 (expression -> exp AND exp .)
    )               reduce using rule 76 (expression -> exp AND exp .)
    ,               reduce using rule 76 (expression -> exp AND exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 121

    (72) expression -> exp < = . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 143
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 122

    (71) expression -> exp < > . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 144
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 123

    (75) expression -> exp < exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 75 (expression -> exp < exp .)
    )               reduce using rule 75 (expression -> exp < exp .)
    ,               reduce using rule 75 (expression -> exp < exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 124

    (70) expression -> exp = = . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 145
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 125

    (77) expression -> exp OR exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 77 (expression -> exp OR exp .)
    )               reduce using rule 77 (expression -> exp OR exp .)
    ,               reduce using rule 77 (expression -> exp OR exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 126

    (73) expression -> exp > = . exp
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 146
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 127

    (74) expression -> exp > exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 74 (expression -> exp > exp .)
    )               reduce using rule 74 (expression -> exp > exp .)
    ,               reduce using rule 74 (expression -> exp > exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 128

    (64) commandA -> OFF move exp . ;
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               shift and go to state 147
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 129

    (63) commandA -> ON move exp . CTE_INTEGER color ;
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 148
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 130

    (29) id -> ID [ sumdim exp . ] [ sumdim exp ]
    (30) id -> ID [ sumdim exp . ]
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ]               shift and go to state 149
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 131

    (56) array -> ARR typeDim ID [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 150


state 132

    (57) matrix -> MAT typeDim ID [ . CTE_INTEGER ] [ CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 151


state 133

    (19) module -> MOD # moduleID insertQuadMod . moduleA endMod
    (20) moduleA -> . ( vars ) block
    (21) moduleA -> . block
    (43) block -> . { blockA

    (               shift and go to state 152
    {               shift and go to state 154

    moduleA                        shift and go to state 155
    block                          shift and go to state 153

state 134

    (61) command -> figure exp exp color ; .

    SAMPLE          reduce using rule 61 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 61 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 61 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 61 (command -> figure exp exp color ; .)
    ARC             reduce using rule 61 (command -> figure exp exp color ; .)
    ]               reduce using rule 61 (command -> figure exp exp color ; .)
    IF              reduce using rule 61 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 61 (command -> figure exp exp color ; .)
    WHILE           reduce using rule 61 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 61 (command -> figure exp exp color ; .)
    #               reduce using rule 61 (command -> figure exp exp color ; .)
    ARR             reduce using rule 61 (command -> figure exp exp color ; .)
    MAT             reduce using rule 61 (command -> figure exp exp color ; .)
    WHERE           reduce using rule 61 (command -> figure exp exp color ; .)
    CLEAR           reduce using rule 61 (command -> figure exp exp color ; .)
    ID              reduce using rule 61 (command -> figure exp exp color ; .)
    }               reduce using rule 61 (command -> figure exp exp color ; .)
    MOD             reduce using rule 61 (command -> figure exp exp color ; .)
    END             reduce using rule 61 (command -> figure exp exp color ; .)


state 135

    (65) cycle -> WHILE gotoW ( expression ) . gotoFalse block continueGoW
    (110) gotoFalse -> .

    {               reduce using rule 110 (gotoFalse -> .)

    gotoFalse                      shift and go to state 156

state 136

    (66) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA . ] ;

    ]               shift and go to state 157


state 137

    (67) repeatA -> command . repeatB
    (68) repeatB -> . repeatA
    (69) repeatB -> . empty
    (67) repeatA -> . command repeatB
    (118) empty -> .
    (61) command -> . figure exp exp color ;
    (62) command -> . SAMPLE commandA
    (86) figure -> . OVAL
    (87) figure -> . TRIO
    (88) figure -> . QUAD
    (89) figure -> . ARC

    ]               reduce using rule 118 (empty -> .)
    SAMPLE          shift and go to state 20
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 23
    ARC             shift and go to state 32

    figure                         shift and go to state 3
    repeatA                        shift and go to state 158
    repeatB                        shift and go to state 159
    command                        shift and go to state 137
    empty                          shift and go to state 160

state 138

    (37) callingA -> ) . ;

    ;               shift and go to state 161


state 139

    (33) calling -> # callID ( insertEra callingA .

    MOD             reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    IF              reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    ECHO            reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    WHILE           reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    REPLAY          reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    SAMPLE          reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    #               reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    ARR             reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    MAT             reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    WHERE           reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    CLEAR           reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    ID              reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    OVAL            reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    TRIO            reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    QUAD            reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    ARC             reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    END             reduce using rule 33 (calling -> # callID ( insertEra callingA .)
    }               reduce using rule 33 (calling -> # callID ( insertEra callingA .)


state 140

    (36) callingA -> callingB . ) ;

    )               shift and go to state 162


state 141

    (38) callingB -> expression . checkParam callingC
    (39) checkParam -> .

    ,               reduce using rule 39 (checkParam -> .)
    )               reduce using rule 39 (checkParam -> .)

    checkParam                     shift and go to state 163

state 142

    (50) condition -> IF ( expression ) gotoFalse . block conditionA continueGo
    (43) block -> . { blockA

    {               shift and go to state 154

    block                          shift and go to state 164

state 143

    (72) expression -> exp < = exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 72 (expression -> exp < = exp .)
    )               reduce using rule 72 (expression -> exp < = exp .)
    ,               reduce using rule 72 (expression -> exp < = exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 144

    (71) expression -> exp < > exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 71 (expression -> exp < > exp .)
    )               reduce using rule 71 (expression -> exp < > exp .)
    ,               reduce using rule 71 (expression -> exp < > exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 145

    (70) expression -> exp = = exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 70 (expression -> exp = = exp .)
    )               reduce using rule 70 (expression -> exp = = exp .)
    ,               reduce using rule 70 (expression -> exp = = exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 146

    (73) expression -> exp > = exp .
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ;               reduce using rule 73 (expression -> exp > = exp .)
    )               reduce using rule 73 (expression -> exp > = exp .)
    ,               reduce using rule 73 (expression -> exp > = exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 147

    (64) commandA -> OFF move exp ; .

    MOD             reduce using rule 64 (commandA -> OFF move exp ; .)
    IF              reduce using rule 64 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 64 (commandA -> OFF move exp ; .)
    WHILE           reduce using rule 64 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 64 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 64 (commandA -> OFF move exp ; .)
    #               reduce using rule 64 (commandA -> OFF move exp ; .)
    ARR             reduce using rule 64 (commandA -> OFF move exp ; .)
    MAT             reduce using rule 64 (commandA -> OFF move exp ; .)
    WHERE           reduce using rule 64 (commandA -> OFF move exp ; .)
    CLEAR           reduce using rule 64 (commandA -> OFF move exp ; .)
    ID              reduce using rule 64 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 64 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 64 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 64 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 64 (commandA -> OFF move exp ; .)
    END             reduce using rule 64 (commandA -> OFF move exp ; .)
    ]               reduce using rule 64 (commandA -> OFF move exp ; .)
    }               reduce using rule 64 (commandA -> OFF move exp ; .)


state 148

    (63) commandA -> ON move exp CTE_INTEGER . color ;
    (94) color -> . RED
    (95) color -> . YELLOW
    (96) color -> . BLUE
    (97) color -> . GREEN
    (98) color -> . BLACK
    (99) color -> . WHITE
    (100) color -> . ORANGE
    (101) color -> . PURPLE
    (102) color -> . CYAN

    RED             shift and go to state 114
    YELLOW          shift and go to state 109
    BLUE            shift and go to state 105
    GREEN           shift and go to state 108
    BLACK           shift and go to state 112
    WHITE           shift and go to state 113
    ORANGE          shift and go to state 111
    PURPLE          shift and go to state 107
    CYAN            shift and go to state 110

    color                          shift and go to state 165

state 149

    (29) id -> ID [ sumdim exp ] . [ sumdim exp ]
    (30) id -> ID [ sumdim exp ] .

    [               shift and go to state 166
    +               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    -               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    *               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    /               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    ;               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    )               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    ,               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    (               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 30 (id -> ID [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 30 (id -> ID [ sumdim exp ] .)
    TRUE            reduce using rule 30 (id -> ID [ sumdim exp ] .)
    FALSE           reduce using rule 30 (id -> ID [ sumdim exp ] .)
    ID              reduce using rule 30 (id -> ID [ sumdim exp ] .)
    =               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    <               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    >               reduce using rule 30 (id -> ID [ sumdim exp ] .)
    AND             reduce using rule 30 (id -> ID [ sumdim exp ] .)
    OR              reduce using rule 30 (id -> ID [ sumdim exp ] .)
    RED             reduce using rule 30 (id -> ID [ sumdim exp ] .)
    YELLOW          reduce using rule 30 (id -> ID [ sumdim exp ] .)
    BLUE            reduce using rule 30 (id -> ID [ sumdim exp ] .)
    GREEN           reduce using rule 30 (id -> ID [ sumdim exp ] .)
    BLACK           reduce using rule 30 (id -> ID [ sumdim exp ] .)
    WHITE           reduce using rule 30 (id -> ID [ sumdim exp ] .)
    ORANGE          reduce using rule 30 (id -> ID [ sumdim exp ] .)
    PURPLE          reduce using rule 30 (id -> ID [ sumdim exp ] .)
    CYAN            reduce using rule 30 (id -> ID [ sumdim exp ] .)
    ]               reduce using rule 30 (id -> ID [ sumdim exp ] .)


state 150

    (56) array -> ARR typeDim ID [ CTE_INTEGER . ] ;

    ]               shift and go to state 167


state 151

    (57) matrix -> MAT typeDim ID [ CTE_INTEGER . ] [ CTE_INTEGER ] ;

    ]               shift and go to state 168


state 152

    (20) moduleA -> ( . vars ) block
    (23) vars -> . type ID varsA
    (26) type -> . INT
    (27) type -> . FLOAT
    (28) type -> . BOOL

    INT             shift and go to state 171
    FLOAT           shift and go to state 170
    BOOL            shift and go to state 172

    type                           shift and go to state 173
    vars                           shift and go to state 169

state 153

    (21) moduleA -> block .

    MOD             reduce using rule 21 (moduleA -> block .)
    IF              reduce using rule 21 (moduleA -> block .)
    ECHO            reduce using rule 21 (moduleA -> block .)
    WHILE           reduce using rule 21 (moduleA -> block .)
    REPLAY          reduce using rule 21 (moduleA -> block .)
    SAMPLE          reduce using rule 21 (moduleA -> block .)
    #               reduce using rule 21 (moduleA -> block .)
    ARR             reduce using rule 21 (moduleA -> block .)
    MAT             reduce using rule 21 (moduleA -> block .)
    WHERE           reduce using rule 21 (moduleA -> block .)
    CLEAR           reduce using rule 21 (moduleA -> block .)
    ID              reduce using rule 21 (moduleA -> block .)
    OVAL            reduce using rule 21 (moduleA -> block .)
    TRIO            reduce using rule 21 (moduleA -> block .)
    QUAD            reduce using rule 21 (moduleA -> block .)
    ARC             reduce using rule 21 (moduleA -> block .)
    END             reduce using rule 21 (moduleA -> block .)


state 154

    (43) block -> { . blockA
    (44) blockA -> . blockB }
    (45) blockA -> . }
    (46) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . screen
    (49) assign -> . id = expression ;
    (50) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (53) write -> . ECHO writeA ;
    (65) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (66) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (61) command -> . figure exp exp color ;
    (62) command -> . SAMPLE commandA
    (33) calling -> . # callID ( insertEra callingA
    (56) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (57) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (103) screen -> . WHERE
    (104) screen -> . CLEAR
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID
    (86) figure -> . OVAL
    (87) figure -> . TRIO
    (88) figure -> . QUAD
    (89) figure -> . ARC

    }               shift and go to state 175
    IF              shift and go to state 13
    ECHO            shift and go to state 19
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 20
    #               shift and go to state 10
    ARR             shift and go to state 28
    MAT             shift and go to state 29
    WHERE           shift and go to state 31
    CLEAR           shift and go to state 14
    ID              shift and go to state 24
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 23
    ARC             shift and go to state 32

    figure                         shift and go to state 3
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    command                        shift and go to state 33
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    condition                      shift and go to state 25
    cycle                          shift and go to state 26
    statute                        shift and go to state 174
    calling                        shift and go to state 30
    blockB                         shift and go to state 176
    blockA                         shift and go to state 177
    assign                         shift and go to state 36

state 155

    (19) module -> MOD # moduleID insertQuadMod moduleA . endMod
    (117) endMod -> .

    MOD             reduce using rule 117 (endMod -> .)
    IF              reduce using rule 117 (endMod -> .)
    ECHO            reduce using rule 117 (endMod -> .)
    WHILE           reduce using rule 117 (endMod -> .)
    REPLAY          reduce using rule 117 (endMod -> .)
    SAMPLE          reduce using rule 117 (endMod -> .)
    #               reduce using rule 117 (endMod -> .)
    ARR             reduce using rule 117 (endMod -> .)
    MAT             reduce using rule 117 (endMod -> .)
    WHERE           reduce using rule 117 (endMod -> .)
    CLEAR           reduce using rule 117 (endMod -> .)
    ID              reduce using rule 117 (endMod -> .)
    OVAL            reduce using rule 117 (endMod -> .)
    TRIO            reduce using rule 117 (endMod -> .)
    QUAD            reduce using rule 117 (endMod -> .)
    ARC             reduce using rule 117 (endMod -> .)
    END             reduce using rule 117 (endMod -> .)

    endMod                         shift and go to state 178

state 156

    (65) cycle -> WHILE gotoW ( expression ) gotoFalse . block continueGoW
    (43) block -> . { blockA

    {               shift and go to state 154

    block                          shift and go to state 179

state 157

    (66) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] . ;

    ;               shift and go to state 180


state 158

    (68) repeatB -> repeatA .

    ]               reduce using rule 68 (repeatB -> repeatA .)


state 159

    (67) repeatA -> command repeatB .

    ]               reduce using rule 67 (repeatA -> command repeatB .)


state 160

    (69) repeatB -> empty .

    ]               reduce using rule 69 (repeatB -> empty .)


state 161

    (37) callingA -> ) ; .

    MOD             reduce using rule 37 (callingA -> ) ; .)
    IF              reduce using rule 37 (callingA -> ) ; .)
    ECHO            reduce using rule 37 (callingA -> ) ; .)
    WHILE           reduce using rule 37 (callingA -> ) ; .)
    REPLAY          reduce using rule 37 (callingA -> ) ; .)
    SAMPLE          reduce using rule 37 (callingA -> ) ; .)
    #               reduce using rule 37 (callingA -> ) ; .)
    ARR             reduce using rule 37 (callingA -> ) ; .)
    MAT             reduce using rule 37 (callingA -> ) ; .)
    WHERE           reduce using rule 37 (callingA -> ) ; .)
    CLEAR           reduce using rule 37 (callingA -> ) ; .)
    ID              reduce using rule 37 (callingA -> ) ; .)
    OVAL            reduce using rule 37 (callingA -> ) ; .)
    TRIO            reduce using rule 37 (callingA -> ) ; .)
    QUAD            reduce using rule 37 (callingA -> ) ; .)
    ARC             reduce using rule 37 (callingA -> ) ; .)
    END             reduce using rule 37 (callingA -> ) ; .)
    }               reduce using rule 37 (callingA -> ) ; .)


state 162

    (36) callingA -> callingB ) . ;

    ;               shift and go to state 181


state 163

    (38) callingB -> expression checkParam . callingC
    (40) callingC -> . , sumXparam callingB
    (41) callingC -> . empty
    (118) empty -> .

    ,               shift and go to state 182
    )               reduce using rule 118 (empty -> .)

    callingC                       shift and go to state 183
    empty                          shift and go to state 184

state 164

    (50) condition -> IF ( expression ) gotoFalse block . conditionA continueGo
    (51) conditionA -> . ELSE gotoE block
    (52) conditionA -> . empty
    (118) empty -> .

    ELSE            shift and go to state 187
    MOD             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ECHO            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    REPLAY          reduce using rule 118 (empty -> .)
    SAMPLE          reduce using rule 118 (empty -> .)
    #               reduce using rule 118 (empty -> .)
    ARR             reduce using rule 118 (empty -> .)
    MAT             reduce using rule 118 (empty -> .)
    WHERE           reduce using rule 118 (empty -> .)
    CLEAR           reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    OVAL            reduce using rule 118 (empty -> .)
    TRIO            reduce using rule 118 (empty -> .)
    QUAD            reduce using rule 118 (empty -> .)
    ARC             reduce using rule 118 (empty -> .)
    END             reduce using rule 118 (empty -> .)
    }               reduce using rule 118 (empty -> .)

    conditionA                     shift and go to state 185
    empty                          shift and go to state 186

state 165

    (63) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 188


state 166

    (29) id -> ID [ sumdim exp ] [ . sumdim exp ]
    (32) sumdim -> .

    (               reduce using rule 32 (sumdim -> .)
    CTE_INTEGER     reduce using rule 32 (sumdim -> .)
    CTE_FLOAT       reduce using rule 32 (sumdim -> .)
    TRUE            reduce using rule 32 (sumdim -> .)
    FALSE           reduce using rule 32 (sumdim -> .)
    ID              reduce using rule 32 (sumdim -> .)

    sumdim                         shift and go to state 189

state 167

    (56) array -> ARR typeDim ID [ CTE_INTEGER ] . ;

    ;               shift and go to state 190


state 168

    (57) matrix -> MAT typeDim ID [ CTE_INTEGER ] . [ CTE_INTEGER ] ;

    [               shift and go to state 191


state 169

    (20) moduleA -> ( vars . ) block

    )               shift and go to state 192


state 170

    (27) type -> FLOAT .

    ID              reduce using rule 27 (type -> FLOAT .)


state 171

    (26) type -> INT .

    ID              reduce using rule 26 (type -> INT .)


state 172

    (28) type -> BOOL .

    ID              reduce using rule 28 (type -> BOOL .)


state 173

    (23) vars -> type . ID varsA

    ID              shift and go to state 193


state 174

    (46) blockB -> statute . blockC
    (47) blockC -> . blockB
    (48) blockC -> . empty
    (46) blockB -> . statute blockC
    (118) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . screen
    (49) assign -> . id = expression ;
    (50) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (53) write -> . ECHO writeA ;
    (65) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (66) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (61) command -> . figure exp exp color ;
    (62) command -> . SAMPLE commandA
    (33) calling -> . # callID ( insertEra callingA
    (56) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (57) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (103) screen -> . WHERE
    (104) screen -> . CLEAR
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID
    (86) figure -> . OVAL
    (87) figure -> . TRIO
    (88) figure -> . QUAD
    (89) figure -> . ARC

    }               reduce using rule 118 (empty -> .)
    IF              shift and go to state 13
    ECHO            shift and go to state 19
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 20
    #               shift and go to state 10
    ARR             shift and go to state 28
    MAT             shift and go to state 29
    WHERE           shift and go to state 31
    CLEAR           shift and go to state 14
    ID              shift and go to state 24
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 23
    ARC             shift and go to state 32

    figure                         shift and go to state 3
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    command                        shift and go to state 33
    empty                          shift and go to state 194
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    condition                      shift and go to state 25
    cycle                          shift and go to state 26
    statute                        shift and go to state 174
    calling                        shift and go to state 30
    blockC                         shift and go to state 195
    blockB                         shift and go to state 196
    assign                         shift and go to state 36

state 175

    (45) blockA -> } .

    MOD             reduce using rule 45 (blockA -> } .)
    IF              reduce using rule 45 (blockA -> } .)
    ECHO            reduce using rule 45 (blockA -> } .)
    WHILE           reduce using rule 45 (blockA -> } .)
    REPLAY          reduce using rule 45 (blockA -> } .)
    SAMPLE          reduce using rule 45 (blockA -> } .)
    #               reduce using rule 45 (blockA -> } .)
    ARR             reduce using rule 45 (blockA -> } .)
    MAT             reduce using rule 45 (blockA -> } .)
    WHERE           reduce using rule 45 (blockA -> } .)
    CLEAR           reduce using rule 45 (blockA -> } .)
    ID              reduce using rule 45 (blockA -> } .)
    OVAL            reduce using rule 45 (blockA -> } .)
    TRIO            reduce using rule 45 (blockA -> } .)
    QUAD            reduce using rule 45 (blockA -> } .)
    ARC             reduce using rule 45 (blockA -> } .)
    END             reduce using rule 45 (blockA -> } .)
    ELSE            reduce using rule 45 (blockA -> } .)
    }               reduce using rule 45 (blockA -> } .)


state 176

    (44) blockA -> blockB . }

    }               shift and go to state 197


state 177

    (43) block -> { blockA .

    MOD             reduce using rule 43 (block -> { blockA .)
    IF              reduce using rule 43 (block -> { blockA .)
    ECHO            reduce using rule 43 (block -> { blockA .)
    WHILE           reduce using rule 43 (block -> { blockA .)
    REPLAY          reduce using rule 43 (block -> { blockA .)
    SAMPLE          reduce using rule 43 (block -> { blockA .)
    #               reduce using rule 43 (block -> { blockA .)
    ARR             reduce using rule 43 (block -> { blockA .)
    MAT             reduce using rule 43 (block -> { blockA .)
    WHERE           reduce using rule 43 (block -> { blockA .)
    CLEAR           reduce using rule 43 (block -> { blockA .)
    ID              reduce using rule 43 (block -> { blockA .)
    OVAL            reduce using rule 43 (block -> { blockA .)
    TRIO            reduce using rule 43 (block -> { blockA .)
    QUAD            reduce using rule 43 (block -> { blockA .)
    ARC             reduce using rule 43 (block -> { blockA .)
    END             reduce using rule 43 (block -> { blockA .)
    }               reduce using rule 43 (block -> { blockA .)
    ELSE            reduce using rule 43 (block -> { blockA .)


state 178

    (19) module -> MOD # moduleID insertQuadMod moduleA endMod .

    MOD             reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    IF              reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ECHO            reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    WHILE           reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    REPLAY          reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    SAMPLE          reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    #               reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ARR             reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    MAT             reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    WHERE           reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    CLEAR           reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ID              reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    OVAL            reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    TRIO            reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    QUAD            reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ARC             reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    END             reduce using rule 19 (module -> MOD # moduleID insertQuadMod moduleA endMod .)


state 179

    (65) cycle -> WHILE gotoW ( expression ) gotoFalse block . continueGoW
    (115) continueGoW -> .

    MOD             reduce using rule 115 (continueGoW -> .)
    IF              reduce using rule 115 (continueGoW -> .)
    ECHO            reduce using rule 115 (continueGoW -> .)
    WHILE           reduce using rule 115 (continueGoW -> .)
    REPLAY          reduce using rule 115 (continueGoW -> .)
    SAMPLE          reduce using rule 115 (continueGoW -> .)
    #               reduce using rule 115 (continueGoW -> .)
    ARR             reduce using rule 115 (continueGoW -> .)
    MAT             reduce using rule 115 (continueGoW -> .)
    WHERE           reduce using rule 115 (continueGoW -> .)
    CLEAR           reduce using rule 115 (continueGoW -> .)
    ID              reduce using rule 115 (continueGoW -> .)
    OVAL            reduce using rule 115 (continueGoW -> .)
    TRIO            reduce using rule 115 (continueGoW -> .)
    QUAD            reduce using rule 115 (continueGoW -> .)
    ARC             reduce using rule 115 (continueGoW -> .)
    END             reduce using rule 115 (continueGoW -> .)
    }               reduce using rule 115 (continueGoW -> .)

    continueGoW                    shift and go to state 198

state 180

    (66) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .

    MOD             reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    IF              reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ECHO            reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHILE           reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    REPLAY          reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    SAMPLE          reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    #               reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARR             reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MAT             reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHERE           reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    CLEAR           reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ID              reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    OVAL            reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    TRIO            reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    QUAD            reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARC             reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    END             reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    }               reduce using rule 66 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)


state 181

    (36) callingA -> callingB ) ; .

    MOD             reduce using rule 36 (callingA -> callingB ) ; .)
    IF              reduce using rule 36 (callingA -> callingB ) ; .)
    ECHO            reduce using rule 36 (callingA -> callingB ) ; .)
    WHILE           reduce using rule 36 (callingA -> callingB ) ; .)
    REPLAY          reduce using rule 36 (callingA -> callingB ) ; .)
    SAMPLE          reduce using rule 36 (callingA -> callingB ) ; .)
    #               reduce using rule 36 (callingA -> callingB ) ; .)
    ARR             reduce using rule 36 (callingA -> callingB ) ; .)
    MAT             reduce using rule 36 (callingA -> callingB ) ; .)
    WHERE           reduce using rule 36 (callingA -> callingB ) ; .)
    CLEAR           reduce using rule 36 (callingA -> callingB ) ; .)
    ID              reduce using rule 36 (callingA -> callingB ) ; .)
    OVAL            reduce using rule 36 (callingA -> callingB ) ; .)
    TRIO            reduce using rule 36 (callingA -> callingB ) ; .)
    QUAD            reduce using rule 36 (callingA -> callingB ) ; .)
    ARC             reduce using rule 36 (callingA -> callingB ) ; .)
    END             reduce using rule 36 (callingA -> callingB ) ; .)
    }               reduce using rule 36 (callingA -> callingB ) ; .)


state 182

    (40) callingC -> , . sumXparam callingB
    (42) sumXparam -> .

    (               reduce using rule 42 (sumXparam -> .)
    CTE_INTEGER     reduce using rule 42 (sumXparam -> .)
    CTE_FLOAT       reduce using rule 42 (sumXparam -> .)
    TRUE            reduce using rule 42 (sumXparam -> .)
    FALSE           reduce using rule 42 (sumXparam -> .)
    ID              reduce using rule 42 (sumXparam -> .)

    sumXparam                      shift and go to state 199

state 183

    (38) callingB -> expression checkParam callingC .

    )               reduce using rule 38 (callingB -> expression checkParam callingC .)


state 184

    (41) callingC -> empty .

    )               reduce using rule 41 (callingC -> empty .)


state 185

    (50) condition -> IF ( expression ) gotoFalse block conditionA . continueGo
    (114) continueGo -> .

    MOD             reduce using rule 114 (continueGo -> .)
    IF              reduce using rule 114 (continueGo -> .)
    ECHO            reduce using rule 114 (continueGo -> .)
    WHILE           reduce using rule 114 (continueGo -> .)
    REPLAY          reduce using rule 114 (continueGo -> .)
    SAMPLE          reduce using rule 114 (continueGo -> .)
    #               reduce using rule 114 (continueGo -> .)
    ARR             reduce using rule 114 (continueGo -> .)
    MAT             reduce using rule 114 (continueGo -> .)
    WHERE           reduce using rule 114 (continueGo -> .)
    CLEAR           reduce using rule 114 (continueGo -> .)
    ID              reduce using rule 114 (continueGo -> .)
    OVAL            reduce using rule 114 (continueGo -> .)
    TRIO            reduce using rule 114 (continueGo -> .)
    QUAD            reduce using rule 114 (continueGo -> .)
    ARC             reduce using rule 114 (continueGo -> .)
    END             reduce using rule 114 (continueGo -> .)
    }               reduce using rule 114 (continueGo -> .)

    continueGo                     shift and go to state 200

state 186

    (52) conditionA -> empty .

    MOD             reduce using rule 52 (conditionA -> empty .)
    IF              reduce using rule 52 (conditionA -> empty .)
    ECHO            reduce using rule 52 (conditionA -> empty .)
    WHILE           reduce using rule 52 (conditionA -> empty .)
    REPLAY          reduce using rule 52 (conditionA -> empty .)
    SAMPLE          reduce using rule 52 (conditionA -> empty .)
    #               reduce using rule 52 (conditionA -> empty .)
    ARR             reduce using rule 52 (conditionA -> empty .)
    MAT             reduce using rule 52 (conditionA -> empty .)
    WHERE           reduce using rule 52 (conditionA -> empty .)
    CLEAR           reduce using rule 52 (conditionA -> empty .)
    ID              reduce using rule 52 (conditionA -> empty .)
    OVAL            reduce using rule 52 (conditionA -> empty .)
    TRIO            reduce using rule 52 (conditionA -> empty .)
    QUAD            reduce using rule 52 (conditionA -> empty .)
    ARC             reduce using rule 52 (conditionA -> empty .)
    END             reduce using rule 52 (conditionA -> empty .)
    }               reduce using rule 52 (conditionA -> empty .)


state 187

    (51) conditionA -> ELSE . gotoE block
    (111) gotoE -> .

    {               reduce using rule 111 (gotoE -> .)

    gotoE                          shift and go to state 201

state 188

    (63) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHILE           reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARR             reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    MAT             reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHERE           reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    CLEAR           reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 63 (commandA -> ON move exp CTE_INTEGER color ; .)


state 189

    (29) id -> ID [ sumdim exp ] [ sumdim . exp ]
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    exp                            shift and go to state 202
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 190

    (56) array -> ARR typeDim ID [ CTE_INTEGER ] ; .

    IF              reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    #               reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHERE           reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    CLEAR           reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ID              reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    }               reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    END             reduce using rule 56 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)


state 191

    (57) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 203


state 192

    (20) moduleA -> ( vars ) . block
    (43) block -> . { blockA

    {               shift and go to state 154

    block                          shift and go to state 204

state 193

    (23) vars -> type ID . varsA
    (24) varsA -> . , vars
    (25) varsA -> . empty
    (118) empty -> .

    ,               shift and go to state 206
    )               reduce using rule 118 (empty -> .)

    varsA                          shift and go to state 205
    empty                          shift and go to state 207

state 194

    (48) blockC -> empty .

    }               reduce using rule 48 (blockC -> empty .)


state 195

    (46) blockB -> statute blockC .

    }               reduce using rule 46 (blockB -> statute blockC .)


state 196

    (47) blockC -> blockB .

    }               reduce using rule 47 (blockC -> blockB .)


state 197

    (44) blockA -> blockB } .

    MOD             reduce using rule 44 (blockA -> blockB } .)
    IF              reduce using rule 44 (blockA -> blockB } .)
    ECHO            reduce using rule 44 (blockA -> blockB } .)
    WHILE           reduce using rule 44 (blockA -> blockB } .)
    REPLAY          reduce using rule 44 (blockA -> blockB } .)
    SAMPLE          reduce using rule 44 (blockA -> blockB } .)
    #               reduce using rule 44 (blockA -> blockB } .)
    ARR             reduce using rule 44 (blockA -> blockB } .)
    MAT             reduce using rule 44 (blockA -> blockB } .)
    WHERE           reduce using rule 44 (blockA -> blockB } .)
    CLEAR           reduce using rule 44 (blockA -> blockB } .)
    ID              reduce using rule 44 (blockA -> blockB } .)
    OVAL            reduce using rule 44 (blockA -> blockB } .)
    TRIO            reduce using rule 44 (blockA -> blockB } .)
    QUAD            reduce using rule 44 (blockA -> blockB } .)
    ARC             reduce using rule 44 (blockA -> blockB } .)
    END             reduce using rule 44 (blockA -> blockB } .)
    ELSE            reduce using rule 44 (blockA -> blockB } .)
    }               reduce using rule 44 (blockA -> blockB } .)


state 198

    (65) cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .

    MOD             reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    IF              reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ECHO            reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHILE           reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    REPLAY          reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    SAMPLE          reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    #               reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARR             reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    MAT             reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHERE           reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    CLEAR           reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ID              reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    OVAL            reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    TRIO            reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    QUAD            reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARC             reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    END             reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    }               reduce using rule 65 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)


state 199

    (40) callingC -> , sumXparam . callingB
    (38) callingB -> . expression checkParam callingC
    (70) expression -> . exp = = exp
    (71) expression -> . exp < > exp
    (72) expression -> . exp < = exp
    (73) expression -> . exp > = exp
    (74) expression -> . exp > exp
    (75) expression -> . exp < exp
    (76) expression -> . exp AND exp
    (77) expression -> . exp OR exp
    (78) expression -> . exp empty
    (79) exp -> . exp + exp
    (80) exp -> . exp - exp
    (81) exp -> . exp * exp
    (82) exp -> . exp / exp
    (83) exp -> . factor empty
    (84) factor -> . ( expression )
    (85) factor -> . var_cte
    (105) var_cte -> . id
    (106) var_cte -> . CTE_INTEGER
    (107) var_cte -> . CTE_FLOAT
    (108) var_cte -> . TRUE
    (109) var_cte -> . FALSE
    (29) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (30) id -> . ID [ sumdim exp ]
    (31) id -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 24

    var_cte                        shift and go to state 37
    callingB                       shift and go to state 208
    exp                            shift and go to state 54
    factor                         shift and go to state 41
    expression                     shift and go to state 141
    id                             shift and go to state 39

state 200

    (50) condition -> IF ( expression ) gotoFalse block conditionA continueGo .

    IF              reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ECHO            reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHILE           reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    REPLAY          reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    SAMPLE          reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    #               reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARR             reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MAT             reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHERE           reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    CLEAR           reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ID              reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    OVAL            reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    TRIO            reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    QUAD            reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARC             reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    }               reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MOD             reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    END             reduce using rule 50 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)


state 201

    (51) conditionA -> ELSE gotoE . block
    (43) block -> . { blockA

    {               shift and go to state 154

    block                          shift and go to state 209

state 202

    (29) id -> ID [ sumdim exp ] [ sumdim exp . ]
    (79) exp -> exp . + exp
    (80) exp -> exp . - exp
    (81) exp -> exp . * exp
    (82) exp -> exp . / exp

    ]               shift and go to state 210
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 203

    (57) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER . ] ;

    ]               shift and go to state 211


state 204

    (20) moduleA -> ( vars ) block .

    MOD             reduce using rule 20 (moduleA -> ( vars ) block .)
    IF              reduce using rule 20 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 20 (moduleA -> ( vars ) block .)
    WHILE           reduce using rule 20 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 20 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 20 (moduleA -> ( vars ) block .)
    #               reduce using rule 20 (moduleA -> ( vars ) block .)
    ARR             reduce using rule 20 (moduleA -> ( vars ) block .)
    MAT             reduce using rule 20 (moduleA -> ( vars ) block .)
    WHERE           reduce using rule 20 (moduleA -> ( vars ) block .)
    CLEAR           reduce using rule 20 (moduleA -> ( vars ) block .)
    ID              reduce using rule 20 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 20 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 20 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 20 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 20 (moduleA -> ( vars ) block .)
    END             reduce using rule 20 (moduleA -> ( vars ) block .)


state 205

    (23) vars -> type ID varsA .

    )               reduce using rule 23 (vars -> type ID varsA .)


state 206

    (24) varsA -> , . vars
    (23) vars -> . type ID varsA
    (26) type -> . INT
    (27) type -> . FLOAT
    (28) type -> . BOOL

    INT             shift and go to state 171
    FLOAT           shift and go to state 170
    BOOL            shift and go to state 172

    type                           shift and go to state 173
    vars                           shift and go to state 212

state 207

    (25) varsA -> empty .

    )               reduce using rule 25 (varsA -> empty .)


state 208

    (40) callingC -> , sumXparam callingB .

    )               reduce using rule 40 (callingC -> , sumXparam callingB .)


state 209

    (51) conditionA -> ELSE gotoE block .

    MOD             reduce using rule 51 (conditionA -> ELSE gotoE block .)
    IF              reduce using rule 51 (conditionA -> ELSE gotoE block .)
    ECHO            reduce using rule 51 (conditionA -> ELSE gotoE block .)
    WHILE           reduce using rule 51 (conditionA -> ELSE gotoE block .)
    REPLAY          reduce using rule 51 (conditionA -> ELSE gotoE block .)
    SAMPLE          reduce using rule 51 (conditionA -> ELSE gotoE block .)
    #               reduce using rule 51 (conditionA -> ELSE gotoE block .)
    ARR             reduce using rule 51 (conditionA -> ELSE gotoE block .)
    MAT             reduce using rule 51 (conditionA -> ELSE gotoE block .)
    WHERE           reduce using rule 51 (conditionA -> ELSE gotoE block .)
    CLEAR           reduce using rule 51 (conditionA -> ELSE gotoE block .)
    ID              reduce using rule 51 (conditionA -> ELSE gotoE block .)
    OVAL            reduce using rule 51 (conditionA -> ELSE gotoE block .)
    TRIO            reduce using rule 51 (conditionA -> ELSE gotoE block .)
    QUAD            reduce using rule 51 (conditionA -> ELSE gotoE block .)
    ARC             reduce using rule 51 (conditionA -> ELSE gotoE block .)
    END             reduce using rule 51 (conditionA -> ELSE gotoE block .)
    }               reduce using rule 51 (conditionA -> ELSE gotoE block .)


state 210

    (29) id -> ID [ sumdim exp ] [ sumdim exp ] .

    +               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    -               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    *               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    /               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ;               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    )               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ,               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    (               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    TRUE            reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    FALSE           reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ID              reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    =               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    <               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    >               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    AND             reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    OR              reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    RED             reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    YELLOW          reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    BLUE            reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    GREEN           reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    BLACK           reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    WHITE           reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ORANGE          reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    PURPLE          reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CYAN            reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ]               reduce using rule 29 (id -> ID [ sumdim exp ] [ sumdim exp ] .)


state 211

    (57) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] . ;

    ;               shift and go to state 213


state 212

    (24) varsA -> , vars .

    )               reduce using rule 24 (varsA -> , vars .)


state 213

    (57) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .

    MOD             reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    IF              reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    #               reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHERE           reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    CLEAR           reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ID              reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    END             reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    }               reduce using rule 57 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)

