Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> write
Rule 12    statute -> cycle
Rule 13    statute -> repeat
Rule 14    statute -> command
Rule 15    statute -> calling
Rule 16    statute -> array
Rule 17    statute -> matrix
Rule 18    statute -> pipeline
Rule 19    statute -> screen
Rule 20    module -> MOD # moduleID insertQuadMod moduleA endMod
Rule 21    moduleA -> ( vars ) block
Rule 22    moduleA -> block
Rule 23    moduleID -> ID
Rule 24    vars -> type ID varsA
Rule 25    varsA -> , vars
Rule 26    varsA -> empty
Rule 27    type -> INT
Rule 28    type -> FLOAT
Rule 29    type -> BOOL
Rule 30    calling -> # callID ( insertEra callingA
Rule 31    callID -> ID
Rule 32    insertEra -> <empty>
Rule 33    callingA -> callingB ) ;
Rule 34    callingA -> ) ;
Rule 35    callingB -> expression checkParam callingC
Rule 36    checkParam -> <empty>
Rule 37    callingC -> , sumXparam callingB
Rule 38    callingC -> empty
Rule 39    sumXparam -> <empty>
Rule 40    block -> { blockA
Rule 41    blockA -> blockB }
Rule 42    blockA -> }
Rule 43    blockB -> statute blockC
Rule 44    blockC -> blockB
Rule 45    blockC -> empty
Rule 46    assign -> ID = expression ;
Rule 47    condition -> IF ( expression ) gotoFalse block conditionA continueGo
Rule 48    conditionA -> ELSE gotoE block
Rule 49    conditionA -> empty
Rule 50    write -> ECHO writeA ;
Rule 51    writeA -> expression
Rule 52    writeA -> CTE_STRING
Rule 53    array -> ARR typeDim ID [ CTE_INTEGER ] ;
Rule 54    matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
Rule 55    pipeline -> PIPE ID pipelineA
Rule 56    pipelineA -> [ pipelineB ] ;
Rule 57    pipelineA -> IN ( var_cte ) ;
Rule 58    pipelineA -> OUT ( ) ;
Rule 59    pipelineA -> COUNT ;
Rule 60    pipelineB -> exp pipelineC
Rule 61    pipelineC -> , pipelineB
Rule 62    pipelineC -> empty
Rule 63    typeDim -> INT
Rule 64    typeDim -> FLOAT
Rule 65    typeDim -> BOOL
Rule 66    command -> figure exp exp color ;
Rule 67    command -> SAMPLE commandA
Rule 68    commandA -> ON move exp CTE_INTEGER color ;
Rule 69    commandA -> OFF move exp ;
Rule 70    cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW
Rule 71    repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ;
Rule 72    repeatA -> command repeatB
Rule 73    repeatB -> repeatA
Rule 74    repeatB -> empty
Rule 75    expression -> exp = = exp
Rule 76    expression -> exp < > exp
Rule 77    expression -> exp < = exp
Rule 78    expression -> exp > = exp
Rule 79    expression -> exp > exp
Rule 80    expression -> exp < exp
Rule 81    expression -> exp AND exp
Rule 82    expression -> exp OR exp
Rule 83    expression -> exp empty
Rule 84    exp -> exp + exp
Rule 85    exp -> exp - exp
Rule 86    exp -> exp * exp
Rule 87    exp -> exp / exp
Rule 88    exp -> factor empty
Rule 89    factor -> ( expression )
Rule 90    factor -> var_cte
Rule 91    figure -> OVAL
Rule 92    figure -> TRIO
Rule 93    figure -> QUAD
Rule 94    figure -> ARC
Rule 95    move -> UP
Rule 96    move -> DOWN
Rule 97    move -> LEFT
Rule 98    move -> RIGHT
Rule 99    color -> RED
Rule 100   color -> YELLOW
Rule 101   color -> BLUE
Rule 102   color -> GREEN
Rule 103   color -> BLACK
Rule 104   color -> WHITE
Rule 105   color -> ORANGE
Rule 106   color -> PURPLE
Rule 107   color -> CYAN
Rule 108   screen -> WHERE
Rule 109   screen -> CLEAR
Rule 110   var_cte -> ID
Rule 111   var_cte -> CTE_INTEGER
Rule 112   var_cte -> CTE_FLOAT
Rule 113   var_cte -> TRUE
Rule 114   var_cte -> FALSE
Rule 115   gotoFalse -> <empty>
Rule 116   gotoE -> <empty>
Rule 117   gotoW -> <empty>
Rule 118   gotoR -> <empty>
Rule 119   continueGo -> <empty>
Rule 120   continueGoW -> <empty>
Rule 121   insertQuadMod -> <empty>
Rule 122   endMod -> <empty>
Rule 123   empty -> <empty>

Terminals, with rules where they appear

#                    : 20 30
(                    : 21 30 47 57 58 70 89
)                    : 21 33 34 47 57 58 70 89
*                    : 86
+                    : 84
,                    : 25 37 61
-                    : 85
/                    : 87
;                    : 33 34 46 50 53 54 56 57 58 59 66 68 69 71
<                    : 76 77 80
=                    : 46 75 75 77 78
>                    : 76 78 79
AND                  : 81
ARC                  : 94
ARR                  : 53
BLACK                : 103
BLUE                 : 101
BOOL                 : 29 65
CLEAR                : 109
COUNT                : 59
CTE_FLOAT            : 112
CTE_INTEGER          : 53 54 54 68 71 111
CTE_STRING           : 52
CYAN                 : 107
DOWN                 : 96
ECHO                 : 50
ELSE                 : 48
END                  : 2 3
FALSE                : 114
FLOAT                : 28 64
GREEN                : 102
ID                   : 23 24 31 46 53 54 55 110
IF                   : 47
IN                   : 57
INIT                 : 1
INT                  : 27 63
LEFT                 : 97
MAT                  : 54
MOD                  : 20
OFF                  : 69
ON                   : 68
OR                   : 82
ORANGE               : 105
OUT                  : 58
OVAL                 : 91
PIPE                 : 55
PURPLE               : 106
QUAD                 : 93
RED                  : 99
REPLAY               : 71
RIGHT                : 98
SAMPLE               : 67
TRIO                 : 92
TRUE                 : 113
UP                   : 95
WHERE                : 108
WHILE                : 70
WHITE                : 104
YELLOW               : 100
[                    : 53 54 54 56 71
]                    : 53 54 54 56 71
error                : 
{                    : 40
}                    : 41 42

Nonterminals, with rules where they appear

array                : 16
assign               : 9
block                : 21 22 47 48 70
blockA               : 40
blockB               : 41 44
blockC               : 43
callID               : 30
calling              : 15
callingA             : 30
callingB             : 33 37
callingC             : 35
checkParam           : 35
color                : 66 68
command              : 14 72
commandA             : 67
condition            : 10
conditionA           : 47
continueGo           : 47
continueGoW          : 70
cycle                : 12
empty                : 6 26 38 45 49 62 74 83 88
endMod               : 20
exp                  : 60 66 66 68 69 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 84 84 85 85 86 86 87 87
expression           : 35 46 47 51 70 89
factor               : 88
figure               : 66
gotoE                : 48
gotoFalse            : 47 70
gotoR                : 71
gotoW                : 70
insertEra            : 30
insertQuadMod        : 20
matrix               : 17
module               : 8
moduleA              : 20
moduleID             : 20
move                 : 68 69
pipeline             : 18
pipelineA            : 55
pipelineB            : 56 61
pipelineC            : 60
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
repeat               : 13
repeatA              : 71 73
repeatB              : 72
screen               : 19
statute              : 7 43
sumXparam            : 37
type                 : 24
typeDim              : 53 54
var_cte              : 57 90
vars                 : 21 25
varsA                : 24
workspace            : 4
write                : 11
writeA               : 50

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (20) module -> . MOD # moduleID insertQuadMod moduleA endMod
    (46) assign -> . ID = expression ;
    (47) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (50) write -> . ECHO writeA ;
    (70) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (71) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (66) command -> . figure exp exp color ;
    (67) command -> . SAMPLE commandA
    (30) calling -> . # callID ( insertEra callingA
    (53) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (54) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (55) pipeline -> . PIPE ID pipelineA
    (108) screen -> . WHERE
    (109) screen -> . CLEAR
    (91) figure -> . OVAL
    (92) figure -> . TRIO
    (93) figure -> . QUAD
    (94) figure -> . ARC

    END             shift and go to state 17
    MOD             shift and go to state 36
    ID              shift and go to state 25
    IF              shift and go to state 13
    ECHO            shift and go to state 20
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 21
    #               shift and go to state 10
    ARR             shift and go to state 19
    MAT             shift and go to state 30
    PIPE            shift and go to state 9
    WHERE           shift and go to state 32
    CLEAR           shift and go to state 14
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 24
    ARC             shift and go to state 33

    figure                         shift and go to state 3
    module                         shift and go to state 4
    array                          shift and go to state 8
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    condition                      shift and go to state 26
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    programA                       shift and go to state 22
    programB                       shift and go to state 23
    cycle                          shift and go to state 27
    statute                        shift and go to state 28
    pipeline                       shift and go to state 29
    calling                        shift and go to state 31
    command                        shift and go to state 34
    workspace                      shift and go to state 35
    assign                         shift and go to state 37

state 2

    (0) S' -> program .



state 3

    (66) command -> figure . exp exp color ;
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 43
    factor                         shift and go to state 44

state 4

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    WHILE           reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    ARR             reduce using rule 8 (workspace -> module .)
    MAT             reduce using rule 8 (workspace -> module .)
    PIPE            reduce using rule 8 (workspace -> module .)
    WHERE           reduce using rule 8 (workspace -> module .)
    CLEAR           reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 5

    (91) figure -> OVAL .

    (               reduce using rule 91 (figure -> OVAL .)
    ID              reduce using rule 91 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 91 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 91 (figure -> OVAL .)
    TRUE            reduce using rule 91 (figure -> OVAL .)
    FALSE           reduce using rule 91 (figure -> OVAL .)


state 6

    (70) cycle -> WHILE . gotoW ( expression ) gotoFalse block continueGoW
    (117) gotoW -> .

    (               reduce using rule 117 (gotoW -> .)

    gotoW                          shift and go to state 47

state 7

    (71) repeat -> REPLAY . CTE_INTEGER gotoR [ repeatA ] ;

    CTE_INTEGER     shift and go to state 48


state 8

    (16) statute -> array .

    MOD             reduce using rule 16 (statute -> array .)
    ID              reduce using rule 16 (statute -> array .)
    IF              reduce using rule 16 (statute -> array .)
    ECHO            reduce using rule 16 (statute -> array .)
    WHILE           reduce using rule 16 (statute -> array .)
    REPLAY          reduce using rule 16 (statute -> array .)
    SAMPLE          reduce using rule 16 (statute -> array .)
    #               reduce using rule 16 (statute -> array .)
    ARR             reduce using rule 16 (statute -> array .)
    MAT             reduce using rule 16 (statute -> array .)
    PIPE            reduce using rule 16 (statute -> array .)
    WHERE           reduce using rule 16 (statute -> array .)
    CLEAR           reduce using rule 16 (statute -> array .)
    OVAL            reduce using rule 16 (statute -> array .)
    TRIO            reduce using rule 16 (statute -> array .)
    QUAD            reduce using rule 16 (statute -> array .)
    ARC             reduce using rule 16 (statute -> array .)
    END             reduce using rule 16 (statute -> array .)
    }               reduce using rule 16 (statute -> array .)


state 9

    (55) pipeline -> PIPE . ID pipelineA

    ID              shift and go to state 49


state 10

    (30) calling -> # . callID ( insertEra callingA
    (31) callID -> . ID

    ID              shift and go to state 51

    callID                         shift and go to state 50

state 11

    (17) statute -> matrix .

    MOD             reduce using rule 17 (statute -> matrix .)
    ID              reduce using rule 17 (statute -> matrix .)
    IF              reduce using rule 17 (statute -> matrix .)
    ECHO            reduce using rule 17 (statute -> matrix .)
    WHILE           reduce using rule 17 (statute -> matrix .)
    REPLAY          reduce using rule 17 (statute -> matrix .)
    SAMPLE          reduce using rule 17 (statute -> matrix .)
    #               reduce using rule 17 (statute -> matrix .)
    ARR             reduce using rule 17 (statute -> matrix .)
    MAT             reduce using rule 17 (statute -> matrix .)
    PIPE            reduce using rule 17 (statute -> matrix .)
    WHERE           reduce using rule 17 (statute -> matrix .)
    CLEAR           reduce using rule 17 (statute -> matrix .)
    OVAL            reduce using rule 17 (statute -> matrix .)
    TRIO            reduce using rule 17 (statute -> matrix .)
    QUAD            reduce using rule 17 (statute -> matrix .)
    ARC             reduce using rule 17 (statute -> matrix .)
    END             reduce using rule 17 (statute -> matrix .)
    }               reduce using rule 17 (statute -> matrix .)


state 12

    (11) statute -> write .

    MOD             reduce using rule 11 (statute -> write .)
    ID              reduce using rule 11 (statute -> write .)
    IF              reduce using rule 11 (statute -> write .)
    ECHO            reduce using rule 11 (statute -> write .)
    WHILE           reduce using rule 11 (statute -> write .)
    REPLAY          reduce using rule 11 (statute -> write .)
    SAMPLE          reduce using rule 11 (statute -> write .)
    #               reduce using rule 11 (statute -> write .)
    ARR             reduce using rule 11 (statute -> write .)
    MAT             reduce using rule 11 (statute -> write .)
    PIPE            reduce using rule 11 (statute -> write .)
    WHERE           reduce using rule 11 (statute -> write .)
    CLEAR           reduce using rule 11 (statute -> write .)
    OVAL            reduce using rule 11 (statute -> write .)
    TRIO            reduce using rule 11 (statute -> write .)
    QUAD            reduce using rule 11 (statute -> write .)
    ARC             reduce using rule 11 (statute -> write .)
    END             reduce using rule 11 (statute -> write .)
    }               reduce using rule 11 (statute -> write .)


state 13

    (47) condition -> IF . ( expression ) gotoFalse block conditionA continueGo

    (               shift and go to state 52


state 14

    (109) screen -> CLEAR .

    ID              reduce using rule 109 (screen -> CLEAR .)
    IF              reduce using rule 109 (screen -> CLEAR .)
    ECHO            reduce using rule 109 (screen -> CLEAR .)
    WHILE           reduce using rule 109 (screen -> CLEAR .)
    REPLAY          reduce using rule 109 (screen -> CLEAR .)
    SAMPLE          reduce using rule 109 (screen -> CLEAR .)
    #               reduce using rule 109 (screen -> CLEAR .)
    ARR             reduce using rule 109 (screen -> CLEAR .)
    MAT             reduce using rule 109 (screen -> CLEAR .)
    PIPE            reduce using rule 109 (screen -> CLEAR .)
    WHERE           reduce using rule 109 (screen -> CLEAR .)
    CLEAR           reduce using rule 109 (screen -> CLEAR .)
    OVAL            reduce using rule 109 (screen -> CLEAR .)
    TRIO            reduce using rule 109 (screen -> CLEAR .)
    QUAD            reduce using rule 109 (screen -> CLEAR .)
    ARC             reduce using rule 109 (screen -> CLEAR .)
    }               reduce using rule 109 (screen -> CLEAR .)
    MOD             reduce using rule 109 (screen -> CLEAR .)
    END             reduce using rule 109 (screen -> CLEAR .)


state 15

    (92) figure -> TRIO .

    (               reduce using rule 92 (figure -> TRIO .)
    ID              reduce using rule 92 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 92 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 92 (figure -> TRIO .)
    TRUE            reduce using rule 92 (figure -> TRIO .)
    FALSE           reduce using rule 92 (figure -> TRIO .)


state 16

    (13) statute -> repeat .

    MOD             reduce using rule 13 (statute -> repeat .)
    ID              reduce using rule 13 (statute -> repeat .)
    IF              reduce using rule 13 (statute -> repeat .)
    ECHO            reduce using rule 13 (statute -> repeat .)
    WHILE           reduce using rule 13 (statute -> repeat .)
    REPLAY          reduce using rule 13 (statute -> repeat .)
    SAMPLE          reduce using rule 13 (statute -> repeat .)
    #               reduce using rule 13 (statute -> repeat .)
    ARR             reduce using rule 13 (statute -> repeat .)
    MAT             reduce using rule 13 (statute -> repeat .)
    PIPE            reduce using rule 13 (statute -> repeat .)
    WHERE           reduce using rule 13 (statute -> repeat .)
    CLEAR           reduce using rule 13 (statute -> repeat .)
    OVAL            reduce using rule 13 (statute -> repeat .)
    TRIO            reduce using rule 13 (statute -> repeat .)
    QUAD            reduce using rule 13 (statute -> repeat .)
    ARC             reduce using rule 13 (statute -> repeat .)
    END             reduce using rule 13 (statute -> repeat .)
    }               reduce using rule 13 (statute -> repeat .)


state 17

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 18

    (19) statute -> screen .

    MOD             reduce using rule 19 (statute -> screen .)
    ID              reduce using rule 19 (statute -> screen .)
    IF              reduce using rule 19 (statute -> screen .)
    ECHO            reduce using rule 19 (statute -> screen .)
    WHILE           reduce using rule 19 (statute -> screen .)
    REPLAY          reduce using rule 19 (statute -> screen .)
    SAMPLE          reduce using rule 19 (statute -> screen .)
    #               reduce using rule 19 (statute -> screen .)
    ARR             reduce using rule 19 (statute -> screen .)
    MAT             reduce using rule 19 (statute -> screen .)
    PIPE            reduce using rule 19 (statute -> screen .)
    WHERE           reduce using rule 19 (statute -> screen .)
    CLEAR           reduce using rule 19 (statute -> screen .)
    OVAL            reduce using rule 19 (statute -> screen .)
    TRIO            reduce using rule 19 (statute -> screen .)
    QUAD            reduce using rule 19 (statute -> screen .)
    ARC             reduce using rule 19 (statute -> screen .)
    END             reduce using rule 19 (statute -> screen .)
    }               reduce using rule 19 (statute -> screen .)


state 19

    (53) array -> ARR . typeDim ID [ CTE_INTEGER ] ;
    (63) typeDim -> . INT
    (64) typeDim -> . FLOAT
    (65) typeDim -> . BOOL

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 56

    typeDim                        shift and go to state 55

state 20

    (50) write -> ECHO . writeA ;
    (51) writeA -> . expression
    (52) writeA -> . CTE_STRING
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    CTE_STRING      shift and go to state 58
    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 59
    factor                         shift and go to state 44
    writeA                         shift and go to state 57
    expression                     shift and go to state 60

state 21

    (67) command -> SAMPLE . commandA
    (68) commandA -> . ON move exp CTE_INTEGER color ;
    (69) commandA -> . OFF move exp ;

    ON              shift and go to state 63
    OFF             shift and go to state 62

    commandA                       shift and go to state 61

state 22

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 23

    (2) programA -> programB . END

    END             shift and go to state 64


state 24

    (93) figure -> QUAD .

    (               reduce using rule 93 (figure -> QUAD .)
    ID              reduce using rule 93 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 93 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 93 (figure -> QUAD .)
    TRUE            reduce using rule 93 (figure -> QUAD .)
    FALSE           reduce using rule 93 (figure -> QUAD .)


state 25

    (46) assign -> ID . = expression ;

    =               shift and go to state 65


state 26

    (10) statute -> condition .

    MOD             reduce using rule 10 (statute -> condition .)
    ID              reduce using rule 10 (statute -> condition .)
    IF              reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    WHILE           reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    ARR             reduce using rule 10 (statute -> condition .)
    MAT             reduce using rule 10 (statute -> condition .)
    PIPE            reduce using rule 10 (statute -> condition .)
    WHERE           reduce using rule 10 (statute -> condition .)
    CLEAR           reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)


state 27

    (12) statute -> cycle .

    MOD             reduce using rule 12 (statute -> cycle .)
    ID              reduce using rule 12 (statute -> cycle .)
    IF              reduce using rule 12 (statute -> cycle .)
    ECHO            reduce using rule 12 (statute -> cycle .)
    WHILE           reduce using rule 12 (statute -> cycle .)
    REPLAY          reduce using rule 12 (statute -> cycle .)
    SAMPLE          reduce using rule 12 (statute -> cycle .)
    #               reduce using rule 12 (statute -> cycle .)
    ARR             reduce using rule 12 (statute -> cycle .)
    MAT             reduce using rule 12 (statute -> cycle .)
    PIPE            reduce using rule 12 (statute -> cycle .)
    WHERE           reduce using rule 12 (statute -> cycle .)
    CLEAR           reduce using rule 12 (statute -> cycle .)
    OVAL            reduce using rule 12 (statute -> cycle .)
    TRIO            reduce using rule 12 (statute -> cycle .)
    QUAD            reduce using rule 12 (statute -> cycle .)
    ARC             reduce using rule 12 (statute -> cycle .)
    END             reduce using rule 12 (statute -> cycle .)
    }               reduce using rule 12 (statute -> cycle .)


state 28

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    WHILE           reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    ARR             reduce using rule 7 (workspace -> statute .)
    MAT             reduce using rule 7 (workspace -> statute .)
    PIPE            reduce using rule 7 (workspace -> statute .)
    WHERE           reduce using rule 7 (workspace -> statute .)
    CLEAR           reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 29

    (18) statute -> pipeline .

    MOD             reduce using rule 18 (statute -> pipeline .)
    ID              reduce using rule 18 (statute -> pipeline .)
    IF              reduce using rule 18 (statute -> pipeline .)
    ECHO            reduce using rule 18 (statute -> pipeline .)
    WHILE           reduce using rule 18 (statute -> pipeline .)
    REPLAY          reduce using rule 18 (statute -> pipeline .)
    SAMPLE          reduce using rule 18 (statute -> pipeline .)
    #               reduce using rule 18 (statute -> pipeline .)
    ARR             reduce using rule 18 (statute -> pipeline .)
    MAT             reduce using rule 18 (statute -> pipeline .)
    PIPE            reduce using rule 18 (statute -> pipeline .)
    WHERE           reduce using rule 18 (statute -> pipeline .)
    CLEAR           reduce using rule 18 (statute -> pipeline .)
    OVAL            reduce using rule 18 (statute -> pipeline .)
    TRIO            reduce using rule 18 (statute -> pipeline .)
    QUAD            reduce using rule 18 (statute -> pipeline .)
    ARC             reduce using rule 18 (statute -> pipeline .)
    END             reduce using rule 18 (statute -> pipeline .)
    }               reduce using rule 18 (statute -> pipeline .)


state 30

    (54) matrix -> MAT . typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (63) typeDim -> . INT
    (64) typeDim -> . FLOAT
    (65) typeDim -> . BOOL

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 56

    typeDim                        shift and go to state 66

state 31

    (15) statute -> calling .

    MOD             reduce using rule 15 (statute -> calling .)
    ID              reduce using rule 15 (statute -> calling .)
    IF              reduce using rule 15 (statute -> calling .)
    ECHO            reduce using rule 15 (statute -> calling .)
    WHILE           reduce using rule 15 (statute -> calling .)
    REPLAY          reduce using rule 15 (statute -> calling .)
    SAMPLE          reduce using rule 15 (statute -> calling .)
    #               reduce using rule 15 (statute -> calling .)
    ARR             reduce using rule 15 (statute -> calling .)
    MAT             reduce using rule 15 (statute -> calling .)
    PIPE            reduce using rule 15 (statute -> calling .)
    WHERE           reduce using rule 15 (statute -> calling .)
    CLEAR           reduce using rule 15 (statute -> calling .)
    OVAL            reduce using rule 15 (statute -> calling .)
    TRIO            reduce using rule 15 (statute -> calling .)
    QUAD            reduce using rule 15 (statute -> calling .)
    ARC             reduce using rule 15 (statute -> calling .)
    END             reduce using rule 15 (statute -> calling .)
    }               reduce using rule 15 (statute -> calling .)


state 32

    (108) screen -> WHERE .

    ID              reduce using rule 108 (screen -> WHERE .)
    IF              reduce using rule 108 (screen -> WHERE .)
    ECHO            reduce using rule 108 (screen -> WHERE .)
    WHILE           reduce using rule 108 (screen -> WHERE .)
    REPLAY          reduce using rule 108 (screen -> WHERE .)
    SAMPLE          reduce using rule 108 (screen -> WHERE .)
    #               reduce using rule 108 (screen -> WHERE .)
    ARR             reduce using rule 108 (screen -> WHERE .)
    MAT             reduce using rule 108 (screen -> WHERE .)
    PIPE            reduce using rule 108 (screen -> WHERE .)
    WHERE           reduce using rule 108 (screen -> WHERE .)
    CLEAR           reduce using rule 108 (screen -> WHERE .)
    OVAL            reduce using rule 108 (screen -> WHERE .)
    TRIO            reduce using rule 108 (screen -> WHERE .)
    QUAD            reduce using rule 108 (screen -> WHERE .)
    ARC             reduce using rule 108 (screen -> WHERE .)
    }               reduce using rule 108 (screen -> WHERE .)
    MOD             reduce using rule 108 (screen -> WHERE .)
    END             reduce using rule 108 (screen -> WHERE .)


state 33

    (94) figure -> ARC .

    (               reduce using rule 94 (figure -> ARC .)
    ID              reduce using rule 94 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 94 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 94 (figure -> ARC .)
    TRUE            reduce using rule 94 (figure -> ARC .)
    FALSE           reduce using rule 94 (figure -> ARC .)


state 34

    (14) statute -> command .

    MOD             reduce using rule 14 (statute -> command .)
    ID              reduce using rule 14 (statute -> command .)
    IF              reduce using rule 14 (statute -> command .)
    ECHO            reduce using rule 14 (statute -> command .)
    WHILE           reduce using rule 14 (statute -> command .)
    REPLAY          reduce using rule 14 (statute -> command .)
    SAMPLE          reduce using rule 14 (statute -> command .)
    #               reduce using rule 14 (statute -> command .)
    ARR             reduce using rule 14 (statute -> command .)
    MAT             reduce using rule 14 (statute -> command .)
    PIPE            reduce using rule 14 (statute -> command .)
    WHERE           reduce using rule 14 (statute -> command .)
    CLEAR           reduce using rule 14 (statute -> command .)
    OVAL            reduce using rule 14 (statute -> command .)
    TRIO            reduce using rule 14 (statute -> command .)
    QUAD            reduce using rule 14 (statute -> command .)
    ARC             reduce using rule 14 (statute -> command .)
    END             reduce using rule 14 (statute -> command .)
    }               reduce using rule 14 (statute -> command .)


state 35

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (123) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (20) module -> . MOD # moduleID insertQuadMod moduleA endMod
    (46) assign -> . ID = expression ;
    (47) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (50) write -> . ECHO writeA ;
    (70) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (71) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (66) command -> . figure exp exp color ;
    (67) command -> . SAMPLE commandA
    (30) calling -> . # callID ( insertEra callingA
    (53) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (54) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (55) pipeline -> . PIPE ID pipelineA
    (108) screen -> . WHERE
    (109) screen -> . CLEAR
    (91) figure -> . OVAL
    (92) figure -> . TRIO
    (93) figure -> . QUAD
    (94) figure -> . ARC

    END             reduce using rule 123 (empty -> .)
    MOD             shift and go to state 36
    ID              shift and go to state 25
    IF              shift and go to state 13
    ECHO            shift and go to state 20
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 21
    #               shift and go to state 10
    ARR             shift and go to state 19
    MAT             shift and go to state 30
    PIPE            shift and go to state 9
    WHERE           shift and go to state 32
    CLEAR           shift and go to state 14
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 24
    ARC             shift and go to state 33

    figure                         shift and go to state 3
    module                         shift and go to state 4
    array                          shift and go to state 8
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    condition                      shift and go to state 26
    empty                          shift and go to state 67
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    programB                       shift and go to state 68
    programC                       shift and go to state 69
    cycle                          shift and go to state 27
    statute                        shift and go to state 28
    pipeline                       shift and go to state 29
    calling                        shift and go to state 31
    command                        shift and go to state 34
    workspace                      shift and go to state 35
    assign                         shift and go to state 37

state 36

    (20) module -> MOD . # moduleID insertQuadMod moduleA endMod

    #               shift and go to state 70


state 37

    (9) statute -> assign .

    MOD             reduce using rule 9 (statute -> assign .)
    ID              reduce using rule 9 (statute -> assign .)
    IF              reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    WHILE           reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    ARR             reduce using rule 9 (statute -> assign .)
    MAT             reduce using rule 9 (statute -> assign .)
    PIPE            reduce using rule 9 (statute -> assign .)
    WHERE           reduce using rule 9 (statute -> assign .)
    CLEAR           reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)


state 38

    (112) var_cte -> CTE_FLOAT .

    =               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 112 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 112 (var_cte -> CTE_FLOAT .)
    +               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 112 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 112 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 112 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 112 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 112 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 112 (var_cte -> CTE_FLOAT .)
    WHITE           reduce using rule 112 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 112 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 112 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 112 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 112 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 112 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 112 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 112 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 112 (var_cte -> CTE_FLOAT .)


state 39

    (89) factor -> ( . expression )
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    expression                     shift and go to state 71
    exp                            shift and go to state 59
    factor                         shift and go to state 44

state 40

    (90) factor -> var_cte .

    +               reduce using rule 90 (factor -> var_cte .)
    -               reduce using rule 90 (factor -> var_cte .)
    *               reduce using rule 90 (factor -> var_cte .)
    /               reduce using rule 90 (factor -> var_cte .)
    ;               reduce using rule 90 (factor -> var_cte .)
    )               reduce using rule 90 (factor -> var_cte .)
    ,               reduce using rule 90 (factor -> var_cte .)
    ]               reduce using rule 90 (factor -> var_cte .)
    (               reduce using rule 90 (factor -> var_cte .)
    ID              reduce using rule 90 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 90 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 90 (factor -> var_cte .)
    TRUE            reduce using rule 90 (factor -> var_cte .)
    FALSE           reduce using rule 90 (factor -> var_cte .)
    =               reduce using rule 90 (factor -> var_cte .)
    <               reduce using rule 90 (factor -> var_cte .)
    >               reduce using rule 90 (factor -> var_cte .)
    AND             reduce using rule 90 (factor -> var_cte .)
    OR              reduce using rule 90 (factor -> var_cte .)
    RED             reduce using rule 90 (factor -> var_cte .)
    YELLOW          reduce using rule 90 (factor -> var_cte .)
    BLUE            reduce using rule 90 (factor -> var_cte .)
    GREEN           reduce using rule 90 (factor -> var_cte .)
    BLACK           reduce using rule 90 (factor -> var_cte .)
    WHITE           reduce using rule 90 (factor -> var_cte .)
    ORANGE          reduce using rule 90 (factor -> var_cte .)
    PURPLE          reduce using rule 90 (factor -> var_cte .)
    CYAN            reduce using rule 90 (factor -> var_cte .)


state 41

    (111) var_cte -> CTE_INTEGER .

    =               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 111 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 111 (var_cte -> CTE_INTEGER .)
    +               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 111 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 111 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 111 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 111 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 111 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 111 (var_cte -> CTE_INTEGER .)
    WHITE           reduce using rule 111 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 111 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 111 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 111 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 111 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 111 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 111 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 111 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 111 (var_cte -> CTE_INTEGER .)


state 42

    (113) var_cte -> TRUE .

    =               reduce using rule 113 (var_cte -> TRUE .)
    <               reduce using rule 113 (var_cte -> TRUE .)
    >               reduce using rule 113 (var_cte -> TRUE .)
    AND             reduce using rule 113 (var_cte -> TRUE .)
    OR              reduce using rule 113 (var_cte -> TRUE .)
    +               reduce using rule 113 (var_cte -> TRUE .)
    -               reduce using rule 113 (var_cte -> TRUE .)
    *               reduce using rule 113 (var_cte -> TRUE .)
    /               reduce using rule 113 (var_cte -> TRUE .)
    ,               reduce using rule 113 (var_cte -> TRUE .)
    )               reduce using rule 113 (var_cte -> TRUE .)
    ;               reduce using rule 113 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 113 (var_cte -> TRUE .)
    ]               reduce using rule 113 (var_cte -> TRUE .)
    RED             reduce using rule 113 (var_cte -> TRUE .)
    YELLOW          reduce using rule 113 (var_cte -> TRUE .)
    BLUE            reduce using rule 113 (var_cte -> TRUE .)
    GREEN           reduce using rule 113 (var_cte -> TRUE .)
    BLACK           reduce using rule 113 (var_cte -> TRUE .)
    WHITE           reduce using rule 113 (var_cte -> TRUE .)
    ORANGE          reduce using rule 113 (var_cte -> TRUE .)
    PURPLE          reduce using rule 113 (var_cte -> TRUE .)
    CYAN            reduce using rule 113 (var_cte -> TRUE .)
    (               reduce using rule 113 (var_cte -> TRUE .)
    ID              reduce using rule 113 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 113 (var_cte -> TRUE .)
    TRUE            reduce using rule 113 (var_cte -> TRUE .)
    FALSE           reduce using rule 113 (var_cte -> TRUE .)


state 43

    (66) command -> figure exp . exp color ;
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 76
    factor                         shift and go to state 44

state 44

    (88) exp -> factor . empty
    (123) empty -> .

    +               reduce using rule 123 (empty -> .)
    -               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    CTE_INTEGER     reduce using rule 123 (empty -> .)
    CTE_FLOAT       reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    =               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    >               reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    RED             reduce using rule 123 (empty -> .)
    YELLOW          reduce using rule 123 (empty -> .)
    BLUE            reduce using rule 123 (empty -> .)
    GREEN           reduce using rule 123 (empty -> .)
    BLACK           reduce using rule 123 (empty -> .)
    WHITE           reduce using rule 123 (empty -> .)
    ORANGE          reduce using rule 123 (empty -> .)
    PURPLE          reduce using rule 123 (empty -> .)
    CYAN            reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)

    empty                          shift and go to state 77

state 45

    (114) var_cte -> FALSE .

    =               reduce using rule 114 (var_cte -> FALSE .)
    <               reduce using rule 114 (var_cte -> FALSE .)
    >               reduce using rule 114 (var_cte -> FALSE .)
    AND             reduce using rule 114 (var_cte -> FALSE .)
    OR              reduce using rule 114 (var_cte -> FALSE .)
    +               reduce using rule 114 (var_cte -> FALSE .)
    -               reduce using rule 114 (var_cte -> FALSE .)
    *               reduce using rule 114 (var_cte -> FALSE .)
    /               reduce using rule 114 (var_cte -> FALSE .)
    ,               reduce using rule 114 (var_cte -> FALSE .)
    )               reduce using rule 114 (var_cte -> FALSE .)
    ;               reduce using rule 114 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 114 (var_cte -> FALSE .)
    ]               reduce using rule 114 (var_cte -> FALSE .)
    RED             reduce using rule 114 (var_cte -> FALSE .)
    YELLOW          reduce using rule 114 (var_cte -> FALSE .)
    BLUE            reduce using rule 114 (var_cte -> FALSE .)
    GREEN           reduce using rule 114 (var_cte -> FALSE .)
    BLACK           reduce using rule 114 (var_cte -> FALSE .)
    WHITE           reduce using rule 114 (var_cte -> FALSE .)
    ORANGE          reduce using rule 114 (var_cte -> FALSE .)
    PURPLE          reduce using rule 114 (var_cte -> FALSE .)
    CYAN            reduce using rule 114 (var_cte -> FALSE .)
    (               reduce using rule 114 (var_cte -> FALSE .)
    ID              reduce using rule 114 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 114 (var_cte -> FALSE .)
    TRUE            reduce using rule 114 (var_cte -> FALSE .)
    FALSE           reduce using rule 114 (var_cte -> FALSE .)


state 46

    (110) var_cte -> ID .

    =               reduce using rule 110 (var_cte -> ID .)
    <               reduce using rule 110 (var_cte -> ID .)
    >               reduce using rule 110 (var_cte -> ID .)
    AND             reduce using rule 110 (var_cte -> ID .)
    OR              reduce using rule 110 (var_cte -> ID .)
    +               reduce using rule 110 (var_cte -> ID .)
    -               reduce using rule 110 (var_cte -> ID .)
    *               reduce using rule 110 (var_cte -> ID .)
    /               reduce using rule 110 (var_cte -> ID .)
    ,               reduce using rule 110 (var_cte -> ID .)
    )               reduce using rule 110 (var_cte -> ID .)
    ;               reduce using rule 110 (var_cte -> ID .)
    CTE_INTEGER     reduce using rule 110 (var_cte -> ID .)
    ]               reduce using rule 110 (var_cte -> ID .)
    RED             reduce using rule 110 (var_cte -> ID .)
    YELLOW          reduce using rule 110 (var_cte -> ID .)
    BLUE            reduce using rule 110 (var_cte -> ID .)
    GREEN           reduce using rule 110 (var_cte -> ID .)
    BLACK           reduce using rule 110 (var_cte -> ID .)
    WHITE           reduce using rule 110 (var_cte -> ID .)
    ORANGE          reduce using rule 110 (var_cte -> ID .)
    PURPLE          reduce using rule 110 (var_cte -> ID .)
    CYAN            reduce using rule 110 (var_cte -> ID .)
    (               reduce using rule 110 (var_cte -> ID .)
    ID              reduce using rule 110 (var_cte -> ID .)
    CTE_FLOAT       reduce using rule 110 (var_cte -> ID .)
    TRUE            reduce using rule 110 (var_cte -> ID .)
    FALSE           reduce using rule 110 (var_cte -> ID .)


state 47

    (70) cycle -> WHILE gotoW . ( expression ) gotoFalse block continueGoW

    (               shift and go to state 78


state 48

    (71) repeat -> REPLAY CTE_INTEGER . gotoR [ repeatA ] ;
    (118) gotoR -> .

    [               reduce using rule 118 (gotoR -> .)

    gotoR                          shift and go to state 79

state 49

    (55) pipeline -> PIPE ID . pipelineA
    (56) pipelineA -> . [ pipelineB ] ;
    (57) pipelineA -> . IN ( var_cte ) ;
    (58) pipelineA -> . OUT ( ) ;
    (59) pipelineA -> . COUNT ;

    [               shift and go to state 83
    IN              shift and go to state 81
    OUT             shift and go to state 84
    COUNT           shift and go to state 80

    pipelineA                      shift and go to state 82

state 50

    (30) calling -> # callID . ( insertEra callingA

    (               shift and go to state 85


state 51

    (31) callID -> ID .

    (               reduce using rule 31 (callID -> ID .)


state 52

    (47) condition -> IF ( . expression ) gotoFalse block conditionA continueGo
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    exp                            shift and go to state 59
    factor                         shift and go to state 44
    var_cte                        shift and go to state 40
    expression                     shift and go to state 86

state 53

    (63) typeDim -> INT .

    ID              reduce using rule 63 (typeDim -> INT .)


state 54

    (64) typeDim -> FLOAT .

    ID              reduce using rule 64 (typeDim -> FLOAT .)


state 55

    (53) array -> ARR typeDim . ID [ CTE_INTEGER ] ;

    ID              shift and go to state 87


state 56

    (65) typeDim -> BOOL .

    ID              reduce using rule 65 (typeDim -> BOOL .)


state 57

    (50) write -> ECHO writeA . ;

    ;               shift and go to state 88


state 58

    (52) writeA -> CTE_STRING .

    ;               reduce using rule 52 (writeA -> CTE_STRING .)


state 59

    (75) expression -> exp . = = exp
    (76) expression -> exp . < > exp
    (77) expression -> exp . < = exp
    (78) expression -> exp . > = exp
    (79) expression -> exp . > exp
    (80) expression -> exp . < exp
    (81) expression -> exp . AND exp
    (82) expression -> exp . OR exp
    (83) expression -> exp . empty
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp
    (123) empty -> .

    =               shift and go to state 91
    <               shift and go to state 90
    >               shift and go to state 94
    AND             shift and go to state 89
    OR              shift and go to state 92
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    ;               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)

    empty                          shift and go to state 93

state 60

    (51) writeA -> expression .

    ;               reduce using rule 51 (writeA -> expression .)


state 61

    (67) command -> SAMPLE commandA .

    SAMPLE          reduce using rule 67 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 67 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 67 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 67 (command -> SAMPLE commandA .)
    ARC             reduce using rule 67 (command -> SAMPLE commandA .)
    ]               reduce using rule 67 (command -> SAMPLE commandA .)
    ID              reduce using rule 67 (command -> SAMPLE commandA .)
    IF              reduce using rule 67 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 67 (command -> SAMPLE commandA .)
    WHILE           reduce using rule 67 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 67 (command -> SAMPLE commandA .)
    #               reduce using rule 67 (command -> SAMPLE commandA .)
    ARR             reduce using rule 67 (command -> SAMPLE commandA .)
    MAT             reduce using rule 67 (command -> SAMPLE commandA .)
    PIPE            reduce using rule 67 (command -> SAMPLE commandA .)
    WHERE           reduce using rule 67 (command -> SAMPLE commandA .)
    CLEAR           reduce using rule 67 (command -> SAMPLE commandA .)
    }               reduce using rule 67 (command -> SAMPLE commandA .)
    MOD             reduce using rule 67 (command -> SAMPLE commandA .)
    END             reduce using rule 67 (command -> SAMPLE commandA .)


state 62

    (69) commandA -> OFF . move exp ;
    (95) move -> . UP
    (96) move -> . DOWN
    (97) move -> . LEFT
    (98) move -> . RIGHT

    UP              shift and go to state 97
    DOWN            shift and go to state 98
    LEFT            shift and go to state 99
    RIGHT           shift and go to state 95

    move                           shift and go to state 96

state 63

    (68) commandA -> ON . move exp CTE_INTEGER color ;
    (95) move -> . UP
    (96) move -> . DOWN
    (97) move -> . LEFT
    (98) move -> . RIGHT

    UP              shift and go to state 97
    DOWN            shift and go to state 98
    LEFT            shift and go to state 99
    RIGHT           shift and go to state 95

    move                           shift and go to state 100

state 64

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 65

    (46) assign -> ID = . expression ;
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    expression                     shift and go to state 101
    exp                            shift and go to state 59
    factor                         shift and go to state 44

state 66

    (54) matrix -> MAT typeDim . ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    ID              shift and go to state 102


state 67

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 68

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 69

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 70

    (20) module -> MOD # . moduleID insertQuadMod moduleA endMod
    (23) moduleID -> . ID

    ID              shift and go to state 103

    moduleID                       shift and go to state 104

state 71

    (89) factor -> ( expression . )

    )               shift and go to state 105


state 72

    (84) exp -> exp + . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 106
    factor                         shift and go to state 44

state 73

    (86) exp -> exp * . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 107
    factor                         shift and go to state 44

state 74

    (85) exp -> exp - . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 108
    factor                         shift and go to state 44

state 75

    (87) exp -> exp / . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 109
    factor                         shift and go to state 44

state 76

    (66) command -> figure exp exp . color ;
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp
    (99) color -> . RED
    (100) color -> . YELLOW
    (101) color -> . BLUE
    (102) color -> . GREEN
    (103) color -> . BLACK
    (104) color -> . WHITE
    (105) color -> . ORANGE
    (106) color -> . PURPLE
    (107) color -> . CYAN

    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    RED             shift and go to state 119
    YELLOW          shift and go to state 114
    BLUE            shift and go to state 110
    GREEN           shift and go to state 113
    BLACK           shift and go to state 117
    WHITE           shift and go to state 118
    ORANGE          shift and go to state 116
    PURPLE          shift and go to state 112
    CYAN            shift and go to state 115

    color                          shift and go to state 111

state 77

    (88) exp -> factor empty .

    +               reduce using rule 88 (exp -> factor empty .)
    -               reduce using rule 88 (exp -> factor empty .)
    *               reduce using rule 88 (exp -> factor empty .)
    /               reduce using rule 88 (exp -> factor empty .)
    (               reduce using rule 88 (exp -> factor empty .)
    ID              reduce using rule 88 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 88 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 88 (exp -> factor empty .)
    TRUE            reduce using rule 88 (exp -> factor empty .)
    FALSE           reduce using rule 88 (exp -> factor empty .)
    ;               reduce using rule 88 (exp -> factor empty .)
    )               reduce using rule 88 (exp -> factor empty .)
    ,               reduce using rule 88 (exp -> factor empty .)
    ]               reduce using rule 88 (exp -> factor empty .)
    =               reduce using rule 88 (exp -> factor empty .)
    <               reduce using rule 88 (exp -> factor empty .)
    >               reduce using rule 88 (exp -> factor empty .)
    AND             reduce using rule 88 (exp -> factor empty .)
    OR              reduce using rule 88 (exp -> factor empty .)
    RED             reduce using rule 88 (exp -> factor empty .)
    YELLOW          reduce using rule 88 (exp -> factor empty .)
    BLUE            reduce using rule 88 (exp -> factor empty .)
    GREEN           reduce using rule 88 (exp -> factor empty .)
    BLACK           reduce using rule 88 (exp -> factor empty .)
    WHITE           reduce using rule 88 (exp -> factor empty .)
    ORANGE          reduce using rule 88 (exp -> factor empty .)
    PURPLE          reduce using rule 88 (exp -> factor empty .)
    CYAN            reduce using rule 88 (exp -> factor empty .)


state 78

    (70) cycle -> WHILE gotoW ( . expression ) gotoFalse block continueGoW
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 59
    factor                         shift and go to state 44
    expression                     shift and go to state 120

state 79

    (71) repeat -> REPLAY CTE_INTEGER gotoR . [ repeatA ] ;

    [               shift and go to state 121


state 80

    (59) pipelineA -> COUNT . ;

    ;               shift and go to state 122


state 81

    (57) pipelineA -> IN . ( var_cte ) ;

    (               shift and go to state 123


state 82

    (55) pipeline -> PIPE ID pipelineA .

    ID              reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    IF              reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    ECHO            reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    WHILE           reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    REPLAY          reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    SAMPLE          reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    #               reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    ARR             reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    MAT             reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    PIPE            reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    WHERE           reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    CLEAR           reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    OVAL            reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    TRIO            reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    QUAD            reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    ARC             reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    }               reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    MOD             reduce using rule 55 (pipeline -> PIPE ID pipelineA .)
    END             reduce using rule 55 (pipeline -> PIPE ID pipelineA .)


state 83

    (56) pipelineA -> [ . pipelineB ] ;
    (60) pipelineB -> . exp pipelineC
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    pipelineB                      shift and go to state 124
    exp                            shift and go to state 125
    factor                         shift and go to state 44

state 84

    (58) pipelineA -> OUT . ( ) ;

    (               shift and go to state 126


state 85

    (30) calling -> # callID ( . insertEra callingA
    (32) insertEra -> .

    )               reduce using rule 32 (insertEra -> .)
    (               reduce using rule 32 (insertEra -> .)
    ID              reduce using rule 32 (insertEra -> .)
    CTE_INTEGER     reduce using rule 32 (insertEra -> .)
    CTE_FLOAT       reduce using rule 32 (insertEra -> .)
    TRUE            reduce using rule 32 (insertEra -> .)
    FALSE           reduce using rule 32 (insertEra -> .)

    insertEra                      shift and go to state 127

state 86

    (47) condition -> IF ( expression . ) gotoFalse block conditionA continueGo

    )               shift and go to state 128


state 87

    (53) array -> ARR typeDim ID . [ CTE_INTEGER ] ;

    [               shift and go to state 129


state 88

    (50) write -> ECHO writeA ; .

    MOD             reduce using rule 50 (write -> ECHO writeA ; .)
    ID              reduce using rule 50 (write -> ECHO writeA ; .)
    IF              reduce using rule 50 (write -> ECHO writeA ; .)
    ECHO            reduce using rule 50 (write -> ECHO writeA ; .)
    WHILE           reduce using rule 50 (write -> ECHO writeA ; .)
    REPLAY          reduce using rule 50 (write -> ECHO writeA ; .)
    SAMPLE          reduce using rule 50 (write -> ECHO writeA ; .)
    #               reduce using rule 50 (write -> ECHO writeA ; .)
    ARR             reduce using rule 50 (write -> ECHO writeA ; .)
    MAT             reduce using rule 50 (write -> ECHO writeA ; .)
    PIPE            reduce using rule 50 (write -> ECHO writeA ; .)
    WHERE           reduce using rule 50 (write -> ECHO writeA ; .)
    CLEAR           reduce using rule 50 (write -> ECHO writeA ; .)
    OVAL            reduce using rule 50 (write -> ECHO writeA ; .)
    TRIO            reduce using rule 50 (write -> ECHO writeA ; .)
    QUAD            reduce using rule 50 (write -> ECHO writeA ; .)
    ARC             reduce using rule 50 (write -> ECHO writeA ; .)
    END             reduce using rule 50 (write -> ECHO writeA ; .)
    }               reduce using rule 50 (write -> ECHO writeA ; .)


state 89

    (81) expression -> exp AND . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 130
    factor                         shift and go to state 44

state 90

    (76) expression -> exp < . > exp
    (77) expression -> exp < . = exp
    (80) expression -> exp < . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    >               shift and go to state 133
    =               shift and go to state 132
    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 131
    factor                         shift and go to state 44

state 91

    (75) expression -> exp = . = exp

    =               shift and go to state 134


state 92

    (82) expression -> exp OR . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 135
    factor                         shift and go to state 44

state 93

    (83) expression -> exp empty .

    )               reduce using rule 83 (expression -> exp empty .)
    ;               reduce using rule 83 (expression -> exp empty .)
    ,               reduce using rule 83 (expression -> exp empty .)


state 94

    (78) expression -> exp > . = exp
    (79) expression -> exp > . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    =               shift and go to state 137
    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 136
    factor                         shift and go to state 44

state 95

    (98) move -> RIGHT .

    (               reduce using rule 98 (move -> RIGHT .)
    ID              reduce using rule 98 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 98 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 98 (move -> RIGHT .)
    TRUE            reduce using rule 98 (move -> RIGHT .)
    FALSE           reduce using rule 98 (move -> RIGHT .)


state 96

    (69) commandA -> OFF move . exp ;
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 138
    factor                         shift and go to state 44

state 97

    (95) move -> UP .

    (               reduce using rule 95 (move -> UP .)
    ID              reduce using rule 95 (move -> UP .)
    CTE_INTEGER     reduce using rule 95 (move -> UP .)
    CTE_FLOAT       reduce using rule 95 (move -> UP .)
    TRUE            reduce using rule 95 (move -> UP .)
    FALSE           reduce using rule 95 (move -> UP .)


state 98

    (96) move -> DOWN .

    (               reduce using rule 96 (move -> DOWN .)
    ID              reduce using rule 96 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 96 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 96 (move -> DOWN .)
    TRUE            reduce using rule 96 (move -> DOWN .)
    FALSE           reduce using rule 96 (move -> DOWN .)


state 99

    (97) move -> LEFT .

    (               reduce using rule 97 (move -> LEFT .)
    ID              reduce using rule 97 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 97 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 97 (move -> LEFT .)
    TRUE            reduce using rule 97 (move -> LEFT .)
    FALSE           reduce using rule 97 (move -> LEFT .)


state 100

    (68) commandA -> ON move . exp CTE_INTEGER color ;
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 139
    factor                         shift and go to state 44

state 101

    (46) assign -> ID = expression . ;

    ;               shift and go to state 140


state 102

    (54) matrix -> MAT typeDim ID . [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    [               shift and go to state 141


state 103

    (23) moduleID -> ID .

    (               reduce using rule 23 (moduleID -> ID .)
    {               reduce using rule 23 (moduleID -> ID .)


state 104

    (20) module -> MOD # moduleID . insertQuadMod moduleA endMod
    (121) insertQuadMod -> .

    (               reduce using rule 121 (insertQuadMod -> .)
    {               reduce using rule 121 (insertQuadMod -> .)

    insertQuadMod                  shift and go to state 142

state 105

    (89) factor -> ( expression ) .

    +               reduce using rule 89 (factor -> ( expression ) .)
    -               reduce using rule 89 (factor -> ( expression ) .)
    *               reduce using rule 89 (factor -> ( expression ) .)
    /               reduce using rule 89 (factor -> ( expression ) .)
    ;               reduce using rule 89 (factor -> ( expression ) .)
    )               reduce using rule 89 (factor -> ( expression ) .)
    ,               reduce using rule 89 (factor -> ( expression ) .)
    ]               reduce using rule 89 (factor -> ( expression ) .)
    (               reduce using rule 89 (factor -> ( expression ) .)
    ID              reduce using rule 89 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 89 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 89 (factor -> ( expression ) .)
    TRUE            reduce using rule 89 (factor -> ( expression ) .)
    FALSE           reduce using rule 89 (factor -> ( expression ) .)
    =               reduce using rule 89 (factor -> ( expression ) .)
    <               reduce using rule 89 (factor -> ( expression ) .)
    >               reduce using rule 89 (factor -> ( expression ) .)
    AND             reduce using rule 89 (factor -> ( expression ) .)
    OR              reduce using rule 89 (factor -> ( expression ) .)
    RED             reduce using rule 89 (factor -> ( expression ) .)
    YELLOW          reduce using rule 89 (factor -> ( expression ) .)
    BLUE            reduce using rule 89 (factor -> ( expression ) .)
    GREEN           reduce using rule 89 (factor -> ( expression ) .)
    BLACK           reduce using rule 89 (factor -> ( expression ) .)
    WHITE           reduce using rule 89 (factor -> ( expression ) .)
    ORANGE          reduce using rule 89 (factor -> ( expression ) .)
    PURPLE          reduce using rule 89 (factor -> ( expression ) .)
    CYAN            reduce using rule 89 (factor -> ( expression ) .)


state 106

    (84) exp -> exp + exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    +               reduce using rule 84 (exp -> exp + exp .)
    -               reduce using rule 84 (exp -> exp + exp .)
    (               reduce using rule 84 (exp -> exp + exp .)
    ID              reduce using rule 84 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 84 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 84 (exp -> exp + exp .)
    TRUE            reduce using rule 84 (exp -> exp + exp .)
    FALSE           reduce using rule 84 (exp -> exp + exp .)
    ;               reduce using rule 84 (exp -> exp + exp .)
    )               reduce using rule 84 (exp -> exp + exp .)
    ,               reduce using rule 84 (exp -> exp + exp .)
    ]               reduce using rule 84 (exp -> exp + exp .)
    =               reduce using rule 84 (exp -> exp + exp .)
    <               reduce using rule 84 (exp -> exp + exp .)
    >               reduce using rule 84 (exp -> exp + exp .)
    AND             reduce using rule 84 (exp -> exp + exp .)
    OR              reduce using rule 84 (exp -> exp + exp .)
    RED             reduce using rule 84 (exp -> exp + exp .)
    YELLOW          reduce using rule 84 (exp -> exp + exp .)
    BLUE            reduce using rule 84 (exp -> exp + exp .)
    GREEN           reduce using rule 84 (exp -> exp + exp .)
    BLACK           reduce using rule 84 (exp -> exp + exp .)
    WHITE           reduce using rule 84 (exp -> exp + exp .)
    ORANGE          reduce using rule 84 (exp -> exp + exp .)
    PURPLE          reduce using rule 84 (exp -> exp + exp .)
    CYAN            reduce using rule 84 (exp -> exp + exp .)
    *               shift and go to state 73
    /               shift and go to state 75

  ! *               [ reduce using rule 84 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 84 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]


state 107

    (86) exp -> exp * exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    +               reduce using rule 86 (exp -> exp * exp .)
    -               reduce using rule 86 (exp -> exp * exp .)
    *               reduce using rule 86 (exp -> exp * exp .)
    /               reduce using rule 86 (exp -> exp * exp .)
    (               reduce using rule 86 (exp -> exp * exp .)
    ID              reduce using rule 86 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 86 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 86 (exp -> exp * exp .)
    TRUE            reduce using rule 86 (exp -> exp * exp .)
    FALSE           reduce using rule 86 (exp -> exp * exp .)
    ;               reduce using rule 86 (exp -> exp * exp .)
    )               reduce using rule 86 (exp -> exp * exp .)
    ,               reduce using rule 86 (exp -> exp * exp .)
    ]               reduce using rule 86 (exp -> exp * exp .)
    =               reduce using rule 86 (exp -> exp * exp .)
    <               reduce using rule 86 (exp -> exp * exp .)
    >               reduce using rule 86 (exp -> exp * exp .)
    AND             reduce using rule 86 (exp -> exp * exp .)
    OR              reduce using rule 86 (exp -> exp * exp .)
    RED             reduce using rule 86 (exp -> exp * exp .)
    YELLOW          reduce using rule 86 (exp -> exp * exp .)
    BLUE            reduce using rule 86 (exp -> exp * exp .)
    GREEN           reduce using rule 86 (exp -> exp * exp .)
    BLACK           reduce using rule 86 (exp -> exp * exp .)
    WHITE           reduce using rule 86 (exp -> exp * exp .)
    ORANGE          reduce using rule 86 (exp -> exp * exp .)
    PURPLE          reduce using rule 86 (exp -> exp * exp .)
    CYAN            reduce using rule 86 (exp -> exp * exp .)

  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]
  ! *               [ shift and go to state 73 ]
  ! /               [ shift and go to state 75 ]


state 108

    (85) exp -> exp - exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    +               reduce using rule 85 (exp -> exp - exp .)
    -               reduce using rule 85 (exp -> exp - exp .)
    (               reduce using rule 85 (exp -> exp - exp .)
    ID              reduce using rule 85 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 85 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 85 (exp -> exp - exp .)
    TRUE            reduce using rule 85 (exp -> exp - exp .)
    FALSE           reduce using rule 85 (exp -> exp - exp .)
    ;               reduce using rule 85 (exp -> exp - exp .)
    )               reduce using rule 85 (exp -> exp - exp .)
    ,               reduce using rule 85 (exp -> exp - exp .)
    ]               reduce using rule 85 (exp -> exp - exp .)
    =               reduce using rule 85 (exp -> exp - exp .)
    <               reduce using rule 85 (exp -> exp - exp .)
    >               reduce using rule 85 (exp -> exp - exp .)
    AND             reduce using rule 85 (exp -> exp - exp .)
    OR              reduce using rule 85 (exp -> exp - exp .)
    RED             reduce using rule 85 (exp -> exp - exp .)
    YELLOW          reduce using rule 85 (exp -> exp - exp .)
    BLUE            reduce using rule 85 (exp -> exp - exp .)
    GREEN           reduce using rule 85 (exp -> exp - exp .)
    BLACK           reduce using rule 85 (exp -> exp - exp .)
    WHITE           reduce using rule 85 (exp -> exp - exp .)
    ORANGE          reduce using rule 85 (exp -> exp - exp .)
    PURPLE          reduce using rule 85 (exp -> exp - exp .)
    CYAN            reduce using rule 85 (exp -> exp - exp .)
    *               shift and go to state 73
    /               shift and go to state 75

  ! *               [ reduce using rule 85 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 85 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]


state 109

    (87) exp -> exp / exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    +               reduce using rule 87 (exp -> exp / exp .)
    -               reduce using rule 87 (exp -> exp / exp .)
    *               reduce using rule 87 (exp -> exp / exp .)
    /               reduce using rule 87 (exp -> exp / exp .)
    (               reduce using rule 87 (exp -> exp / exp .)
    ID              reduce using rule 87 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 87 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 87 (exp -> exp / exp .)
    TRUE            reduce using rule 87 (exp -> exp / exp .)
    FALSE           reduce using rule 87 (exp -> exp / exp .)
    ;               reduce using rule 87 (exp -> exp / exp .)
    )               reduce using rule 87 (exp -> exp / exp .)
    ,               reduce using rule 87 (exp -> exp / exp .)
    ]               reduce using rule 87 (exp -> exp / exp .)
    =               reduce using rule 87 (exp -> exp / exp .)
    <               reduce using rule 87 (exp -> exp / exp .)
    >               reduce using rule 87 (exp -> exp / exp .)
    AND             reduce using rule 87 (exp -> exp / exp .)
    OR              reduce using rule 87 (exp -> exp / exp .)
    RED             reduce using rule 87 (exp -> exp / exp .)
    YELLOW          reduce using rule 87 (exp -> exp / exp .)
    BLUE            reduce using rule 87 (exp -> exp / exp .)
    GREEN           reduce using rule 87 (exp -> exp / exp .)
    BLACK           reduce using rule 87 (exp -> exp / exp .)
    WHITE           reduce using rule 87 (exp -> exp / exp .)
    ORANGE          reduce using rule 87 (exp -> exp / exp .)
    PURPLE          reduce using rule 87 (exp -> exp / exp .)
    CYAN            reduce using rule 87 (exp -> exp / exp .)

  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 74 ]
  ! *               [ shift and go to state 73 ]
  ! /               [ shift and go to state 75 ]


state 110

    (101) color -> BLUE .

    ;               reduce using rule 101 (color -> BLUE .)


state 111

    (66) command -> figure exp exp color . ;

    ;               shift and go to state 143


state 112

    (106) color -> PURPLE .

    ;               reduce using rule 106 (color -> PURPLE .)


state 113

    (102) color -> GREEN .

    ;               reduce using rule 102 (color -> GREEN .)


state 114

    (100) color -> YELLOW .

    ;               reduce using rule 100 (color -> YELLOW .)


state 115

    (107) color -> CYAN .

    ;               reduce using rule 107 (color -> CYAN .)


state 116

    (105) color -> ORANGE .

    ;               reduce using rule 105 (color -> ORANGE .)


state 117

    (103) color -> BLACK .

    ;               reduce using rule 103 (color -> BLACK .)


state 118

    (104) color -> WHITE .

    ;               reduce using rule 104 (color -> WHITE .)


state 119

    (99) color -> RED .

    ;               reduce using rule 99 (color -> RED .)


state 120

    (70) cycle -> WHILE gotoW ( expression . ) gotoFalse block continueGoW

    )               shift and go to state 144


state 121

    (71) repeat -> REPLAY CTE_INTEGER gotoR [ . repeatA ] ;
    (72) repeatA -> . command repeatB
    (66) command -> . figure exp exp color ;
    (67) command -> . SAMPLE commandA
    (91) figure -> . OVAL
    (92) figure -> . TRIO
    (93) figure -> . QUAD
    (94) figure -> . ARC

    SAMPLE          shift and go to state 21
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 24
    ARC             shift and go to state 33

    figure                         shift and go to state 3
    repeatA                        shift and go to state 145
    command                        shift and go to state 146

state 122

    (59) pipelineA -> COUNT ; .

    MOD             reduce using rule 59 (pipelineA -> COUNT ; .)
    ID              reduce using rule 59 (pipelineA -> COUNT ; .)
    IF              reduce using rule 59 (pipelineA -> COUNT ; .)
    ECHO            reduce using rule 59 (pipelineA -> COUNT ; .)
    WHILE           reduce using rule 59 (pipelineA -> COUNT ; .)
    REPLAY          reduce using rule 59 (pipelineA -> COUNT ; .)
    SAMPLE          reduce using rule 59 (pipelineA -> COUNT ; .)
    #               reduce using rule 59 (pipelineA -> COUNT ; .)
    ARR             reduce using rule 59 (pipelineA -> COUNT ; .)
    MAT             reduce using rule 59 (pipelineA -> COUNT ; .)
    PIPE            reduce using rule 59 (pipelineA -> COUNT ; .)
    WHERE           reduce using rule 59 (pipelineA -> COUNT ; .)
    CLEAR           reduce using rule 59 (pipelineA -> COUNT ; .)
    OVAL            reduce using rule 59 (pipelineA -> COUNT ; .)
    TRIO            reduce using rule 59 (pipelineA -> COUNT ; .)
    QUAD            reduce using rule 59 (pipelineA -> COUNT ; .)
    ARC             reduce using rule 59 (pipelineA -> COUNT ; .)
    END             reduce using rule 59 (pipelineA -> COUNT ; .)
    }               reduce using rule 59 (pipelineA -> COUNT ; .)


state 123

    (57) pipelineA -> IN ( . var_cte ) ;
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 147

state 124

    (56) pipelineA -> [ pipelineB . ] ;

    ]               shift and go to state 148


state 125

    (60) pipelineB -> exp . pipelineC
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp
    (61) pipelineC -> . , pipelineB
    (62) pipelineC -> . empty
    (123) empty -> .

    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75
    ,               shift and go to state 149
    ]               reduce using rule 123 (empty -> .)

    empty                          shift and go to state 151
    pipelineC                      shift and go to state 150

state 126

    (58) pipelineA -> OUT ( . ) ;

    )               shift and go to state 152


state 127

    (30) calling -> # callID ( insertEra . callingA
    (33) callingA -> . callingB ) ;
    (34) callingA -> . ) ;
    (35) callingB -> . expression checkParam callingC
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    )               shift and go to state 153
    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    factor                         shift and go to state 44
    var_cte                        shift and go to state 40
    callingA                       shift and go to state 154
    callingB                       shift and go to state 155
    exp                            shift and go to state 59
    expression                     shift and go to state 156

state 128

    (47) condition -> IF ( expression ) . gotoFalse block conditionA continueGo
    (115) gotoFalse -> .

    {               reduce using rule 115 (gotoFalse -> .)

    gotoFalse                      shift and go to state 157

state 129

    (53) array -> ARR typeDim ID [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 158


state 130

    (81) expression -> exp AND exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 81 (expression -> exp AND exp .)
    ;               reduce using rule 81 (expression -> exp AND exp .)
    ,               reduce using rule 81 (expression -> exp AND exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 131

    (80) expression -> exp < exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 80 (expression -> exp < exp .)
    ;               reduce using rule 80 (expression -> exp < exp .)
    ,               reduce using rule 80 (expression -> exp < exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 132

    (77) expression -> exp < = . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 159
    factor                         shift and go to state 44

state 133

    (76) expression -> exp < > . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 160
    factor                         shift and go to state 44

state 134

    (75) expression -> exp = = . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 161
    factor                         shift and go to state 44

state 135

    (82) expression -> exp OR exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 82 (expression -> exp OR exp .)
    ;               reduce using rule 82 (expression -> exp OR exp .)
    ,               reduce using rule 82 (expression -> exp OR exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 136

    (79) expression -> exp > exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 79 (expression -> exp > exp .)
    ;               reduce using rule 79 (expression -> exp > exp .)
    ,               reduce using rule 79 (expression -> exp > exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 137

    (78) expression -> exp > = . exp
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    exp                            shift and go to state 162
    factor                         shift and go to state 44

state 138

    (69) commandA -> OFF move exp . ;
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    ;               shift and go to state 163
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 139

    (68) commandA -> ON move exp . CTE_INTEGER color ;
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 164
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 140

    (46) assign -> ID = expression ; .

    MOD             reduce using rule 46 (assign -> ID = expression ; .)
    ID              reduce using rule 46 (assign -> ID = expression ; .)
    IF              reduce using rule 46 (assign -> ID = expression ; .)
    ECHO            reduce using rule 46 (assign -> ID = expression ; .)
    WHILE           reduce using rule 46 (assign -> ID = expression ; .)
    REPLAY          reduce using rule 46 (assign -> ID = expression ; .)
    SAMPLE          reduce using rule 46 (assign -> ID = expression ; .)
    #               reduce using rule 46 (assign -> ID = expression ; .)
    ARR             reduce using rule 46 (assign -> ID = expression ; .)
    MAT             reduce using rule 46 (assign -> ID = expression ; .)
    PIPE            reduce using rule 46 (assign -> ID = expression ; .)
    WHERE           reduce using rule 46 (assign -> ID = expression ; .)
    CLEAR           reduce using rule 46 (assign -> ID = expression ; .)
    OVAL            reduce using rule 46 (assign -> ID = expression ; .)
    TRIO            reduce using rule 46 (assign -> ID = expression ; .)
    QUAD            reduce using rule 46 (assign -> ID = expression ; .)
    ARC             reduce using rule 46 (assign -> ID = expression ; .)
    END             reduce using rule 46 (assign -> ID = expression ; .)
    }               reduce using rule 46 (assign -> ID = expression ; .)


state 141

    (54) matrix -> MAT typeDim ID [ . CTE_INTEGER ] [ CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 165


state 142

    (20) module -> MOD # moduleID insertQuadMod . moduleA endMod
    (21) moduleA -> . ( vars ) block
    (22) moduleA -> . block
    (40) block -> . { blockA

    (               shift and go to state 166
    {               shift and go to state 168

    moduleA                        shift and go to state 169
    block                          shift and go to state 167

state 143

    (66) command -> figure exp exp color ; .

    SAMPLE          reduce using rule 66 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 66 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 66 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 66 (command -> figure exp exp color ; .)
    ARC             reduce using rule 66 (command -> figure exp exp color ; .)
    ]               reduce using rule 66 (command -> figure exp exp color ; .)
    ID              reduce using rule 66 (command -> figure exp exp color ; .)
    IF              reduce using rule 66 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 66 (command -> figure exp exp color ; .)
    WHILE           reduce using rule 66 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 66 (command -> figure exp exp color ; .)
    #               reduce using rule 66 (command -> figure exp exp color ; .)
    ARR             reduce using rule 66 (command -> figure exp exp color ; .)
    MAT             reduce using rule 66 (command -> figure exp exp color ; .)
    PIPE            reduce using rule 66 (command -> figure exp exp color ; .)
    WHERE           reduce using rule 66 (command -> figure exp exp color ; .)
    CLEAR           reduce using rule 66 (command -> figure exp exp color ; .)
    }               reduce using rule 66 (command -> figure exp exp color ; .)
    MOD             reduce using rule 66 (command -> figure exp exp color ; .)
    END             reduce using rule 66 (command -> figure exp exp color ; .)


state 144

    (70) cycle -> WHILE gotoW ( expression ) . gotoFalse block continueGoW
    (115) gotoFalse -> .

    {               reduce using rule 115 (gotoFalse -> .)

    gotoFalse                      shift and go to state 170

state 145

    (71) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA . ] ;

    ]               shift and go to state 171


state 146

    (72) repeatA -> command . repeatB
    (73) repeatB -> . repeatA
    (74) repeatB -> . empty
    (72) repeatA -> . command repeatB
    (123) empty -> .
    (66) command -> . figure exp exp color ;
    (67) command -> . SAMPLE commandA
    (91) figure -> . OVAL
    (92) figure -> . TRIO
    (93) figure -> . QUAD
    (94) figure -> . ARC

    ]               reduce using rule 123 (empty -> .)
    SAMPLE          shift and go to state 21
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 24
    ARC             shift and go to state 33

    figure                         shift and go to state 3
    repeatA                        shift and go to state 172
    repeatB                        shift and go to state 173
    command                        shift and go to state 146
    empty                          shift and go to state 174

state 147

    (57) pipelineA -> IN ( var_cte . ) ;

    )               shift and go to state 175


state 148

    (56) pipelineA -> [ pipelineB ] . ;

    ;               shift and go to state 176


state 149

    (61) pipelineC -> , . pipelineB
    (60) pipelineB -> . exp pipelineC
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    pipelineB                      shift and go to state 177
    exp                            shift and go to state 125
    factor                         shift and go to state 44

state 150

    (60) pipelineB -> exp pipelineC .

    ]               reduce using rule 60 (pipelineB -> exp pipelineC .)


state 151

    (62) pipelineC -> empty .

    ]               reduce using rule 62 (pipelineC -> empty .)


state 152

    (58) pipelineA -> OUT ( ) . ;

    ;               shift and go to state 178


state 153

    (34) callingA -> ) . ;

    ;               shift and go to state 179


state 154

    (30) calling -> # callID ( insertEra callingA .

    MOD             reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    ID              reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    IF              reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    ECHO            reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    WHILE           reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    REPLAY          reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    SAMPLE          reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    #               reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    ARR             reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    MAT             reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    PIPE            reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    WHERE           reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    CLEAR           reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    OVAL            reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    TRIO            reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    QUAD            reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    ARC             reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    END             reduce using rule 30 (calling -> # callID ( insertEra callingA .)
    }               reduce using rule 30 (calling -> # callID ( insertEra callingA .)


state 155

    (33) callingA -> callingB . ) ;

    )               shift and go to state 180


state 156

    (35) callingB -> expression . checkParam callingC
    (36) checkParam -> .

    ,               reduce using rule 36 (checkParam -> .)
    )               reduce using rule 36 (checkParam -> .)

    checkParam                     shift and go to state 181

state 157

    (47) condition -> IF ( expression ) gotoFalse . block conditionA continueGo
    (40) block -> . { blockA

    {               shift and go to state 168

    block                          shift and go to state 182

state 158

    (53) array -> ARR typeDim ID [ CTE_INTEGER . ] ;

    ]               shift and go to state 183


state 159

    (77) expression -> exp < = exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 77 (expression -> exp < = exp .)
    ;               reduce using rule 77 (expression -> exp < = exp .)
    ,               reduce using rule 77 (expression -> exp < = exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 160

    (76) expression -> exp < > exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 76 (expression -> exp < > exp .)
    ;               reduce using rule 76 (expression -> exp < > exp .)
    ,               reduce using rule 76 (expression -> exp < > exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 161

    (75) expression -> exp = = exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 75 (expression -> exp = = exp .)
    ;               reduce using rule 75 (expression -> exp = = exp .)
    ,               reduce using rule 75 (expression -> exp = = exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 162

    (78) expression -> exp > = exp .
    (84) exp -> exp . + exp
    (85) exp -> exp . - exp
    (86) exp -> exp . * exp
    (87) exp -> exp . / exp

    )               reduce using rule 78 (expression -> exp > = exp .)
    ;               reduce using rule 78 (expression -> exp > = exp .)
    ,               reduce using rule 78 (expression -> exp > = exp .)
    +               shift and go to state 72
    -               shift and go to state 74
    *               shift and go to state 73
    /               shift and go to state 75


state 163

    (69) commandA -> OFF move exp ; .

    MOD             reduce using rule 69 (commandA -> OFF move exp ; .)
    ID              reduce using rule 69 (commandA -> OFF move exp ; .)
    IF              reduce using rule 69 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 69 (commandA -> OFF move exp ; .)
    WHILE           reduce using rule 69 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 69 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 69 (commandA -> OFF move exp ; .)
    #               reduce using rule 69 (commandA -> OFF move exp ; .)
    ARR             reduce using rule 69 (commandA -> OFF move exp ; .)
    MAT             reduce using rule 69 (commandA -> OFF move exp ; .)
    PIPE            reduce using rule 69 (commandA -> OFF move exp ; .)
    WHERE           reduce using rule 69 (commandA -> OFF move exp ; .)
    CLEAR           reduce using rule 69 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 69 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 69 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 69 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 69 (commandA -> OFF move exp ; .)
    END             reduce using rule 69 (commandA -> OFF move exp ; .)
    ]               reduce using rule 69 (commandA -> OFF move exp ; .)
    }               reduce using rule 69 (commandA -> OFF move exp ; .)


state 164

    (68) commandA -> ON move exp CTE_INTEGER . color ;
    (99) color -> . RED
    (100) color -> . YELLOW
    (101) color -> . BLUE
    (102) color -> . GREEN
    (103) color -> . BLACK
    (104) color -> . WHITE
    (105) color -> . ORANGE
    (106) color -> . PURPLE
    (107) color -> . CYAN

    RED             shift and go to state 119
    YELLOW          shift and go to state 114
    BLUE            shift and go to state 110
    GREEN           shift and go to state 113
    BLACK           shift and go to state 117
    WHITE           shift and go to state 118
    ORANGE          shift and go to state 116
    PURPLE          shift and go to state 112
    CYAN            shift and go to state 115

    color                          shift and go to state 184

state 165

    (54) matrix -> MAT typeDim ID [ CTE_INTEGER . ] [ CTE_INTEGER ] ;

    ]               shift and go to state 185


state 166

    (21) moduleA -> ( . vars ) block
    (24) vars -> . type ID varsA
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOL

    INT             shift and go to state 188
    FLOAT           shift and go to state 187
    BOOL            shift and go to state 189

    type                           shift and go to state 190
    vars                           shift and go to state 186

state 167

    (22) moduleA -> block .

    MOD             reduce using rule 22 (moduleA -> block .)
    ID              reduce using rule 22 (moduleA -> block .)
    IF              reduce using rule 22 (moduleA -> block .)
    ECHO            reduce using rule 22 (moduleA -> block .)
    WHILE           reduce using rule 22 (moduleA -> block .)
    REPLAY          reduce using rule 22 (moduleA -> block .)
    SAMPLE          reduce using rule 22 (moduleA -> block .)
    #               reduce using rule 22 (moduleA -> block .)
    ARR             reduce using rule 22 (moduleA -> block .)
    MAT             reduce using rule 22 (moduleA -> block .)
    PIPE            reduce using rule 22 (moduleA -> block .)
    WHERE           reduce using rule 22 (moduleA -> block .)
    CLEAR           reduce using rule 22 (moduleA -> block .)
    OVAL            reduce using rule 22 (moduleA -> block .)
    TRIO            reduce using rule 22 (moduleA -> block .)
    QUAD            reduce using rule 22 (moduleA -> block .)
    ARC             reduce using rule 22 (moduleA -> block .)
    END             reduce using rule 22 (moduleA -> block .)


state 168

    (40) block -> { . blockA
    (41) blockA -> . blockB }
    (42) blockA -> . }
    (43) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (46) assign -> . ID = expression ;
    (47) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (50) write -> . ECHO writeA ;
    (70) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (71) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (66) command -> . figure exp exp color ;
    (67) command -> . SAMPLE commandA
    (30) calling -> . # callID ( insertEra callingA
    (53) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (54) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (55) pipeline -> . PIPE ID pipelineA
    (108) screen -> . WHERE
    (109) screen -> . CLEAR
    (91) figure -> . OVAL
    (92) figure -> . TRIO
    (93) figure -> . QUAD
    (94) figure -> . ARC

    }               shift and go to state 192
    ID              shift and go to state 25
    IF              shift and go to state 13
    ECHO            shift and go to state 20
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 21
    #               shift and go to state 10
    ARR             shift and go to state 19
    MAT             shift and go to state 30
    PIPE            shift and go to state 9
    WHERE           shift and go to state 32
    CLEAR           shift and go to state 14
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 24
    ARC             shift and go to state 33

    figure                         shift and go to state 3
    array                          shift and go to state 8
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    command                        shift and go to state 34
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    condition                      shift and go to state 26
    cycle                          shift and go to state 27
    statute                        shift and go to state 191
    pipeline                       shift and go to state 29
    calling                        shift and go to state 31
    blockB                         shift and go to state 193
    blockA                         shift and go to state 194
    assign                         shift and go to state 37

state 169

    (20) module -> MOD # moduleID insertQuadMod moduleA . endMod
    (122) endMod -> .

    MOD             reduce using rule 122 (endMod -> .)
    ID              reduce using rule 122 (endMod -> .)
    IF              reduce using rule 122 (endMod -> .)
    ECHO            reduce using rule 122 (endMod -> .)
    WHILE           reduce using rule 122 (endMod -> .)
    REPLAY          reduce using rule 122 (endMod -> .)
    SAMPLE          reduce using rule 122 (endMod -> .)
    #               reduce using rule 122 (endMod -> .)
    ARR             reduce using rule 122 (endMod -> .)
    MAT             reduce using rule 122 (endMod -> .)
    PIPE            reduce using rule 122 (endMod -> .)
    WHERE           reduce using rule 122 (endMod -> .)
    CLEAR           reduce using rule 122 (endMod -> .)
    OVAL            reduce using rule 122 (endMod -> .)
    TRIO            reduce using rule 122 (endMod -> .)
    QUAD            reduce using rule 122 (endMod -> .)
    ARC             reduce using rule 122 (endMod -> .)
    END             reduce using rule 122 (endMod -> .)

    endMod                         shift and go to state 195

state 170

    (70) cycle -> WHILE gotoW ( expression ) gotoFalse . block continueGoW
    (40) block -> . { blockA

    {               shift and go to state 168

    block                          shift and go to state 196

state 171

    (71) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] . ;

    ;               shift and go to state 197


state 172

    (73) repeatB -> repeatA .

    ]               reduce using rule 73 (repeatB -> repeatA .)


state 173

    (72) repeatA -> command repeatB .

    ]               reduce using rule 72 (repeatA -> command repeatB .)


state 174

    (74) repeatB -> empty .

    ]               reduce using rule 74 (repeatB -> empty .)


state 175

    (57) pipelineA -> IN ( var_cte ) . ;

    ;               shift and go to state 198


state 176

    (56) pipelineA -> [ pipelineB ] ; .

    MOD             reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    ID              reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    IF              reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    ECHO            reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    WHILE           reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    REPLAY          reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    SAMPLE          reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    #               reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    ARR             reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    MAT             reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    PIPE            reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    WHERE           reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    CLEAR           reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    OVAL            reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    TRIO            reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    QUAD            reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    ARC             reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    END             reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)
    }               reduce using rule 56 (pipelineA -> [ pipelineB ] ; .)


state 177

    (61) pipelineC -> , pipelineB .

    ]               reduce using rule 61 (pipelineC -> , pipelineB .)


state 178

    (58) pipelineA -> OUT ( ) ; .

    MOD             reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    ID              reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    IF              reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    ECHO            reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    WHILE           reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    REPLAY          reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    SAMPLE          reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    #               reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    ARR             reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    MAT             reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    PIPE            reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    WHERE           reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    CLEAR           reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    OVAL            reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    TRIO            reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    QUAD            reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    ARC             reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    END             reduce using rule 58 (pipelineA -> OUT ( ) ; .)
    }               reduce using rule 58 (pipelineA -> OUT ( ) ; .)


state 179

    (34) callingA -> ) ; .

    MOD             reduce using rule 34 (callingA -> ) ; .)
    ID              reduce using rule 34 (callingA -> ) ; .)
    IF              reduce using rule 34 (callingA -> ) ; .)
    ECHO            reduce using rule 34 (callingA -> ) ; .)
    WHILE           reduce using rule 34 (callingA -> ) ; .)
    REPLAY          reduce using rule 34 (callingA -> ) ; .)
    SAMPLE          reduce using rule 34 (callingA -> ) ; .)
    #               reduce using rule 34 (callingA -> ) ; .)
    ARR             reduce using rule 34 (callingA -> ) ; .)
    MAT             reduce using rule 34 (callingA -> ) ; .)
    PIPE            reduce using rule 34 (callingA -> ) ; .)
    WHERE           reduce using rule 34 (callingA -> ) ; .)
    CLEAR           reduce using rule 34 (callingA -> ) ; .)
    OVAL            reduce using rule 34 (callingA -> ) ; .)
    TRIO            reduce using rule 34 (callingA -> ) ; .)
    QUAD            reduce using rule 34 (callingA -> ) ; .)
    ARC             reduce using rule 34 (callingA -> ) ; .)
    END             reduce using rule 34 (callingA -> ) ; .)
    }               reduce using rule 34 (callingA -> ) ; .)


state 180

    (33) callingA -> callingB ) . ;

    ;               shift and go to state 199


state 181

    (35) callingB -> expression checkParam . callingC
    (37) callingC -> . , sumXparam callingB
    (38) callingC -> . empty
    (123) empty -> .

    ,               shift and go to state 200
    )               reduce using rule 123 (empty -> .)

    callingC                       shift and go to state 201
    empty                          shift and go to state 202

state 182

    (47) condition -> IF ( expression ) gotoFalse block . conditionA continueGo
    (48) conditionA -> . ELSE gotoE block
    (49) conditionA -> . empty
    (123) empty -> .

    ELSE            shift and go to state 205
    MOD             reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    ECHO            reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    REPLAY          reduce using rule 123 (empty -> .)
    SAMPLE          reduce using rule 123 (empty -> .)
    #               reduce using rule 123 (empty -> .)
    ARR             reduce using rule 123 (empty -> .)
    MAT             reduce using rule 123 (empty -> .)
    PIPE            reduce using rule 123 (empty -> .)
    WHERE           reduce using rule 123 (empty -> .)
    CLEAR           reduce using rule 123 (empty -> .)
    OVAL            reduce using rule 123 (empty -> .)
    TRIO            reduce using rule 123 (empty -> .)
    QUAD            reduce using rule 123 (empty -> .)
    ARC             reduce using rule 123 (empty -> .)
    END             reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)

    conditionA                     shift and go to state 203
    empty                          shift and go to state 204

state 183

    (53) array -> ARR typeDim ID [ CTE_INTEGER ] . ;

    ;               shift and go to state 206


state 184

    (68) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 207


state 185

    (54) matrix -> MAT typeDim ID [ CTE_INTEGER ] . [ CTE_INTEGER ] ;

    [               shift and go to state 208


state 186

    (21) moduleA -> ( vars . ) block

    )               shift and go to state 209


state 187

    (28) type -> FLOAT .

    ID              reduce using rule 28 (type -> FLOAT .)


state 188

    (27) type -> INT .

    ID              reduce using rule 27 (type -> INT .)


state 189

    (29) type -> BOOL .

    ID              reduce using rule 29 (type -> BOOL .)


state 190

    (24) vars -> type . ID varsA

    ID              shift and go to state 210


state 191

    (43) blockB -> statute . blockC
    (44) blockC -> . blockB
    (45) blockC -> . empty
    (43) blockB -> . statute blockC
    (123) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (46) assign -> . ID = expression ;
    (47) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (50) write -> . ECHO writeA ;
    (70) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (71) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (66) command -> . figure exp exp color ;
    (67) command -> . SAMPLE commandA
    (30) calling -> . # callID ( insertEra callingA
    (53) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (54) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (55) pipeline -> . PIPE ID pipelineA
    (108) screen -> . WHERE
    (109) screen -> . CLEAR
    (91) figure -> . OVAL
    (92) figure -> . TRIO
    (93) figure -> . QUAD
    (94) figure -> . ARC

    }               reduce using rule 123 (empty -> .)
    ID              shift and go to state 25
    IF              shift and go to state 13
    ECHO            shift and go to state 20
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 21
    #               shift and go to state 10
    ARR             shift and go to state 19
    MAT             shift and go to state 30
    PIPE            shift and go to state 9
    WHERE           shift and go to state 32
    CLEAR           shift and go to state 14
    OVAL            shift and go to state 5
    TRIO            shift and go to state 15
    QUAD            shift and go to state 24
    ARC             shift and go to state 33

    figure                         shift and go to state 3
    array                          shift and go to state 8
    matrix                         shift and go to state 11
    write                          shift and go to state 12
    command                        shift and go to state 34
    empty                          shift and go to state 211
    repeat                         shift and go to state 16
    screen                         shift and go to state 18
    condition                      shift and go to state 26
    cycle                          shift and go to state 27
    statute                        shift and go to state 191
    pipeline                       shift and go to state 29
    calling                        shift and go to state 31
    blockC                         shift and go to state 212
    blockB                         shift and go to state 213
    assign                         shift and go to state 37

state 192

    (42) blockA -> } .

    MOD             reduce using rule 42 (blockA -> } .)
    ID              reduce using rule 42 (blockA -> } .)
    IF              reduce using rule 42 (blockA -> } .)
    ECHO            reduce using rule 42 (blockA -> } .)
    WHILE           reduce using rule 42 (blockA -> } .)
    REPLAY          reduce using rule 42 (blockA -> } .)
    SAMPLE          reduce using rule 42 (blockA -> } .)
    #               reduce using rule 42 (blockA -> } .)
    ARR             reduce using rule 42 (blockA -> } .)
    MAT             reduce using rule 42 (blockA -> } .)
    PIPE            reduce using rule 42 (blockA -> } .)
    WHERE           reduce using rule 42 (blockA -> } .)
    CLEAR           reduce using rule 42 (blockA -> } .)
    OVAL            reduce using rule 42 (blockA -> } .)
    TRIO            reduce using rule 42 (blockA -> } .)
    QUAD            reduce using rule 42 (blockA -> } .)
    ARC             reduce using rule 42 (blockA -> } .)
    END             reduce using rule 42 (blockA -> } .)
    ELSE            reduce using rule 42 (blockA -> } .)
    }               reduce using rule 42 (blockA -> } .)


state 193

    (41) blockA -> blockB . }

    }               shift and go to state 214


state 194

    (40) block -> { blockA .

    MOD             reduce using rule 40 (block -> { blockA .)
    ID              reduce using rule 40 (block -> { blockA .)
    IF              reduce using rule 40 (block -> { blockA .)
    ECHO            reduce using rule 40 (block -> { blockA .)
    WHILE           reduce using rule 40 (block -> { blockA .)
    REPLAY          reduce using rule 40 (block -> { blockA .)
    SAMPLE          reduce using rule 40 (block -> { blockA .)
    #               reduce using rule 40 (block -> { blockA .)
    ARR             reduce using rule 40 (block -> { blockA .)
    MAT             reduce using rule 40 (block -> { blockA .)
    PIPE            reduce using rule 40 (block -> { blockA .)
    WHERE           reduce using rule 40 (block -> { blockA .)
    CLEAR           reduce using rule 40 (block -> { blockA .)
    OVAL            reduce using rule 40 (block -> { blockA .)
    TRIO            reduce using rule 40 (block -> { blockA .)
    QUAD            reduce using rule 40 (block -> { blockA .)
    ARC             reduce using rule 40 (block -> { blockA .)
    END             reduce using rule 40 (block -> { blockA .)
    }               reduce using rule 40 (block -> { blockA .)
    ELSE            reduce using rule 40 (block -> { blockA .)


state 195

    (20) module -> MOD # moduleID insertQuadMod moduleA endMod .

    MOD             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ID              reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    IF              reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ECHO            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    WHILE           reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    REPLAY          reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    SAMPLE          reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    #               reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ARR             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    MAT             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    PIPE            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    WHERE           reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    CLEAR           reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    OVAL            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    TRIO            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    QUAD            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ARC             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    END             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)


state 196

    (70) cycle -> WHILE gotoW ( expression ) gotoFalse block . continueGoW
    (120) continueGoW -> .

    MOD             reduce using rule 120 (continueGoW -> .)
    ID              reduce using rule 120 (continueGoW -> .)
    IF              reduce using rule 120 (continueGoW -> .)
    ECHO            reduce using rule 120 (continueGoW -> .)
    WHILE           reduce using rule 120 (continueGoW -> .)
    REPLAY          reduce using rule 120 (continueGoW -> .)
    SAMPLE          reduce using rule 120 (continueGoW -> .)
    #               reduce using rule 120 (continueGoW -> .)
    ARR             reduce using rule 120 (continueGoW -> .)
    MAT             reduce using rule 120 (continueGoW -> .)
    PIPE            reduce using rule 120 (continueGoW -> .)
    WHERE           reduce using rule 120 (continueGoW -> .)
    CLEAR           reduce using rule 120 (continueGoW -> .)
    OVAL            reduce using rule 120 (continueGoW -> .)
    TRIO            reduce using rule 120 (continueGoW -> .)
    QUAD            reduce using rule 120 (continueGoW -> .)
    ARC             reduce using rule 120 (continueGoW -> .)
    END             reduce using rule 120 (continueGoW -> .)
    }               reduce using rule 120 (continueGoW -> .)

    continueGoW                    shift and go to state 215

state 197

    (71) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .

    MOD             reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ID              reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    IF              reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ECHO            reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHILE           reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    REPLAY          reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    SAMPLE          reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    #               reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARR             reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MAT             reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    PIPE            reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHERE           reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    CLEAR           reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    OVAL            reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    TRIO            reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    QUAD            reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARC             reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    END             reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    }               reduce using rule 71 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)


state 198

    (57) pipelineA -> IN ( var_cte ) ; .

    MOD             reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    ID              reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    IF              reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    ECHO            reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    WHILE           reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    REPLAY          reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    SAMPLE          reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    #               reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    ARR             reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    MAT             reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    PIPE            reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    WHERE           reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    CLEAR           reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    OVAL            reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    TRIO            reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    QUAD            reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    ARC             reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    END             reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)
    }               reduce using rule 57 (pipelineA -> IN ( var_cte ) ; .)


state 199

    (33) callingA -> callingB ) ; .

    MOD             reduce using rule 33 (callingA -> callingB ) ; .)
    ID              reduce using rule 33 (callingA -> callingB ) ; .)
    IF              reduce using rule 33 (callingA -> callingB ) ; .)
    ECHO            reduce using rule 33 (callingA -> callingB ) ; .)
    WHILE           reduce using rule 33 (callingA -> callingB ) ; .)
    REPLAY          reduce using rule 33 (callingA -> callingB ) ; .)
    SAMPLE          reduce using rule 33 (callingA -> callingB ) ; .)
    #               reduce using rule 33 (callingA -> callingB ) ; .)
    ARR             reduce using rule 33 (callingA -> callingB ) ; .)
    MAT             reduce using rule 33 (callingA -> callingB ) ; .)
    PIPE            reduce using rule 33 (callingA -> callingB ) ; .)
    WHERE           reduce using rule 33 (callingA -> callingB ) ; .)
    CLEAR           reduce using rule 33 (callingA -> callingB ) ; .)
    OVAL            reduce using rule 33 (callingA -> callingB ) ; .)
    TRIO            reduce using rule 33 (callingA -> callingB ) ; .)
    QUAD            reduce using rule 33 (callingA -> callingB ) ; .)
    ARC             reduce using rule 33 (callingA -> callingB ) ; .)
    END             reduce using rule 33 (callingA -> callingB ) ; .)
    }               reduce using rule 33 (callingA -> callingB ) ; .)


state 200

    (37) callingC -> , . sumXparam callingB
    (39) sumXparam -> .

    (               reduce using rule 39 (sumXparam -> .)
    ID              reduce using rule 39 (sumXparam -> .)
    CTE_INTEGER     reduce using rule 39 (sumXparam -> .)
    CTE_FLOAT       reduce using rule 39 (sumXparam -> .)
    TRUE            reduce using rule 39 (sumXparam -> .)
    FALSE           reduce using rule 39 (sumXparam -> .)

    sumXparam                      shift and go to state 216

state 201

    (35) callingB -> expression checkParam callingC .

    )               reduce using rule 35 (callingB -> expression checkParam callingC .)


state 202

    (38) callingC -> empty .

    )               reduce using rule 38 (callingC -> empty .)


state 203

    (47) condition -> IF ( expression ) gotoFalse block conditionA . continueGo
    (119) continueGo -> .

    MOD             reduce using rule 119 (continueGo -> .)
    ID              reduce using rule 119 (continueGo -> .)
    IF              reduce using rule 119 (continueGo -> .)
    ECHO            reduce using rule 119 (continueGo -> .)
    WHILE           reduce using rule 119 (continueGo -> .)
    REPLAY          reduce using rule 119 (continueGo -> .)
    SAMPLE          reduce using rule 119 (continueGo -> .)
    #               reduce using rule 119 (continueGo -> .)
    ARR             reduce using rule 119 (continueGo -> .)
    MAT             reduce using rule 119 (continueGo -> .)
    PIPE            reduce using rule 119 (continueGo -> .)
    WHERE           reduce using rule 119 (continueGo -> .)
    CLEAR           reduce using rule 119 (continueGo -> .)
    OVAL            reduce using rule 119 (continueGo -> .)
    TRIO            reduce using rule 119 (continueGo -> .)
    QUAD            reduce using rule 119 (continueGo -> .)
    ARC             reduce using rule 119 (continueGo -> .)
    END             reduce using rule 119 (continueGo -> .)
    }               reduce using rule 119 (continueGo -> .)

    continueGo                     shift and go to state 217

state 204

    (49) conditionA -> empty .

    MOD             reduce using rule 49 (conditionA -> empty .)
    ID              reduce using rule 49 (conditionA -> empty .)
    IF              reduce using rule 49 (conditionA -> empty .)
    ECHO            reduce using rule 49 (conditionA -> empty .)
    WHILE           reduce using rule 49 (conditionA -> empty .)
    REPLAY          reduce using rule 49 (conditionA -> empty .)
    SAMPLE          reduce using rule 49 (conditionA -> empty .)
    #               reduce using rule 49 (conditionA -> empty .)
    ARR             reduce using rule 49 (conditionA -> empty .)
    MAT             reduce using rule 49 (conditionA -> empty .)
    PIPE            reduce using rule 49 (conditionA -> empty .)
    WHERE           reduce using rule 49 (conditionA -> empty .)
    CLEAR           reduce using rule 49 (conditionA -> empty .)
    OVAL            reduce using rule 49 (conditionA -> empty .)
    TRIO            reduce using rule 49 (conditionA -> empty .)
    QUAD            reduce using rule 49 (conditionA -> empty .)
    ARC             reduce using rule 49 (conditionA -> empty .)
    END             reduce using rule 49 (conditionA -> empty .)
    }               reduce using rule 49 (conditionA -> empty .)


state 205

    (48) conditionA -> ELSE . gotoE block
    (116) gotoE -> .

    {               reduce using rule 116 (gotoE -> .)

    gotoE                          shift and go to state 218

state 206

    (53) array -> ARR typeDim ID [ CTE_INTEGER ] ; .

    ID              reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    IF              reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    #               reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    PIPE            reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHERE           reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    CLEAR           reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    }               reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    END             reduce using rule 53 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)


state 207

    (68) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHILE           reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARR             reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    MAT             reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    PIPE            reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHERE           reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    CLEAR           reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 68 (commandA -> ON move exp CTE_INTEGER color ; .)


state 208

    (54) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 219


state 209

    (21) moduleA -> ( vars ) . block
    (40) block -> . { blockA

    {               shift and go to state 168

    block                          shift and go to state 220

state 210

    (24) vars -> type ID . varsA
    (25) varsA -> . , vars
    (26) varsA -> . empty
    (123) empty -> .

    ,               shift and go to state 222
    )               reduce using rule 123 (empty -> .)

    varsA                          shift and go to state 221
    empty                          shift and go to state 223

state 211

    (45) blockC -> empty .

    }               reduce using rule 45 (blockC -> empty .)


state 212

    (43) blockB -> statute blockC .

    }               reduce using rule 43 (blockB -> statute blockC .)


state 213

    (44) blockC -> blockB .

    }               reduce using rule 44 (blockC -> blockB .)


state 214

    (41) blockA -> blockB } .

    MOD             reduce using rule 41 (blockA -> blockB } .)
    ID              reduce using rule 41 (blockA -> blockB } .)
    IF              reduce using rule 41 (blockA -> blockB } .)
    ECHO            reduce using rule 41 (blockA -> blockB } .)
    WHILE           reduce using rule 41 (blockA -> blockB } .)
    REPLAY          reduce using rule 41 (blockA -> blockB } .)
    SAMPLE          reduce using rule 41 (blockA -> blockB } .)
    #               reduce using rule 41 (blockA -> blockB } .)
    ARR             reduce using rule 41 (blockA -> blockB } .)
    MAT             reduce using rule 41 (blockA -> blockB } .)
    PIPE            reduce using rule 41 (blockA -> blockB } .)
    WHERE           reduce using rule 41 (blockA -> blockB } .)
    CLEAR           reduce using rule 41 (blockA -> blockB } .)
    OVAL            reduce using rule 41 (blockA -> blockB } .)
    TRIO            reduce using rule 41 (blockA -> blockB } .)
    QUAD            reduce using rule 41 (blockA -> blockB } .)
    ARC             reduce using rule 41 (blockA -> blockB } .)
    END             reduce using rule 41 (blockA -> blockB } .)
    ELSE            reduce using rule 41 (blockA -> blockB } .)
    }               reduce using rule 41 (blockA -> blockB } .)


state 215

    (70) cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .

    MOD             reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ID              reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    IF              reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ECHO            reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHILE           reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    REPLAY          reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    SAMPLE          reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    #               reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARR             reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    MAT             reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    PIPE            reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHERE           reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    CLEAR           reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    OVAL            reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    TRIO            reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    QUAD            reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARC             reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    END             reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    }               reduce using rule 70 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)


state 216

    (37) callingC -> , sumXparam . callingB
    (35) callingB -> . expression checkParam callingC
    (75) expression -> . exp = = exp
    (76) expression -> . exp < > exp
    (77) expression -> . exp < = exp
    (78) expression -> . exp > = exp
    (79) expression -> . exp > exp
    (80) expression -> . exp < exp
    (81) expression -> . exp AND exp
    (82) expression -> . exp OR exp
    (83) expression -> . exp empty
    (84) exp -> . exp + exp
    (85) exp -> . exp - exp
    (86) exp -> . exp * exp
    (87) exp -> . exp / exp
    (88) exp -> . factor empty
    (89) factor -> . ( expression )
    (90) factor -> . var_cte
    (110) var_cte -> . ID
    (111) var_cte -> . CTE_INTEGER
    (112) var_cte -> . CTE_FLOAT
    (113) var_cte -> . TRUE
    (114) var_cte -> . FALSE

    (               shift and go to state 39
    ID              shift and go to state 46
    CTE_INTEGER     shift and go to state 41
    CTE_FLOAT       shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 45

    var_cte                        shift and go to state 40
    callingB                       shift and go to state 224
    exp                            shift and go to state 59
    factor                         shift and go to state 44
    expression                     shift and go to state 156

state 217

    (47) condition -> IF ( expression ) gotoFalse block conditionA continueGo .

    MOD             reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ID              reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    IF              reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ECHO            reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHILE           reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    REPLAY          reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    SAMPLE          reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    #               reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARR             reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MAT             reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    PIPE            reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHERE           reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    CLEAR           reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    OVAL            reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    TRIO            reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    QUAD            reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARC             reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    END             reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    }               reduce using rule 47 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)


state 218

    (48) conditionA -> ELSE gotoE . block
    (40) block -> . { blockA

    {               shift and go to state 168

    block                          shift and go to state 225

state 219

    (54) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER . ] ;

    ]               shift and go to state 226


state 220

    (21) moduleA -> ( vars ) block .

    MOD             reduce using rule 21 (moduleA -> ( vars ) block .)
    ID              reduce using rule 21 (moduleA -> ( vars ) block .)
    IF              reduce using rule 21 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 21 (moduleA -> ( vars ) block .)
    WHILE           reduce using rule 21 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 21 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 21 (moduleA -> ( vars ) block .)
    #               reduce using rule 21 (moduleA -> ( vars ) block .)
    ARR             reduce using rule 21 (moduleA -> ( vars ) block .)
    MAT             reduce using rule 21 (moduleA -> ( vars ) block .)
    PIPE            reduce using rule 21 (moduleA -> ( vars ) block .)
    WHERE           reduce using rule 21 (moduleA -> ( vars ) block .)
    CLEAR           reduce using rule 21 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 21 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 21 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 21 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 21 (moduleA -> ( vars ) block .)
    END             reduce using rule 21 (moduleA -> ( vars ) block .)


state 221

    (24) vars -> type ID varsA .

    )               reduce using rule 24 (vars -> type ID varsA .)


state 222

    (25) varsA -> , . vars
    (24) vars -> . type ID varsA
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOL

    INT             shift and go to state 188
    FLOAT           shift and go to state 187
    BOOL            shift and go to state 189

    type                           shift and go to state 190
    vars                           shift and go to state 227

state 223

    (26) varsA -> empty .

    )               reduce using rule 26 (varsA -> empty .)


state 224

    (37) callingC -> , sumXparam callingB .

    )               reduce using rule 37 (callingC -> , sumXparam callingB .)


state 225

    (48) conditionA -> ELSE gotoE block .

    MOD             reduce using rule 48 (conditionA -> ELSE gotoE block .)
    ID              reduce using rule 48 (conditionA -> ELSE gotoE block .)
    IF              reduce using rule 48 (conditionA -> ELSE gotoE block .)
    ECHO            reduce using rule 48 (conditionA -> ELSE gotoE block .)
    WHILE           reduce using rule 48 (conditionA -> ELSE gotoE block .)
    REPLAY          reduce using rule 48 (conditionA -> ELSE gotoE block .)
    SAMPLE          reduce using rule 48 (conditionA -> ELSE gotoE block .)
    #               reduce using rule 48 (conditionA -> ELSE gotoE block .)
    ARR             reduce using rule 48 (conditionA -> ELSE gotoE block .)
    MAT             reduce using rule 48 (conditionA -> ELSE gotoE block .)
    PIPE            reduce using rule 48 (conditionA -> ELSE gotoE block .)
    WHERE           reduce using rule 48 (conditionA -> ELSE gotoE block .)
    CLEAR           reduce using rule 48 (conditionA -> ELSE gotoE block .)
    OVAL            reduce using rule 48 (conditionA -> ELSE gotoE block .)
    TRIO            reduce using rule 48 (conditionA -> ELSE gotoE block .)
    QUAD            reduce using rule 48 (conditionA -> ELSE gotoE block .)
    ARC             reduce using rule 48 (conditionA -> ELSE gotoE block .)
    END             reduce using rule 48 (conditionA -> ELSE gotoE block .)
    }               reduce using rule 48 (conditionA -> ELSE gotoE block .)


state 226

    (54) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] . ;

    ;               shift and go to state 228


state 227

    (25) varsA -> , vars .

    )               reduce using rule 25 (varsA -> , vars .)


state 228

    (54) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .

    MOD             reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ID              reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    IF              reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    #               reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    PIPE            reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHERE           reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    CLEAR           reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    END             reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    }               reduce using rule 54 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)

