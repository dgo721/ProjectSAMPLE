Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> read
Rule 12    statute -> write
Rule 13    statute -> cycle
Rule 14    statute -> repeat
Rule 15    statute -> command
Rule 16    statute -> calling
Rule 17    statute -> array
Rule 18    statute -> matrix
Rule 19    statute -> return
Rule 20    typeMod -> INT
Rule 21    typeMod -> FLOAT
Rule 22    typeMod -> BOOL
Rule 23    typeMod -> empty
Rule 24    addMod -> <empty>
Rule 25    module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
Rule 26    moduleA -> ( vars ) block
Rule 27    moduleA -> block
Rule 28    moduleID -> ID
Rule 29    vars -> type ID varsA
Rule 30    varsA -> , vars
Rule 31    varsA -> empty
Rule 32    type -> INT
Rule 33    type -> FLOAT
Rule 34    type -> BOOL
Rule 35    id -> ID [ sumdim exp ] [ sumdim exp ]
Rule 36    id -> ID [ sumdim exp ]
Rule 37    id -> callID # calling2
Rule 38    id -> ID empty
Rule 39    sumdim -> <empty>
Rule 40    calling -> # callID calling2 ;
Rule 41    calling2 -> ( maincalling )
Rule 42    maincalling -> insertEra callingA
Rule 43    callID -> ID
Rule 44    insertEra -> <empty>
Rule 45    callingA -> callingB
Rule 46    callingA -> empty
Rule 47    callingB -> exp checkParam callingC
Rule 48    checkParam -> <empty>
Rule 49    callingC -> , sumXparam callingB
Rule 50    callingC -> empty
Rule 51    sumXparam -> <empty>
Rule 52    block -> { blockA
Rule 53    blockA -> blockB }
Rule 54    blockA -> }
Rule 55    blockB -> statute blockC
Rule 56    blockC -> blockB
Rule 57    blockC -> empty
Rule 58    assign -> id = expression ;
Rule 59    condition -> IF ( expression ) gotoFalse block conditionA continueGo
Rule 60    conditionA -> ELSE gotoE block
Rule 61    conditionA -> empty
Rule 62    read -> INPUT typeDim ID # ;
Rule 63    write -> ECHO ( writeA writeB ) ;
Rule 64    writeA -> expression
Rule 65    writeA -> CTE_STRING
Rule 66    writeB -> , writeA
Rule 67    writeB -> empty
Rule 68    array -> ARR typeDim ID [ CTE_INTEGER ] ;
Rule 69    matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
Rule 70    typeDim -> INT
Rule 71    typeDim -> FLOAT
Rule 72    typeDim -> BOOL
Rule 73    command -> figure exp exp color ;
Rule 74    command -> SAMPLE commandA
Rule 75    commandA -> ON move exp CTE_INTEGER color ;
Rule 76    commandA -> OFF move exp ;
Rule 77    cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW
Rule 78    repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ;
Rule 79    repeatA -> command repeatB
Rule 80    repeatB -> repeatA
Rule 81    repeatB -> empty
Rule 82    expression -> exp = = exp
Rule 83    expression -> exp < > exp
Rule 84    expression -> exp < = exp
Rule 85    expression -> exp > = exp
Rule 86    expression -> exp > exp
Rule 87    expression -> exp < exp
Rule 88    expression -> exp AND exp
Rule 89    expression -> exp OR exp
Rule 90    expression -> exp empty
Rule 91    exp -> exp + exp
Rule 92    exp -> exp - exp
Rule 93    exp -> exp * exp
Rule 94    exp -> exp / exp
Rule 95    exp -> factor empty
Rule 96    return -> RETURN exp ;
Rule 97    factor -> ( expression )
Rule 98    factor -> var_cte
Rule 99    figure -> OVAL
Rule 100   figure -> TRIO
Rule 101   figure -> QUAD
Rule 102   figure -> ARC
Rule 103   move -> UP
Rule 104   move -> DOWN
Rule 105   move -> LEFT
Rule 106   move -> RIGHT
Rule 107   color -> RED
Rule 108   color -> YELLOW
Rule 109   color -> BLUE
Rule 110   color -> GREEN
Rule 111   color -> BLACK
Rule 112   color -> WHITE
Rule 113   color -> ORANGE
Rule 114   color -> PURPLE
Rule 115   color -> CYAN
Rule 116   var_cte -> id
Rule 117   var_cte -> CTE_INTEGER
Rule 118   var_cte -> CTE_FLOAT
Rule 119   var_cte -> TRUE
Rule 120   var_cte -> FALSE
Rule 121   gotoFalse -> <empty>
Rule 122   gotoE -> <empty>
Rule 123   gotoW -> <empty>
Rule 124   gotoR -> <empty>
Rule 125   continueGo -> <empty>
Rule 126   continueGoW -> <empty>
Rule 127   insertQuadMod -> <empty>
Rule 128   endMod -> <empty>
Rule 129   empty -> <empty>

Terminals, with rules where they appear

#                    : 25 37 40 62
(                    : 26 41 59 63 77 97
)                    : 26 41 59 63 77 97
*                    : 93
+                    : 91
,                    : 30 49 66
-                    : 92
/                    : 94
;                    : 40 58 62 63 68 69 73 75 76 78 96
<                    : 83 84 87
=                    : 58 82 82 84 85
>                    : 83 85 86
AND                  : 88
ARC                  : 102
ARR                  : 68
BLACK                : 111
BLUE                 : 109
BOOL                 : 22 34 72
CTE_FLOAT            : 118
CTE_INTEGER          : 68 69 69 75 78 117
CTE_STRING           : 65
CYAN                 : 115
DOWN                 : 104
ECHO                 : 63
ELSE                 : 60
END                  : 2 3
FALSE                : 120
FLOAT                : 21 33 71
GREEN                : 110
ID                   : 28 29 35 36 38 43 62 68 69
IF                   : 59
INIT                 : 1
INPUT                : 62
INT                  : 20 32 70
LEFT                 : 105
MAT                  : 69
MOD                  : 25
OFF                  : 76
ON                   : 75
OR                   : 89
ORANGE               : 113
OVAL                 : 99
PURPLE               : 114
QUAD                 : 101
RED                  : 107
REPLAY               : 78
RETURN               : 96
RIGHT                : 106
SAMPLE               : 74
TRIO                 : 100
TRUE                 : 119
UP                   : 103
WHILE                : 77
WHITE                : 112
YELLOW               : 108
[                    : 35 35 36 68 69 69 78
]                    : 35 35 36 68 69 69 78
error                : 
{                    : 52
}                    : 53 54

Nonterminals, with rules where they appear

addMod               : 25
array                : 17
assign               : 9
block                : 26 27 59 60 77
blockA               : 52
blockB               : 53 56
blockC               : 55
callID               : 37 40
calling              : 16
calling2             : 37 40
callingA             : 42
callingB             : 45 49
callingC             : 47
checkParam           : 47
color                : 73 75
command              : 15 79
commandA             : 74
condition            : 10
conditionA           : 59
continueGo           : 59
continueGoW          : 77
cycle                : 13
empty                : 6 23 31 38 46 50 57 61 67 81 90 95
endMod               : 25
exp                  : 35 35 36 47 73 73 75 76 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 91 91 92 92 93 93 94 94 96
expression           : 58 59 64 77 97
factor               : 95
figure               : 73
gotoE                : 60
gotoFalse            : 59 77
gotoR                : 78
gotoW                : 77
id                   : 58 116
insertEra            : 42
insertQuadMod        : 25
maincalling          : 41
matrix               : 18
module               : 8
moduleA              : 25
moduleID             : 25
move                 : 75 76
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
read                 : 11
repeat               : 14
repeatA              : 78 80
repeatB              : 79
return               : 19
statute              : 7 55
sumXparam            : 49
sumdim               : 35 35 36
type                 : 29
typeDim              : 62 68 69
typeMod              : 25
var_cte              : 98
vars                 : 26 30
varsA                : 29
workspace            : 4
write                : 12
writeA               : 63 66
writeB               : 63

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . return
    (25) module -> . MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
    (58) assign -> . id = expression ;
    (59) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (62) read -> . INPUT typeDim ID # ;
    (63) write -> . ECHO ( writeA writeB ) ;
    (77) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (78) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (73) command -> . figure exp exp color ;
    (74) command -> . SAMPLE commandA
    (40) calling -> . # callID calling2 ;
    (68) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (69) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (96) return -> . RETURN exp ;
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (99) figure -> . OVAL
    (100) figure -> . TRIO
    (101) figure -> . QUAD
    (102) figure -> . ARC
    (43) callID -> . ID

    END             shift and go to state 20
    MOD             shift and go to state 38
    IF              shift and go to state 17
    INPUT           shift and go to state 26
    ECHO            shift and go to state 22
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 23
    #               shift and go to state 14
    ARR             shift and go to state 31
    MAT             shift and go to state 32
    RETURN          shift and go to state 3
    ID              shift and go to state 27
    OVAL            shift and go to state 7
    TRIO            shift and go to state 18
    QUAD            shift and go to state 10
    ARC             shift and go to state 34

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    module                         shift and go to state 6
    array                          shift and go to state 12
    id                             shift and go to state 13
    matrix                         shift and go to state 15
    write                          shift and go to state 16
    condition                      shift and go to state 28
    repeat                         shift and go to state 19
    return                         shift and go to state 11
    read                           shift and go to state 21
    programA                       shift and go to state 24
    programB                       shift and go to state 25
    cycle                          shift and go to state 29
    statute                        shift and go to state 30
    calling                        shift and go to state 33
    command                        shift and go to state 35
    workspace                      shift and go to state 36
    assign                         shift and go to state 37

state 2

    (0) S' -> program .



state 3

    (96) return -> RETURN . exp ;
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 47
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 4

    (73) command -> figure . exp exp color ;
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 48
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 5

    (37) id -> callID . # calling2

    #               shift and go to state 49


state 6

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    INPUT           reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    WHILE           reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    ARR             reduce using rule 8 (workspace -> module .)
    MAT             reduce using rule 8 (workspace -> module .)
    RETURN          reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 7

    (99) figure -> OVAL .

    (               reduce using rule 99 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 99 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 99 (figure -> OVAL .)
    TRUE            reduce using rule 99 (figure -> OVAL .)
    FALSE           reduce using rule 99 (figure -> OVAL .)
    ID              reduce using rule 99 (figure -> OVAL .)


state 8

    (77) cycle -> WHILE . gotoW ( expression ) gotoFalse block continueGoW
    (123) gotoW -> .

    (               reduce using rule 123 (gotoW -> .)

    gotoW                          shift and go to state 50

state 9

    (78) repeat -> REPLAY . CTE_INTEGER gotoR [ repeatA ] ;

    CTE_INTEGER     shift and go to state 51


state 10

    (101) figure -> QUAD .

    (               reduce using rule 101 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 101 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 101 (figure -> QUAD .)
    TRUE            reduce using rule 101 (figure -> QUAD .)
    FALSE           reduce using rule 101 (figure -> QUAD .)
    ID              reduce using rule 101 (figure -> QUAD .)


state 11

    (19) statute -> return .

    IF              reduce using rule 19 (statute -> return .)
    INPUT           reduce using rule 19 (statute -> return .)
    ECHO            reduce using rule 19 (statute -> return .)
    WHILE           reduce using rule 19 (statute -> return .)
    REPLAY          reduce using rule 19 (statute -> return .)
    SAMPLE          reduce using rule 19 (statute -> return .)
    #               reduce using rule 19 (statute -> return .)
    ARR             reduce using rule 19 (statute -> return .)
    MAT             reduce using rule 19 (statute -> return .)
    RETURN          reduce using rule 19 (statute -> return .)
    ID              reduce using rule 19 (statute -> return .)
    OVAL            reduce using rule 19 (statute -> return .)
    TRIO            reduce using rule 19 (statute -> return .)
    QUAD            reduce using rule 19 (statute -> return .)
    ARC             reduce using rule 19 (statute -> return .)
    }               reduce using rule 19 (statute -> return .)
    MOD             reduce using rule 19 (statute -> return .)
    END             reduce using rule 19 (statute -> return .)


state 12

    (17) statute -> array .

    IF              reduce using rule 17 (statute -> array .)
    INPUT           reduce using rule 17 (statute -> array .)
    ECHO            reduce using rule 17 (statute -> array .)
    WHILE           reduce using rule 17 (statute -> array .)
    REPLAY          reduce using rule 17 (statute -> array .)
    SAMPLE          reduce using rule 17 (statute -> array .)
    #               reduce using rule 17 (statute -> array .)
    ARR             reduce using rule 17 (statute -> array .)
    MAT             reduce using rule 17 (statute -> array .)
    RETURN          reduce using rule 17 (statute -> array .)
    ID              reduce using rule 17 (statute -> array .)
    OVAL            reduce using rule 17 (statute -> array .)
    TRIO            reduce using rule 17 (statute -> array .)
    QUAD            reduce using rule 17 (statute -> array .)
    ARC             reduce using rule 17 (statute -> array .)
    }               reduce using rule 17 (statute -> array .)
    MOD             reduce using rule 17 (statute -> array .)
    END             reduce using rule 17 (statute -> array .)


state 13

    (58) assign -> id . = expression ;

    =               shift and go to state 52


state 14

    (40) calling -> # . callID calling2 ;
    (43) callID -> . ID

    ID              shift and go to state 54

    callID                         shift and go to state 53

state 15

    (18) statute -> matrix .

    IF              reduce using rule 18 (statute -> matrix .)
    INPUT           reduce using rule 18 (statute -> matrix .)
    ECHO            reduce using rule 18 (statute -> matrix .)
    WHILE           reduce using rule 18 (statute -> matrix .)
    REPLAY          reduce using rule 18 (statute -> matrix .)
    SAMPLE          reduce using rule 18 (statute -> matrix .)
    #               reduce using rule 18 (statute -> matrix .)
    ARR             reduce using rule 18 (statute -> matrix .)
    MAT             reduce using rule 18 (statute -> matrix .)
    RETURN          reduce using rule 18 (statute -> matrix .)
    ID              reduce using rule 18 (statute -> matrix .)
    OVAL            reduce using rule 18 (statute -> matrix .)
    TRIO            reduce using rule 18 (statute -> matrix .)
    QUAD            reduce using rule 18 (statute -> matrix .)
    ARC             reduce using rule 18 (statute -> matrix .)
    }               reduce using rule 18 (statute -> matrix .)
    MOD             reduce using rule 18 (statute -> matrix .)
    END             reduce using rule 18 (statute -> matrix .)


state 16

    (12) statute -> write .

    IF              reduce using rule 12 (statute -> write .)
    INPUT           reduce using rule 12 (statute -> write .)
    ECHO            reduce using rule 12 (statute -> write .)
    WHILE           reduce using rule 12 (statute -> write .)
    REPLAY          reduce using rule 12 (statute -> write .)
    SAMPLE          reduce using rule 12 (statute -> write .)
    #               reduce using rule 12 (statute -> write .)
    ARR             reduce using rule 12 (statute -> write .)
    MAT             reduce using rule 12 (statute -> write .)
    RETURN          reduce using rule 12 (statute -> write .)
    ID              reduce using rule 12 (statute -> write .)
    OVAL            reduce using rule 12 (statute -> write .)
    TRIO            reduce using rule 12 (statute -> write .)
    QUAD            reduce using rule 12 (statute -> write .)
    ARC             reduce using rule 12 (statute -> write .)
    }               reduce using rule 12 (statute -> write .)
    MOD             reduce using rule 12 (statute -> write .)
    END             reduce using rule 12 (statute -> write .)


state 17

    (59) condition -> IF . ( expression ) gotoFalse block conditionA continueGo

    (               shift and go to state 55


state 18

    (100) figure -> TRIO .

    (               reduce using rule 100 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 100 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 100 (figure -> TRIO .)
    TRUE            reduce using rule 100 (figure -> TRIO .)
    FALSE           reduce using rule 100 (figure -> TRIO .)
    ID              reduce using rule 100 (figure -> TRIO .)


state 19

    (14) statute -> repeat .

    IF              reduce using rule 14 (statute -> repeat .)
    INPUT           reduce using rule 14 (statute -> repeat .)
    ECHO            reduce using rule 14 (statute -> repeat .)
    WHILE           reduce using rule 14 (statute -> repeat .)
    REPLAY          reduce using rule 14 (statute -> repeat .)
    SAMPLE          reduce using rule 14 (statute -> repeat .)
    #               reduce using rule 14 (statute -> repeat .)
    ARR             reduce using rule 14 (statute -> repeat .)
    MAT             reduce using rule 14 (statute -> repeat .)
    RETURN          reduce using rule 14 (statute -> repeat .)
    ID              reduce using rule 14 (statute -> repeat .)
    OVAL            reduce using rule 14 (statute -> repeat .)
    TRIO            reduce using rule 14 (statute -> repeat .)
    QUAD            reduce using rule 14 (statute -> repeat .)
    ARC             reduce using rule 14 (statute -> repeat .)
    }               reduce using rule 14 (statute -> repeat .)
    MOD             reduce using rule 14 (statute -> repeat .)
    END             reduce using rule 14 (statute -> repeat .)


state 20

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 21

    (11) statute -> read .

    IF              reduce using rule 11 (statute -> read .)
    INPUT           reduce using rule 11 (statute -> read .)
    ECHO            reduce using rule 11 (statute -> read .)
    WHILE           reduce using rule 11 (statute -> read .)
    REPLAY          reduce using rule 11 (statute -> read .)
    SAMPLE          reduce using rule 11 (statute -> read .)
    #               reduce using rule 11 (statute -> read .)
    ARR             reduce using rule 11 (statute -> read .)
    MAT             reduce using rule 11 (statute -> read .)
    RETURN          reduce using rule 11 (statute -> read .)
    ID              reduce using rule 11 (statute -> read .)
    OVAL            reduce using rule 11 (statute -> read .)
    TRIO            reduce using rule 11 (statute -> read .)
    QUAD            reduce using rule 11 (statute -> read .)
    ARC             reduce using rule 11 (statute -> read .)
    }               reduce using rule 11 (statute -> read .)
    MOD             reduce using rule 11 (statute -> read .)
    END             reduce using rule 11 (statute -> read .)


state 22

    (63) write -> ECHO . ( writeA writeB ) ;

    (               shift and go to state 56


state 23

    (74) command -> SAMPLE . commandA
    (75) commandA -> . ON move exp CTE_INTEGER color ;
    (76) commandA -> . OFF move exp ;

    ON              shift and go to state 59
    OFF             shift and go to state 58

    commandA                       shift and go to state 57

state 24

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 25

    (2) programA -> programB . END

    END             shift and go to state 60


state 26

    (62) read -> INPUT . typeDim ID # ;
    (70) typeDim -> . INT
    (71) typeDim -> . FLOAT
    (72) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 63

state 27

    (35) id -> ID . [ sumdim exp ] [ sumdim exp ]
    (36) id -> ID . [ sumdim exp ]
    (38) id -> ID . empty
    (43) callID -> ID .
    (129) empty -> .

    [               shift and go to state 65
    #               reduce using rule 43 (callID -> ID .)
    =               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    +               reduce using rule 129 (empty -> .)
    -               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    CTE_INTEGER     reduce using rule 129 (empty -> .)
    CTE_FLOAT       reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    >               reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    RED             reduce using rule 129 (empty -> .)
    YELLOW          reduce using rule 129 (empty -> .)
    BLUE            reduce using rule 129 (empty -> .)
    GREEN           reduce using rule 129 (empty -> .)
    BLACK           reduce using rule 129 (empty -> .)
    WHITE           reduce using rule 129 (empty -> .)
    ORANGE          reduce using rule 129 (empty -> .)
    PURPLE          reduce using rule 129 (empty -> .)
    CYAN            reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)

    empty                          shift and go to state 66

state 28

    (10) statute -> condition .

    IF              reduce using rule 10 (statute -> condition .)
    INPUT           reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    WHILE           reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    ARR             reduce using rule 10 (statute -> condition .)
    MAT             reduce using rule 10 (statute -> condition .)
    RETURN          reduce using rule 10 (statute -> condition .)
    ID              reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)
    MOD             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)


state 29

    (13) statute -> cycle .

    IF              reduce using rule 13 (statute -> cycle .)
    INPUT           reduce using rule 13 (statute -> cycle .)
    ECHO            reduce using rule 13 (statute -> cycle .)
    WHILE           reduce using rule 13 (statute -> cycle .)
    REPLAY          reduce using rule 13 (statute -> cycle .)
    SAMPLE          reduce using rule 13 (statute -> cycle .)
    #               reduce using rule 13 (statute -> cycle .)
    ARR             reduce using rule 13 (statute -> cycle .)
    MAT             reduce using rule 13 (statute -> cycle .)
    RETURN          reduce using rule 13 (statute -> cycle .)
    ID              reduce using rule 13 (statute -> cycle .)
    OVAL            reduce using rule 13 (statute -> cycle .)
    TRIO            reduce using rule 13 (statute -> cycle .)
    QUAD            reduce using rule 13 (statute -> cycle .)
    ARC             reduce using rule 13 (statute -> cycle .)
    }               reduce using rule 13 (statute -> cycle .)
    MOD             reduce using rule 13 (statute -> cycle .)
    END             reduce using rule 13 (statute -> cycle .)


state 30

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    INPUT           reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    WHILE           reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    ARR             reduce using rule 7 (workspace -> statute .)
    MAT             reduce using rule 7 (workspace -> statute .)
    RETURN          reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 31

    (68) array -> ARR . typeDim ID [ CTE_INTEGER ] ;
    (70) typeDim -> . INT
    (71) typeDim -> . FLOAT
    (72) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 67

state 32

    (69) matrix -> MAT . typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (70) typeDim -> . INT
    (71) typeDim -> . FLOAT
    (72) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 68

state 33

    (16) statute -> calling .

    IF              reduce using rule 16 (statute -> calling .)
    INPUT           reduce using rule 16 (statute -> calling .)
    ECHO            reduce using rule 16 (statute -> calling .)
    WHILE           reduce using rule 16 (statute -> calling .)
    REPLAY          reduce using rule 16 (statute -> calling .)
    SAMPLE          reduce using rule 16 (statute -> calling .)
    #               reduce using rule 16 (statute -> calling .)
    ARR             reduce using rule 16 (statute -> calling .)
    MAT             reduce using rule 16 (statute -> calling .)
    RETURN          reduce using rule 16 (statute -> calling .)
    ID              reduce using rule 16 (statute -> calling .)
    OVAL            reduce using rule 16 (statute -> calling .)
    TRIO            reduce using rule 16 (statute -> calling .)
    QUAD            reduce using rule 16 (statute -> calling .)
    ARC             reduce using rule 16 (statute -> calling .)
    }               reduce using rule 16 (statute -> calling .)
    MOD             reduce using rule 16 (statute -> calling .)
    END             reduce using rule 16 (statute -> calling .)


state 34

    (102) figure -> ARC .

    (               reduce using rule 102 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 102 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 102 (figure -> ARC .)
    TRUE            reduce using rule 102 (figure -> ARC .)
    FALSE           reduce using rule 102 (figure -> ARC .)
    ID              reduce using rule 102 (figure -> ARC .)


state 35

    (15) statute -> command .

    IF              reduce using rule 15 (statute -> command .)
    INPUT           reduce using rule 15 (statute -> command .)
    ECHO            reduce using rule 15 (statute -> command .)
    WHILE           reduce using rule 15 (statute -> command .)
    REPLAY          reduce using rule 15 (statute -> command .)
    SAMPLE          reduce using rule 15 (statute -> command .)
    #               reduce using rule 15 (statute -> command .)
    ARR             reduce using rule 15 (statute -> command .)
    MAT             reduce using rule 15 (statute -> command .)
    RETURN          reduce using rule 15 (statute -> command .)
    ID              reduce using rule 15 (statute -> command .)
    OVAL            reduce using rule 15 (statute -> command .)
    TRIO            reduce using rule 15 (statute -> command .)
    QUAD            reduce using rule 15 (statute -> command .)
    ARC             reduce using rule 15 (statute -> command .)
    }               reduce using rule 15 (statute -> command .)
    MOD             reduce using rule 15 (statute -> command .)
    END             reduce using rule 15 (statute -> command .)


state 36

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (129) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . return
    (25) module -> . MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
    (58) assign -> . id = expression ;
    (59) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (62) read -> . INPUT typeDim ID # ;
    (63) write -> . ECHO ( writeA writeB ) ;
    (77) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (78) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (73) command -> . figure exp exp color ;
    (74) command -> . SAMPLE commandA
    (40) calling -> . # callID calling2 ;
    (68) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (69) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (96) return -> . RETURN exp ;
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (99) figure -> . OVAL
    (100) figure -> . TRIO
    (101) figure -> . QUAD
    (102) figure -> . ARC
    (43) callID -> . ID

    END             reduce using rule 129 (empty -> .)
    MOD             shift and go to state 38
    IF              shift and go to state 17
    INPUT           shift and go to state 26
    ECHO            shift and go to state 22
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 23
    #               shift and go to state 14
    ARR             shift and go to state 31
    MAT             shift and go to state 32
    RETURN          shift and go to state 3
    ID              shift and go to state 27
    OVAL            shift and go to state 7
    TRIO            shift and go to state 18
    QUAD            shift and go to state 10
    ARC             shift and go to state 34

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    module                         shift and go to state 6
    array                          shift and go to state 12
    id                             shift and go to state 13
    matrix                         shift and go to state 15
    write                          shift and go to state 16
    condition                      shift and go to state 28
    empty                          shift and go to state 69
    repeat                         shift and go to state 19
    return                         shift and go to state 11
    read                           shift and go to state 21
    programB                       shift and go to state 70
    programC                       shift and go to state 71
    cycle                          shift and go to state 29
    statute                        shift and go to state 30
    calling                        shift and go to state 33
    command                        shift and go to state 35
    workspace                      shift and go to state 36
    assign                         shift and go to state 37

state 37

    (9) statute -> assign .

    IF              reduce using rule 9 (statute -> assign .)
    INPUT           reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    WHILE           reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    ARR             reduce using rule 9 (statute -> assign .)
    MAT             reduce using rule 9 (statute -> assign .)
    RETURN          reduce using rule 9 (statute -> assign .)
    ID              reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)
    MOD             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)


state 38

    (25) module -> MOD . typeMod # moduleID addMod insertQuadMod moduleA endMod
    (20) typeMod -> . INT
    (21) typeMod -> . FLOAT
    (22) typeMod -> . BOOL
    (23) typeMod -> . empty
    (129) empty -> .

    INT             shift and go to state 73
    FLOAT           shift and go to state 74
    BOOL            shift and go to state 75
    #               reduce using rule 129 (empty -> .)

    typeMod                        shift and go to state 72
    empty                          shift and go to state 76

state 39

    (98) factor -> var_cte .

    +               reduce using rule 98 (factor -> var_cte .)
    -               reduce using rule 98 (factor -> var_cte .)
    *               reduce using rule 98 (factor -> var_cte .)
    /               reduce using rule 98 (factor -> var_cte .)
    (               reduce using rule 98 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 98 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 98 (factor -> var_cte .)
    TRUE            reduce using rule 98 (factor -> var_cte .)
    FALSE           reduce using rule 98 (factor -> var_cte .)
    ID              reduce using rule 98 (factor -> var_cte .)
    ;               reduce using rule 98 (factor -> var_cte .)
    =               reduce using rule 98 (factor -> var_cte .)
    <               reduce using rule 98 (factor -> var_cte .)
    >               reduce using rule 98 (factor -> var_cte .)
    AND             reduce using rule 98 (factor -> var_cte .)
    OR              reduce using rule 98 (factor -> var_cte .)
    )               reduce using rule 98 (factor -> var_cte .)
    RED             reduce using rule 98 (factor -> var_cte .)
    YELLOW          reduce using rule 98 (factor -> var_cte .)
    BLUE            reduce using rule 98 (factor -> var_cte .)
    GREEN           reduce using rule 98 (factor -> var_cte .)
    BLACK           reduce using rule 98 (factor -> var_cte .)
    WHITE           reduce using rule 98 (factor -> var_cte .)
    ORANGE          reduce using rule 98 (factor -> var_cte .)
    PURPLE          reduce using rule 98 (factor -> var_cte .)
    CYAN            reduce using rule 98 (factor -> var_cte .)
    ,               reduce using rule 98 (factor -> var_cte .)
    ]               reduce using rule 98 (factor -> var_cte .)


state 40

    (119) var_cte -> TRUE .

    +               reduce using rule 119 (var_cte -> TRUE .)
    -               reduce using rule 119 (var_cte -> TRUE .)
    *               reduce using rule 119 (var_cte -> TRUE .)
    /               reduce using rule 119 (var_cte -> TRUE .)
    ,               reduce using rule 119 (var_cte -> TRUE .)
    )               reduce using rule 119 (var_cte -> TRUE .)
    ;               reduce using rule 119 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 119 (var_cte -> TRUE .)
    (               reduce using rule 119 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 119 (var_cte -> TRUE .)
    TRUE            reduce using rule 119 (var_cte -> TRUE .)
    FALSE           reduce using rule 119 (var_cte -> TRUE .)
    ID              reduce using rule 119 (var_cte -> TRUE .)
    =               reduce using rule 119 (var_cte -> TRUE .)
    <               reduce using rule 119 (var_cte -> TRUE .)
    >               reduce using rule 119 (var_cte -> TRUE .)
    AND             reduce using rule 119 (var_cte -> TRUE .)
    OR              reduce using rule 119 (var_cte -> TRUE .)
    RED             reduce using rule 119 (var_cte -> TRUE .)
    YELLOW          reduce using rule 119 (var_cte -> TRUE .)
    BLUE            reduce using rule 119 (var_cte -> TRUE .)
    GREEN           reduce using rule 119 (var_cte -> TRUE .)
    BLACK           reduce using rule 119 (var_cte -> TRUE .)
    WHITE           reduce using rule 119 (var_cte -> TRUE .)
    ORANGE          reduce using rule 119 (var_cte -> TRUE .)
    PURPLE          reduce using rule 119 (var_cte -> TRUE .)
    CYAN            reduce using rule 119 (var_cte -> TRUE .)
    ]               reduce using rule 119 (var_cte -> TRUE .)


state 41

    (116) var_cte -> id .

    +               reduce using rule 116 (var_cte -> id .)
    -               reduce using rule 116 (var_cte -> id .)
    *               reduce using rule 116 (var_cte -> id .)
    /               reduce using rule 116 (var_cte -> id .)
    ,               reduce using rule 116 (var_cte -> id .)
    )               reduce using rule 116 (var_cte -> id .)
    ;               reduce using rule 116 (var_cte -> id .)
    CTE_INTEGER     reduce using rule 116 (var_cte -> id .)
    (               reduce using rule 116 (var_cte -> id .)
    CTE_FLOAT       reduce using rule 116 (var_cte -> id .)
    TRUE            reduce using rule 116 (var_cte -> id .)
    FALSE           reduce using rule 116 (var_cte -> id .)
    ID              reduce using rule 116 (var_cte -> id .)
    =               reduce using rule 116 (var_cte -> id .)
    <               reduce using rule 116 (var_cte -> id .)
    >               reduce using rule 116 (var_cte -> id .)
    AND             reduce using rule 116 (var_cte -> id .)
    OR              reduce using rule 116 (var_cte -> id .)
    RED             reduce using rule 116 (var_cte -> id .)
    YELLOW          reduce using rule 116 (var_cte -> id .)
    BLUE            reduce using rule 116 (var_cte -> id .)
    GREEN           reduce using rule 116 (var_cte -> id .)
    BLACK           reduce using rule 116 (var_cte -> id .)
    WHITE           reduce using rule 116 (var_cte -> id .)
    ORANGE          reduce using rule 116 (var_cte -> id .)
    PURPLE          reduce using rule 116 (var_cte -> id .)
    CYAN            reduce using rule 116 (var_cte -> id .)
    ]               reduce using rule 116 (var_cte -> id .)


state 42

    (97) factor -> ( . expression )
    (82) expression -> . exp = = exp
    (83) expression -> . exp < > exp
    (84) expression -> . exp < = exp
    (85) expression -> . exp > = exp
    (86) expression -> . exp > exp
    (87) expression -> . exp < exp
    (88) expression -> . exp AND exp
    (89) expression -> . exp OR exp
    (90) expression -> . exp empty
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 77
    factor                         shift and go to state 43
    expression                     shift and go to state 78
    id                             shift and go to state 41

state 43

    (95) exp -> factor . empty
    (129) empty -> .

    ;               reduce using rule 129 (empty -> .)
    +               reduce using rule 129 (empty -> .)
    -               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    CTE_INTEGER     reduce using rule 129 (empty -> .)
    CTE_FLOAT       reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    =               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    >               reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    RED             reduce using rule 129 (empty -> .)
    YELLOW          reduce using rule 129 (empty -> .)
    BLUE            reduce using rule 129 (empty -> .)
    GREEN           reduce using rule 129 (empty -> .)
    BLACK           reduce using rule 129 (empty -> .)
    WHITE           reduce using rule 129 (empty -> .)
    ORANGE          reduce using rule 129 (empty -> .)
    PURPLE          reduce using rule 129 (empty -> .)
    CYAN            reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)

    empty                          shift and go to state 79

state 44

    (117) var_cte -> CTE_INTEGER .

    +               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 117 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 117 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 117 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 117 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 117 (var_cte -> CTE_INTEGER .)
    =               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 117 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 117 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 117 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 117 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 117 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 117 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 117 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 117 (var_cte -> CTE_INTEGER .)
    WHITE           reduce using rule 117 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 117 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 117 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 117 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 117 (var_cte -> CTE_INTEGER .)


state 45

    (120) var_cte -> FALSE .

    +               reduce using rule 120 (var_cte -> FALSE .)
    -               reduce using rule 120 (var_cte -> FALSE .)
    *               reduce using rule 120 (var_cte -> FALSE .)
    /               reduce using rule 120 (var_cte -> FALSE .)
    ,               reduce using rule 120 (var_cte -> FALSE .)
    )               reduce using rule 120 (var_cte -> FALSE .)
    ;               reduce using rule 120 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 120 (var_cte -> FALSE .)
    (               reduce using rule 120 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 120 (var_cte -> FALSE .)
    TRUE            reduce using rule 120 (var_cte -> FALSE .)
    FALSE           reduce using rule 120 (var_cte -> FALSE .)
    ID              reduce using rule 120 (var_cte -> FALSE .)
    =               reduce using rule 120 (var_cte -> FALSE .)
    <               reduce using rule 120 (var_cte -> FALSE .)
    >               reduce using rule 120 (var_cte -> FALSE .)
    AND             reduce using rule 120 (var_cte -> FALSE .)
    OR              reduce using rule 120 (var_cte -> FALSE .)
    RED             reduce using rule 120 (var_cte -> FALSE .)
    YELLOW          reduce using rule 120 (var_cte -> FALSE .)
    BLUE            reduce using rule 120 (var_cte -> FALSE .)
    GREEN           reduce using rule 120 (var_cte -> FALSE .)
    BLACK           reduce using rule 120 (var_cte -> FALSE .)
    WHITE           reduce using rule 120 (var_cte -> FALSE .)
    ORANGE          reduce using rule 120 (var_cte -> FALSE .)
    PURPLE          reduce using rule 120 (var_cte -> FALSE .)
    CYAN            reduce using rule 120 (var_cte -> FALSE .)
    ]               reduce using rule 120 (var_cte -> FALSE .)


state 46

    (118) var_cte -> CTE_FLOAT .

    +               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 118 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 118 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 118 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 118 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 118 (var_cte -> CTE_FLOAT .)
    =               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 118 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 118 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 118 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 118 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 118 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 118 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 118 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 118 (var_cte -> CTE_FLOAT .)
    WHITE           reduce using rule 118 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 118 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 118 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 118 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 118 (var_cte -> CTE_FLOAT .)


state 47

    (96) return -> RETURN exp . ;
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    ;               shift and go to state 84
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 48

    (73) command -> figure exp . exp color ;
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83
    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 85
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 49

    (37) id -> callID # . calling2
    (41) calling2 -> . ( maincalling )

    (               shift and go to state 87

    calling2                       shift and go to state 86

state 50

    (77) cycle -> WHILE gotoW . ( expression ) gotoFalse block continueGoW

    (               shift and go to state 88


state 51

    (78) repeat -> REPLAY CTE_INTEGER . gotoR [ repeatA ] ;
    (124) gotoR -> .

    [               reduce using rule 124 (gotoR -> .)

    gotoR                          shift and go to state 89

state 52

    (58) assign -> id = . expression ;
    (82) expression -> . exp = = exp
    (83) expression -> . exp < > exp
    (84) expression -> . exp < = exp
    (85) expression -> . exp > = exp
    (86) expression -> . exp > exp
    (87) expression -> . exp < exp
    (88) expression -> . exp AND exp
    (89) expression -> . exp OR exp
    (90) expression -> . exp empty
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 77
    factor                         shift and go to state 43
    expression                     shift and go to state 90
    id                             shift and go to state 41

state 53

    (40) calling -> # callID . calling2 ;
    (41) calling2 -> . ( maincalling )

    (               shift and go to state 87

    calling2                       shift and go to state 91

state 54

    (43) callID -> ID .

    (               reduce using rule 43 (callID -> ID .)


state 55

    (59) condition -> IF ( . expression ) gotoFalse block conditionA continueGo
    (82) expression -> . exp = = exp
    (83) expression -> . exp < > exp
    (84) expression -> . exp < = exp
    (85) expression -> . exp > = exp
    (86) expression -> . exp > exp
    (87) expression -> . exp < exp
    (88) expression -> . exp AND exp
    (89) expression -> . exp OR exp
    (90) expression -> . exp empty
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    exp                            shift and go to state 77
    factor                         shift and go to state 43
    var_cte                        shift and go to state 39
    expression                     shift and go to state 92
    id                             shift and go to state 41

state 56

    (63) write -> ECHO ( . writeA writeB ) ;
    (64) writeA -> . expression
    (65) writeA -> . CTE_STRING
    (82) expression -> . exp = = exp
    (83) expression -> . exp < > exp
    (84) expression -> . exp < = exp
    (85) expression -> . exp > = exp
    (86) expression -> . exp > exp
    (87) expression -> . exp < exp
    (88) expression -> . exp AND exp
    (89) expression -> . exp OR exp
    (90) expression -> . exp empty
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    CTE_STRING      shift and go to state 94
    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 77
    factor                         shift and go to state 43
    writeA                         shift and go to state 93
    expression                     shift and go to state 95
    id                             shift and go to state 41

state 57

    (74) command -> SAMPLE commandA .

    SAMPLE          reduce using rule 74 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 74 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 74 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 74 (command -> SAMPLE commandA .)
    ARC             reduce using rule 74 (command -> SAMPLE commandA .)
    ]               reduce using rule 74 (command -> SAMPLE commandA .)
    IF              reduce using rule 74 (command -> SAMPLE commandA .)
    INPUT           reduce using rule 74 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 74 (command -> SAMPLE commandA .)
    WHILE           reduce using rule 74 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 74 (command -> SAMPLE commandA .)
    #               reduce using rule 74 (command -> SAMPLE commandA .)
    ARR             reduce using rule 74 (command -> SAMPLE commandA .)
    MAT             reduce using rule 74 (command -> SAMPLE commandA .)
    RETURN          reduce using rule 74 (command -> SAMPLE commandA .)
    ID              reduce using rule 74 (command -> SAMPLE commandA .)
    }               reduce using rule 74 (command -> SAMPLE commandA .)
    MOD             reduce using rule 74 (command -> SAMPLE commandA .)
    END             reduce using rule 74 (command -> SAMPLE commandA .)


state 58

    (76) commandA -> OFF . move exp ;
    (103) move -> . UP
    (104) move -> . DOWN
    (105) move -> . LEFT
    (106) move -> . RIGHT

    UP              shift and go to state 98
    DOWN            shift and go to state 99
    LEFT            shift and go to state 100
    RIGHT           shift and go to state 96

    move                           shift and go to state 97

state 59

    (75) commandA -> ON . move exp CTE_INTEGER color ;
    (103) move -> . UP
    (104) move -> . DOWN
    (105) move -> . LEFT
    (106) move -> . RIGHT

    UP              shift and go to state 98
    DOWN            shift and go to state 99
    LEFT            shift and go to state 100
    RIGHT           shift and go to state 96

    move                           shift and go to state 101

state 60

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 61

    (70) typeDim -> INT .

    ID              reduce using rule 70 (typeDim -> INT .)


state 62

    (71) typeDim -> FLOAT .

    ID              reduce using rule 71 (typeDim -> FLOAT .)


state 63

    (62) read -> INPUT typeDim . ID # ;

    ID              shift and go to state 102


state 64

    (72) typeDim -> BOOL .

    ID              reduce using rule 72 (typeDim -> BOOL .)


state 65

    (35) id -> ID [ . sumdim exp ] [ sumdim exp ]
    (36) id -> ID [ . sumdim exp ]
    (39) sumdim -> .

    (               reduce using rule 39 (sumdim -> .)
    CTE_INTEGER     reduce using rule 39 (sumdim -> .)
    CTE_FLOAT       reduce using rule 39 (sumdim -> .)
    TRUE            reduce using rule 39 (sumdim -> .)
    FALSE           reduce using rule 39 (sumdim -> .)
    ID              reduce using rule 39 (sumdim -> .)

    sumdim                         shift and go to state 103

state 66

    (38) id -> ID empty .

    =               reduce using rule 38 (id -> ID empty .)
    ]               reduce using rule 38 (id -> ID empty .)
    +               reduce using rule 38 (id -> ID empty .)
    -               reduce using rule 38 (id -> ID empty .)
    *               reduce using rule 38 (id -> ID empty .)
    /               reduce using rule 38 (id -> ID empty .)
    )               reduce using rule 38 (id -> ID empty .)
    ;               reduce using rule 38 (id -> ID empty .)
    ,               reduce using rule 38 (id -> ID empty .)
    RED             reduce using rule 38 (id -> ID empty .)
    YELLOW          reduce using rule 38 (id -> ID empty .)
    BLUE            reduce using rule 38 (id -> ID empty .)
    GREEN           reduce using rule 38 (id -> ID empty .)
    BLACK           reduce using rule 38 (id -> ID empty .)
    WHITE           reduce using rule 38 (id -> ID empty .)
    ORANGE          reduce using rule 38 (id -> ID empty .)
    PURPLE          reduce using rule 38 (id -> ID empty .)
    CYAN            reduce using rule 38 (id -> ID empty .)
    (               reduce using rule 38 (id -> ID empty .)
    CTE_INTEGER     reduce using rule 38 (id -> ID empty .)
    CTE_FLOAT       reduce using rule 38 (id -> ID empty .)
    TRUE            reduce using rule 38 (id -> ID empty .)
    FALSE           reduce using rule 38 (id -> ID empty .)
    ID              reduce using rule 38 (id -> ID empty .)
    <               reduce using rule 38 (id -> ID empty .)
    >               reduce using rule 38 (id -> ID empty .)
    AND             reduce using rule 38 (id -> ID empty .)
    OR              reduce using rule 38 (id -> ID empty .)


state 67

    (68) array -> ARR typeDim . ID [ CTE_INTEGER ] ;

    ID              shift and go to state 104


state 68

    (69) matrix -> MAT typeDim . ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    ID              shift and go to state 105


state 69

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 70

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 71

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 72

    (25) module -> MOD typeMod . # moduleID addMod insertQuadMod moduleA endMod

    #               shift and go to state 106


state 73

    (20) typeMod -> INT .

    #               reduce using rule 20 (typeMod -> INT .)


state 74

    (21) typeMod -> FLOAT .

    #               reduce using rule 21 (typeMod -> FLOAT .)


state 75

    (22) typeMod -> BOOL .

    #               reduce using rule 22 (typeMod -> BOOL .)


state 76

    (23) typeMod -> empty .

    #               reduce using rule 23 (typeMod -> empty .)


state 77

    (82) expression -> exp . = = exp
    (83) expression -> exp . < > exp
    (84) expression -> exp . < = exp
    (85) expression -> exp . > = exp
    (86) expression -> exp . > exp
    (87) expression -> exp . < exp
    (88) expression -> exp . AND exp
    (89) expression -> exp . OR exp
    (90) expression -> exp . empty
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp
    (129) empty -> .

    =               shift and go to state 109
    <               shift and go to state 108
    >               shift and go to state 112
    AND             shift and go to state 107
    OR              shift and go to state 110
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)

    empty                          shift and go to state 111

state 78

    (97) factor -> ( expression . )

    )               shift and go to state 113


state 79

    (95) exp -> factor empty .

    =               reduce using rule 95 (exp -> factor empty .)
    <               reduce using rule 95 (exp -> factor empty .)
    >               reduce using rule 95 (exp -> factor empty .)
    AND             reduce using rule 95 (exp -> factor empty .)
    OR              reduce using rule 95 (exp -> factor empty .)
    +               reduce using rule 95 (exp -> factor empty .)
    -               reduce using rule 95 (exp -> factor empty .)
    *               reduce using rule 95 (exp -> factor empty .)
    /               reduce using rule 95 (exp -> factor empty .)
    ;               reduce using rule 95 (exp -> factor empty .)
    ]               reduce using rule 95 (exp -> factor empty .)
    RED             reduce using rule 95 (exp -> factor empty .)
    YELLOW          reduce using rule 95 (exp -> factor empty .)
    BLUE            reduce using rule 95 (exp -> factor empty .)
    GREEN           reduce using rule 95 (exp -> factor empty .)
    BLACK           reduce using rule 95 (exp -> factor empty .)
    WHITE           reduce using rule 95 (exp -> factor empty .)
    ORANGE          reduce using rule 95 (exp -> factor empty .)
    PURPLE          reduce using rule 95 (exp -> factor empty .)
    CYAN            reduce using rule 95 (exp -> factor empty .)
    )               reduce using rule 95 (exp -> factor empty .)
    ,               reduce using rule 95 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 95 (exp -> factor empty .)
    (               reduce using rule 95 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 95 (exp -> factor empty .)
    TRUE            reduce using rule 95 (exp -> factor empty .)
    FALSE           reduce using rule 95 (exp -> factor empty .)
    ID              reduce using rule 95 (exp -> factor empty .)


state 80

    (91) exp -> exp + . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 114
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 81

    (93) exp -> exp * . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 115
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 82

    (92) exp -> exp - . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 116
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 83

    (94) exp -> exp / . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 117
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 84

    (96) return -> RETURN exp ; .

    IF              reduce using rule 96 (return -> RETURN exp ; .)
    INPUT           reduce using rule 96 (return -> RETURN exp ; .)
    ECHO            reduce using rule 96 (return -> RETURN exp ; .)
    WHILE           reduce using rule 96 (return -> RETURN exp ; .)
    REPLAY          reduce using rule 96 (return -> RETURN exp ; .)
    SAMPLE          reduce using rule 96 (return -> RETURN exp ; .)
    #               reduce using rule 96 (return -> RETURN exp ; .)
    ARR             reduce using rule 96 (return -> RETURN exp ; .)
    MAT             reduce using rule 96 (return -> RETURN exp ; .)
    RETURN          reduce using rule 96 (return -> RETURN exp ; .)
    ID              reduce using rule 96 (return -> RETURN exp ; .)
    OVAL            reduce using rule 96 (return -> RETURN exp ; .)
    TRIO            reduce using rule 96 (return -> RETURN exp ; .)
    QUAD            reduce using rule 96 (return -> RETURN exp ; .)
    ARC             reduce using rule 96 (return -> RETURN exp ; .)
    }               reduce using rule 96 (return -> RETURN exp ; .)
    MOD             reduce using rule 96 (return -> RETURN exp ; .)
    END             reduce using rule 96 (return -> RETURN exp ; .)


state 85

    (73) command -> figure exp exp . color ;
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp
    (107) color -> . RED
    (108) color -> . YELLOW
    (109) color -> . BLUE
    (110) color -> . GREEN
    (111) color -> . BLACK
    (112) color -> . WHITE
    (113) color -> . ORANGE
    (114) color -> . PURPLE
    (115) color -> . CYAN

    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83
    RED             shift and go to state 127
    YELLOW          shift and go to state 122
    BLUE            shift and go to state 118
    GREEN           shift and go to state 121
    BLACK           shift and go to state 125
    WHITE           shift and go to state 126
    ORANGE          shift and go to state 124
    PURPLE          shift and go to state 120
    CYAN            shift and go to state 123

    color                          shift and go to state 119

state 86

    (37) id -> callID # calling2 .

    =               reduce using rule 37 (id -> callID # calling2 .)
    ]               reduce using rule 37 (id -> callID # calling2 .)
    +               reduce using rule 37 (id -> callID # calling2 .)
    -               reduce using rule 37 (id -> callID # calling2 .)
    *               reduce using rule 37 (id -> callID # calling2 .)
    /               reduce using rule 37 (id -> callID # calling2 .)
    )               reduce using rule 37 (id -> callID # calling2 .)
    ;               reduce using rule 37 (id -> callID # calling2 .)
    ,               reduce using rule 37 (id -> callID # calling2 .)
    RED             reduce using rule 37 (id -> callID # calling2 .)
    YELLOW          reduce using rule 37 (id -> callID # calling2 .)
    BLUE            reduce using rule 37 (id -> callID # calling2 .)
    GREEN           reduce using rule 37 (id -> callID # calling2 .)
    BLACK           reduce using rule 37 (id -> callID # calling2 .)
    WHITE           reduce using rule 37 (id -> callID # calling2 .)
    ORANGE          reduce using rule 37 (id -> callID # calling2 .)
    PURPLE          reduce using rule 37 (id -> callID # calling2 .)
    CYAN            reduce using rule 37 (id -> callID # calling2 .)
    (               reduce using rule 37 (id -> callID # calling2 .)
    CTE_INTEGER     reduce using rule 37 (id -> callID # calling2 .)
    CTE_FLOAT       reduce using rule 37 (id -> callID # calling2 .)
    TRUE            reduce using rule 37 (id -> callID # calling2 .)
    FALSE           reduce using rule 37 (id -> callID # calling2 .)
    ID              reduce using rule 37 (id -> callID # calling2 .)
    <               reduce using rule 37 (id -> callID # calling2 .)
    >               reduce using rule 37 (id -> callID # calling2 .)
    AND             reduce using rule 37 (id -> callID # calling2 .)
    OR              reduce using rule 37 (id -> callID # calling2 .)


state 87

    (41) calling2 -> ( . maincalling )
    (42) maincalling -> . insertEra callingA
    (44) insertEra -> .

    (               reduce using rule 44 (insertEra -> .)
    CTE_INTEGER     reduce using rule 44 (insertEra -> .)
    CTE_FLOAT       reduce using rule 44 (insertEra -> .)
    TRUE            reduce using rule 44 (insertEra -> .)
    FALSE           reduce using rule 44 (insertEra -> .)
    ID              reduce using rule 44 (insertEra -> .)
    )               reduce using rule 44 (insertEra -> .)

    insertEra                      shift and go to state 128
    maincalling                    shift and go to state 129

state 88

    (77) cycle -> WHILE gotoW ( . expression ) gotoFalse block continueGoW
    (82) expression -> . exp = = exp
    (83) expression -> . exp < > exp
    (84) expression -> . exp < = exp
    (85) expression -> . exp > = exp
    (86) expression -> . exp > exp
    (87) expression -> . exp < exp
    (88) expression -> . exp AND exp
    (89) expression -> . exp OR exp
    (90) expression -> . exp empty
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 77
    factor                         shift and go to state 43
    expression                     shift and go to state 130
    id                             shift and go to state 41

state 89

    (78) repeat -> REPLAY CTE_INTEGER gotoR . [ repeatA ] ;

    [               shift and go to state 131


state 90

    (58) assign -> id = expression . ;

    ;               shift and go to state 132


state 91

    (40) calling -> # callID calling2 . ;

    ;               shift and go to state 133


state 92

    (59) condition -> IF ( expression . ) gotoFalse block conditionA continueGo

    )               shift and go to state 134


state 93

    (63) write -> ECHO ( writeA . writeB ) ;
    (66) writeB -> . , writeA
    (67) writeB -> . empty
    (129) empty -> .

    ,               shift and go to state 135
    )               reduce using rule 129 (empty -> .)

    writeB                         shift and go to state 136
    empty                          shift and go to state 137

state 94

    (65) writeA -> CTE_STRING .

    )               reduce using rule 65 (writeA -> CTE_STRING .)
    ,               reduce using rule 65 (writeA -> CTE_STRING .)


state 95

    (64) writeA -> expression .

    )               reduce using rule 64 (writeA -> expression .)
    ,               reduce using rule 64 (writeA -> expression .)


state 96

    (106) move -> RIGHT .

    (               reduce using rule 106 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 106 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 106 (move -> RIGHT .)
    TRUE            reduce using rule 106 (move -> RIGHT .)
    FALSE           reduce using rule 106 (move -> RIGHT .)
    ID              reduce using rule 106 (move -> RIGHT .)


state 97

    (76) commandA -> OFF move . exp ;
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 138
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 98

    (103) move -> UP .

    (               reduce using rule 103 (move -> UP .)
    CTE_INTEGER     reduce using rule 103 (move -> UP .)
    CTE_FLOAT       reduce using rule 103 (move -> UP .)
    TRUE            reduce using rule 103 (move -> UP .)
    FALSE           reduce using rule 103 (move -> UP .)
    ID              reduce using rule 103 (move -> UP .)


state 99

    (104) move -> DOWN .

    (               reduce using rule 104 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 104 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 104 (move -> DOWN .)
    TRUE            reduce using rule 104 (move -> DOWN .)
    FALSE           reduce using rule 104 (move -> DOWN .)
    ID              reduce using rule 104 (move -> DOWN .)


state 100

    (105) move -> LEFT .

    (               reduce using rule 105 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 105 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 105 (move -> LEFT .)
    TRUE            reduce using rule 105 (move -> LEFT .)
    FALSE           reduce using rule 105 (move -> LEFT .)
    ID              reduce using rule 105 (move -> LEFT .)


state 101

    (75) commandA -> ON move . exp CTE_INTEGER color ;
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 139
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 102

    (62) read -> INPUT typeDim ID . # ;

    #               shift and go to state 140


state 103

    (35) id -> ID [ sumdim . exp ] [ sumdim exp ]
    (36) id -> ID [ sumdim . exp ]
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 141
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 104

    (68) array -> ARR typeDim ID . [ CTE_INTEGER ] ;

    [               shift and go to state 142


state 105

    (69) matrix -> MAT typeDim ID . [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    [               shift and go to state 143


state 106

    (25) module -> MOD typeMod # . moduleID addMod insertQuadMod moduleA endMod
    (28) moduleID -> . ID

    ID              shift and go to state 144

    moduleID                       shift and go to state 145

state 107

    (88) expression -> exp AND . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 146
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 108

    (83) expression -> exp < . > exp
    (84) expression -> exp < . = exp
    (87) expression -> exp < . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    >               shift and go to state 148
    =               shift and go to state 147
    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 149
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 109

    (82) expression -> exp = . = exp

    =               shift and go to state 150


state 110

    (89) expression -> exp OR . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 151
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 111

    (90) expression -> exp empty .

    )               reduce using rule 90 (expression -> exp empty .)
    ;               reduce using rule 90 (expression -> exp empty .)
    ,               reduce using rule 90 (expression -> exp empty .)


state 112

    (85) expression -> exp > . = exp
    (86) expression -> exp > . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    =               shift and go to state 152
    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 153
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 113

    (97) factor -> ( expression ) .

    +               reduce using rule 97 (factor -> ( expression ) .)
    -               reduce using rule 97 (factor -> ( expression ) .)
    *               reduce using rule 97 (factor -> ( expression ) .)
    /               reduce using rule 97 (factor -> ( expression ) .)
    (               reduce using rule 97 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 97 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 97 (factor -> ( expression ) .)
    TRUE            reduce using rule 97 (factor -> ( expression ) .)
    FALSE           reduce using rule 97 (factor -> ( expression ) .)
    ID              reduce using rule 97 (factor -> ( expression ) .)
    ;               reduce using rule 97 (factor -> ( expression ) .)
    =               reduce using rule 97 (factor -> ( expression ) .)
    <               reduce using rule 97 (factor -> ( expression ) .)
    >               reduce using rule 97 (factor -> ( expression ) .)
    AND             reduce using rule 97 (factor -> ( expression ) .)
    OR              reduce using rule 97 (factor -> ( expression ) .)
    )               reduce using rule 97 (factor -> ( expression ) .)
    RED             reduce using rule 97 (factor -> ( expression ) .)
    YELLOW          reduce using rule 97 (factor -> ( expression ) .)
    BLUE            reduce using rule 97 (factor -> ( expression ) .)
    GREEN           reduce using rule 97 (factor -> ( expression ) .)
    BLACK           reduce using rule 97 (factor -> ( expression ) .)
    WHITE           reduce using rule 97 (factor -> ( expression ) .)
    ORANGE          reduce using rule 97 (factor -> ( expression ) .)
    PURPLE          reduce using rule 97 (factor -> ( expression ) .)
    CYAN            reduce using rule 97 (factor -> ( expression ) .)
    ,               reduce using rule 97 (factor -> ( expression ) .)
    ]               reduce using rule 97 (factor -> ( expression ) .)


state 114

    (91) exp -> exp + exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    =               reduce using rule 91 (exp -> exp + exp .)
    <               reduce using rule 91 (exp -> exp + exp .)
    >               reduce using rule 91 (exp -> exp + exp .)
    AND             reduce using rule 91 (exp -> exp + exp .)
    OR              reduce using rule 91 (exp -> exp + exp .)
    +               reduce using rule 91 (exp -> exp + exp .)
    -               reduce using rule 91 (exp -> exp + exp .)
    ;               reduce using rule 91 (exp -> exp + exp .)
    ]               reduce using rule 91 (exp -> exp + exp .)
    RED             reduce using rule 91 (exp -> exp + exp .)
    YELLOW          reduce using rule 91 (exp -> exp + exp .)
    BLUE            reduce using rule 91 (exp -> exp + exp .)
    GREEN           reduce using rule 91 (exp -> exp + exp .)
    BLACK           reduce using rule 91 (exp -> exp + exp .)
    WHITE           reduce using rule 91 (exp -> exp + exp .)
    ORANGE          reduce using rule 91 (exp -> exp + exp .)
    PURPLE          reduce using rule 91 (exp -> exp + exp .)
    CYAN            reduce using rule 91 (exp -> exp + exp .)
    )               reduce using rule 91 (exp -> exp + exp .)
    ,               reduce using rule 91 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 91 (exp -> exp + exp .)
    (               reduce using rule 91 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 91 (exp -> exp + exp .)
    TRUE            reduce using rule 91 (exp -> exp + exp .)
    FALSE           reduce using rule 91 (exp -> exp + exp .)
    ID              reduce using rule 91 (exp -> exp + exp .)
    *               shift and go to state 81
    /               shift and go to state 83

  ! *               [ reduce using rule 91 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 91 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 80 ]
  ! -               [ shift and go to state 82 ]


state 115

    (93) exp -> exp * exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    =               reduce using rule 93 (exp -> exp * exp .)
    <               reduce using rule 93 (exp -> exp * exp .)
    >               reduce using rule 93 (exp -> exp * exp .)
    AND             reduce using rule 93 (exp -> exp * exp .)
    OR              reduce using rule 93 (exp -> exp * exp .)
    +               reduce using rule 93 (exp -> exp * exp .)
    -               reduce using rule 93 (exp -> exp * exp .)
    *               reduce using rule 93 (exp -> exp * exp .)
    /               reduce using rule 93 (exp -> exp * exp .)
    ;               reduce using rule 93 (exp -> exp * exp .)
    ]               reduce using rule 93 (exp -> exp * exp .)
    RED             reduce using rule 93 (exp -> exp * exp .)
    YELLOW          reduce using rule 93 (exp -> exp * exp .)
    BLUE            reduce using rule 93 (exp -> exp * exp .)
    GREEN           reduce using rule 93 (exp -> exp * exp .)
    BLACK           reduce using rule 93 (exp -> exp * exp .)
    WHITE           reduce using rule 93 (exp -> exp * exp .)
    ORANGE          reduce using rule 93 (exp -> exp * exp .)
    PURPLE          reduce using rule 93 (exp -> exp * exp .)
    CYAN            reduce using rule 93 (exp -> exp * exp .)
    )               reduce using rule 93 (exp -> exp * exp .)
    ,               reduce using rule 93 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 93 (exp -> exp * exp .)
    (               reduce using rule 93 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 93 (exp -> exp * exp .)
    TRUE            reduce using rule 93 (exp -> exp * exp .)
    FALSE           reduce using rule 93 (exp -> exp * exp .)
    ID              reduce using rule 93 (exp -> exp * exp .)

  ! +               [ shift and go to state 80 ]
  ! -               [ shift and go to state 82 ]
  ! *               [ shift and go to state 81 ]
  ! /               [ shift and go to state 83 ]


state 116

    (92) exp -> exp - exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    =               reduce using rule 92 (exp -> exp - exp .)
    <               reduce using rule 92 (exp -> exp - exp .)
    >               reduce using rule 92 (exp -> exp - exp .)
    AND             reduce using rule 92 (exp -> exp - exp .)
    OR              reduce using rule 92 (exp -> exp - exp .)
    +               reduce using rule 92 (exp -> exp - exp .)
    -               reduce using rule 92 (exp -> exp - exp .)
    ;               reduce using rule 92 (exp -> exp - exp .)
    ]               reduce using rule 92 (exp -> exp - exp .)
    RED             reduce using rule 92 (exp -> exp - exp .)
    YELLOW          reduce using rule 92 (exp -> exp - exp .)
    BLUE            reduce using rule 92 (exp -> exp - exp .)
    GREEN           reduce using rule 92 (exp -> exp - exp .)
    BLACK           reduce using rule 92 (exp -> exp - exp .)
    WHITE           reduce using rule 92 (exp -> exp - exp .)
    ORANGE          reduce using rule 92 (exp -> exp - exp .)
    PURPLE          reduce using rule 92 (exp -> exp - exp .)
    CYAN            reduce using rule 92 (exp -> exp - exp .)
    )               reduce using rule 92 (exp -> exp - exp .)
    ,               reduce using rule 92 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 92 (exp -> exp - exp .)
    (               reduce using rule 92 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 92 (exp -> exp - exp .)
    TRUE            reduce using rule 92 (exp -> exp - exp .)
    FALSE           reduce using rule 92 (exp -> exp - exp .)
    ID              reduce using rule 92 (exp -> exp - exp .)
    *               shift and go to state 81
    /               shift and go to state 83

  ! *               [ reduce using rule 92 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 92 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 80 ]
  ! -               [ shift and go to state 82 ]


state 117

    (94) exp -> exp / exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    =               reduce using rule 94 (exp -> exp / exp .)
    <               reduce using rule 94 (exp -> exp / exp .)
    >               reduce using rule 94 (exp -> exp / exp .)
    AND             reduce using rule 94 (exp -> exp / exp .)
    OR              reduce using rule 94 (exp -> exp / exp .)
    +               reduce using rule 94 (exp -> exp / exp .)
    -               reduce using rule 94 (exp -> exp / exp .)
    *               reduce using rule 94 (exp -> exp / exp .)
    /               reduce using rule 94 (exp -> exp / exp .)
    ;               reduce using rule 94 (exp -> exp / exp .)
    ]               reduce using rule 94 (exp -> exp / exp .)
    RED             reduce using rule 94 (exp -> exp / exp .)
    YELLOW          reduce using rule 94 (exp -> exp / exp .)
    BLUE            reduce using rule 94 (exp -> exp / exp .)
    GREEN           reduce using rule 94 (exp -> exp / exp .)
    BLACK           reduce using rule 94 (exp -> exp / exp .)
    WHITE           reduce using rule 94 (exp -> exp / exp .)
    ORANGE          reduce using rule 94 (exp -> exp / exp .)
    PURPLE          reduce using rule 94 (exp -> exp / exp .)
    CYAN            reduce using rule 94 (exp -> exp / exp .)
    )               reduce using rule 94 (exp -> exp / exp .)
    ,               reduce using rule 94 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 94 (exp -> exp / exp .)
    (               reduce using rule 94 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 94 (exp -> exp / exp .)
    TRUE            reduce using rule 94 (exp -> exp / exp .)
    FALSE           reduce using rule 94 (exp -> exp / exp .)
    ID              reduce using rule 94 (exp -> exp / exp .)

  ! +               [ shift and go to state 80 ]
  ! -               [ shift and go to state 82 ]
  ! *               [ shift and go to state 81 ]
  ! /               [ shift and go to state 83 ]


state 118

    (109) color -> BLUE .

    ;               reduce using rule 109 (color -> BLUE .)


state 119

    (73) command -> figure exp exp color . ;

    ;               shift and go to state 154


state 120

    (114) color -> PURPLE .

    ;               reduce using rule 114 (color -> PURPLE .)


state 121

    (110) color -> GREEN .

    ;               reduce using rule 110 (color -> GREEN .)


state 122

    (108) color -> YELLOW .

    ;               reduce using rule 108 (color -> YELLOW .)


state 123

    (115) color -> CYAN .

    ;               reduce using rule 115 (color -> CYAN .)


state 124

    (113) color -> ORANGE .

    ;               reduce using rule 113 (color -> ORANGE .)


state 125

    (111) color -> BLACK .

    ;               reduce using rule 111 (color -> BLACK .)


state 126

    (112) color -> WHITE .

    ;               reduce using rule 112 (color -> WHITE .)


state 127

    (107) color -> RED .

    ;               reduce using rule 107 (color -> RED .)


state 128

    (42) maincalling -> insertEra . callingA
    (45) callingA -> . callingB
    (46) callingA -> . empty
    (47) callingB -> . exp checkParam callingC
    (129) empty -> .
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    )               reduce using rule 129 (empty -> .)
    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    var_cte                        shift and go to state 39
    callID                         shift and go to state 5
    callingA                       shift and go to state 156
    callingB                       shift and go to state 157
    exp                            shift and go to state 158
    factor                         shift and go to state 43
    id                             shift and go to state 41
    empty                          shift and go to state 155

state 129

    (41) calling2 -> ( maincalling . )

    )               shift and go to state 159


state 130

    (77) cycle -> WHILE gotoW ( expression . ) gotoFalse block continueGoW

    )               shift and go to state 160


state 131

    (78) repeat -> REPLAY CTE_INTEGER gotoR [ . repeatA ] ;
    (79) repeatA -> . command repeatB
    (73) command -> . figure exp exp color ;
    (74) command -> . SAMPLE commandA
    (99) figure -> . OVAL
    (100) figure -> . TRIO
    (101) figure -> . QUAD
    (102) figure -> . ARC

    SAMPLE          shift and go to state 23
    OVAL            shift and go to state 7
    TRIO            shift and go to state 18
    QUAD            shift and go to state 10
    ARC             shift and go to state 34

    figure                         shift and go to state 4
    repeatA                        shift and go to state 161
    command                        shift and go to state 162

state 132

    (58) assign -> id = expression ; .

    IF              reduce using rule 58 (assign -> id = expression ; .)
    INPUT           reduce using rule 58 (assign -> id = expression ; .)
    ECHO            reduce using rule 58 (assign -> id = expression ; .)
    WHILE           reduce using rule 58 (assign -> id = expression ; .)
    REPLAY          reduce using rule 58 (assign -> id = expression ; .)
    SAMPLE          reduce using rule 58 (assign -> id = expression ; .)
    #               reduce using rule 58 (assign -> id = expression ; .)
    ARR             reduce using rule 58 (assign -> id = expression ; .)
    MAT             reduce using rule 58 (assign -> id = expression ; .)
    RETURN          reduce using rule 58 (assign -> id = expression ; .)
    ID              reduce using rule 58 (assign -> id = expression ; .)
    OVAL            reduce using rule 58 (assign -> id = expression ; .)
    TRIO            reduce using rule 58 (assign -> id = expression ; .)
    QUAD            reduce using rule 58 (assign -> id = expression ; .)
    ARC             reduce using rule 58 (assign -> id = expression ; .)
    }               reduce using rule 58 (assign -> id = expression ; .)
    MOD             reduce using rule 58 (assign -> id = expression ; .)
    END             reduce using rule 58 (assign -> id = expression ; .)


state 133

    (40) calling -> # callID calling2 ; .

    MOD             reduce using rule 40 (calling -> # callID calling2 ; .)
    IF              reduce using rule 40 (calling -> # callID calling2 ; .)
    INPUT           reduce using rule 40 (calling -> # callID calling2 ; .)
    ECHO            reduce using rule 40 (calling -> # callID calling2 ; .)
    WHILE           reduce using rule 40 (calling -> # callID calling2 ; .)
    REPLAY          reduce using rule 40 (calling -> # callID calling2 ; .)
    SAMPLE          reduce using rule 40 (calling -> # callID calling2 ; .)
    #               reduce using rule 40 (calling -> # callID calling2 ; .)
    ARR             reduce using rule 40 (calling -> # callID calling2 ; .)
    MAT             reduce using rule 40 (calling -> # callID calling2 ; .)
    RETURN          reduce using rule 40 (calling -> # callID calling2 ; .)
    ID              reduce using rule 40 (calling -> # callID calling2 ; .)
    OVAL            reduce using rule 40 (calling -> # callID calling2 ; .)
    TRIO            reduce using rule 40 (calling -> # callID calling2 ; .)
    QUAD            reduce using rule 40 (calling -> # callID calling2 ; .)
    ARC             reduce using rule 40 (calling -> # callID calling2 ; .)
    END             reduce using rule 40 (calling -> # callID calling2 ; .)
    }               reduce using rule 40 (calling -> # callID calling2 ; .)


state 134

    (59) condition -> IF ( expression ) . gotoFalse block conditionA continueGo
    (121) gotoFalse -> .

    {               reduce using rule 121 (gotoFalse -> .)

    gotoFalse                      shift and go to state 163

state 135

    (66) writeB -> , . writeA
    (64) writeA -> . expression
    (65) writeA -> . CTE_STRING
    (82) expression -> . exp = = exp
    (83) expression -> . exp < > exp
    (84) expression -> . exp < = exp
    (85) expression -> . exp > = exp
    (86) expression -> . exp > exp
    (87) expression -> . exp < exp
    (88) expression -> . exp AND exp
    (89) expression -> . exp OR exp
    (90) expression -> . exp empty
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    CTE_STRING      shift and go to state 94
    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 77
    factor                         shift and go to state 43
    writeA                         shift and go to state 164
    expression                     shift and go to state 95
    id                             shift and go to state 41

state 136

    (63) write -> ECHO ( writeA writeB . ) ;

    )               shift and go to state 165


state 137

    (67) writeB -> empty .

    )               reduce using rule 67 (writeB -> empty .)


state 138

    (76) commandA -> OFF move exp . ;
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    ;               shift and go to state 166
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 139

    (75) commandA -> ON move exp . CTE_INTEGER color ;
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 167
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 140

    (62) read -> INPUT typeDim ID # . ;

    ;               shift and go to state 168


state 141

    (35) id -> ID [ sumdim exp . ] [ sumdim exp ]
    (36) id -> ID [ sumdim exp . ]
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    ]               shift and go to state 169
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 142

    (68) array -> ARR typeDim ID [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 170


state 143

    (69) matrix -> MAT typeDim ID [ . CTE_INTEGER ] [ CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 171


state 144

    (28) moduleID -> ID .

    (               reduce using rule 28 (moduleID -> ID .)
    {               reduce using rule 28 (moduleID -> ID .)


state 145

    (25) module -> MOD typeMod # moduleID . addMod insertQuadMod moduleA endMod
    (24) addMod -> .

    (               reduce using rule 24 (addMod -> .)
    {               reduce using rule 24 (addMod -> .)

    addMod                         shift and go to state 172

state 146

    (88) expression -> exp AND exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 88 (expression -> exp AND exp .)
    ;               reduce using rule 88 (expression -> exp AND exp .)
    ,               reduce using rule 88 (expression -> exp AND exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 147

    (84) expression -> exp < = . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 173
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 148

    (83) expression -> exp < > . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 174
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 149

    (87) expression -> exp < exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 87 (expression -> exp < exp .)
    ;               reduce using rule 87 (expression -> exp < exp .)
    ,               reduce using rule 87 (expression -> exp < exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 150

    (82) expression -> exp = = . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 175
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 151

    (89) expression -> exp OR exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 89 (expression -> exp OR exp .)
    ;               reduce using rule 89 (expression -> exp OR exp .)
    ,               reduce using rule 89 (expression -> exp OR exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 152

    (85) expression -> exp > = . exp
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 176
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 153

    (86) expression -> exp > exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 86 (expression -> exp > exp .)
    ;               reduce using rule 86 (expression -> exp > exp .)
    ,               reduce using rule 86 (expression -> exp > exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 154

    (73) command -> figure exp exp color ; .

    SAMPLE          reduce using rule 73 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 73 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 73 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 73 (command -> figure exp exp color ; .)
    ARC             reduce using rule 73 (command -> figure exp exp color ; .)
    ]               reduce using rule 73 (command -> figure exp exp color ; .)
    IF              reduce using rule 73 (command -> figure exp exp color ; .)
    INPUT           reduce using rule 73 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 73 (command -> figure exp exp color ; .)
    WHILE           reduce using rule 73 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 73 (command -> figure exp exp color ; .)
    #               reduce using rule 73 (command -> figure exp exp color ; .)
    ARR             reduce using rule 73 (command -> figure exp exp color ; .)
    MAT             reduce using rule 73 (command -> figure exp exp color ; .)
    RETURN          reduce using rule 73 (command -> figure exp exp color ; .)
    ID              reduce using rule 73 (command -> figure exp exp color ; .)
    }               reduce using rule 73 (command -> figure exp exp color ; .)
    MOD             reduce using rule 73 (command -> figure exp exp color ; .)
    END             reduce using rule 73 (command -> figure exp exp color ; .)


state 155

    (46) callingA -> empty .

    )               reduce using rule 46 (callingA -> empty .)


state 156

    (42) maincalling -> insertEra callingA .

    )               reduce using rule 42 (maincalling -> insertEra callingA .)


state 157

    (45) callingA -> callingB .

    )               reduce using rule 45 (callingA -> callingB .)


state 158

    (47) callingB -> exp . checkParam callingC
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp
    (48) checkParam -> .

    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83
    ,               reduce using rule 48 (checkParam -> .)
    )               reduce using rule 48 (checkParam -> .)

    checkParam                     shift and go to state 177

state 159

    (41) calling2 -> ( maincalling ) .

    =               reduce using rule 41 (calling2 -> ( maincalling ) .)
    ;               reduce using rule 41 (calling2 -> ( maincalling ) .)
    +               reduce using rule 41 (calling2 -> ( maincalling ) .)
    -               reduce using rule 41 (calling2 -> ( maincalling ) .)
    *               reduce using rule 41 (calling2 -> ( maincalling ) .)
    /               reduce using rule 41 (calling2 -> ( maincalling ) .)
    (               reduce using rule 41 (calling2 -> ( maincalling ) .)
    CTE_INTEGER     reduce using rule 41 (calling2 -> ( maincalling ) .)
    CTE_FLOAT       reduce using rule 41 (calling2 -> ( maincalling ) .)
    TRUE            reduce using rule 41 (calling2 -> ( maincalling ) .)
    FALSE           reduce using rule 41 (calling2 -> ( maincalling ) .)
    ID              reduce using rule 41 (calling2 -> ( maincalling ) .)
    <               reduce using rule 41 (calling2 -> ( maincalling ) .)
    >               reduce using rule 41 (calling2 -> ( maincalling ) .)
    AND             reduce using rule 41 (calling2 -> ( maincalling ) .)
    OR              reduce using rule 41 (calling2 -> ( maincalling ) .)
    )               reduce using rule 41 (calling2 -> ( maincalling ) .)
    RED             reduce using rule 41 (calling2 -> ( maincalling ) .)
    YELLOW          reduce using rule 41 (calling2 -> ( maincalling ) .)
    BLUE            reduce using rule 41 (calling2 -> ( maincalling ) .)
    GREEN           reduce using rule 41 (calling2 -> ( maincalling ) .)
    BLACK           reduce using rule 41 (calling2 -> ( maincalling ) .)
    WHITE           reduce using rule 41 (calling2 -> ( maincalling ) .)
    ORANGE          reduce using rule 41 (calling2 -> ( maincalling ) .)
    PURPLE          reduce using rule 41 (calling2 -> ( maincalling ) .)
    CYAN            reduce using rule 41 (calling2 -> ( maincalling ) .)
    ,               reduce using rule 41 (calling2 -> ( maincalling ) .)
    ]               reduce using rule 41 (calling2 -> ( maincalling ) .)


state 160

    (77) cycle -> WHILE gotoW ( expression ) . gotoFalse block continueGoW
    (121) gotoFalse -> .

    {               reduce using rule 121 (gotoFalse -> .)

    gotoFalse                      shift and go to state 178

state 161

    (78) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA . ] ;

    ]               shift and go to state 179


state 162

    (79) repeatA -> command . repeatB
    (80) repeatB -> . repeatA
    (81) repeatB -> . empty
    (79) repeatA -> . command repeatB
    (129) empty -> .
    (73) command -> . figure exp exp color ;
    (74) command -> . SAMPLE commandA
    (99) figure -> . OVAL
    (100) figure -> . TRIO
    (101) figure -> . QUAD
    (102) figure -> . ARC

    ]               reduce using rule 129 (empty -> .)
    SAMPLE          shift and go to state 23
    OVAL            shift and go to state 7
    TRIO            shift and go to state 18
    QUAD            shift and go to state 10
    ARC             shift and go to state 34

    figure                         shift and go to state 4
    repeatA                        shift and go to state 180
    repeatB                        shift and go to state 181
    command                        shift and go to state 162
    empty                          shift and go to state 182

state 163

    (59) condition -> IF ( expression ) gotoFalse . block conditionA continueGo
    (52) block -> . { blockA

    {               shift and go to state 183

    block                          shift and go to state 184

state 164

    (66) writeB -> , writeA .

    )               reduce using rule 66 (writeB -> , writeA .)


state 165

    (63) write -> ECHO ( writeA writeB ) . ;

    ;               shift and go to state 185


state 166

    (76) commandA -> OFF move exp ; .

    MOD             reduce using rule 76 (commandA -> OFF move exp ; .)
    IF              reduce using rule 76 (commandA -> OFF move exp ; .)
    INPUT           reduce using rule 76 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 76 (commandA -> OFF move exp ; .)
    WHILE           reduce using rule 76 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 76 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 76 (commandA -> OFF move exp ; .)
    #               reduce using rule 76 (commandA -> OFF move exp ; .)
    ARR             reduce using rule 76 (commandA -> OFF move exp ; .)
    MAT             reduce using rule 76 (commandA -> OFF move exp ; .)
    RETURN          reduce using rule 76 (commandA -> OFF move exp ; .)
    ID              reduce using rule 76 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 76 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 76 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 76 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 76 (commandA -> OFF move exp ; .)
    END             reduce using rule 76 (commandA -> OFF move exp ; .)
    ]               reduce using rule 76 (commandA -> OFF move exp ; .)
    }               reduce using rule 76 (commandA -> OFF move exp ; .)


state 167

    (75) commandA -> ON move exp CTE_INTEGER . color ;
    (107) color -> . RED
    (108) color -> . YELLOW
    (109) color -> . BLUE
    (110) color -> . GREEN
    (111) color -> . BLACK
    (112) color -> . WHITE
    (113) color -> . ORANGE
    (114) color -> . PURPLE
    (115) color -> . CYAN

    RED             shift and go to state 127
    YELLOW          shift and go to state 122
    BLUE            shift and go to state 118
    GREEN           shift and go to state 121
    BLACK           shift and go to state 125
    WHITE           shift and go to state 126
    ORANGE          shift and go to state 124
    PURPLE          shift and go to state 120
    CYAN            shift and go to state 123

    color                          shift and go to state 186

state 168

    (62) read -> INPUT typeDim ID # ; .

    IF              reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    INPUT           reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    ECHO            reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    WHILE           reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    REPLAY          reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    SAMPLE          reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    #               reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    ARR             reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    MAT             reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    RETURN          reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    ID              reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    OVAL            reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    TRIO            reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    QUAD            reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    ARC             reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    }               reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    MOD             reduce using rule 62 (read -> INPUT typeDim ID # ; .)
    END             reduce using rule 62 (read -> INPUT typeDim ID # ; .)


state 169

    (35) id -> ID [ sumdim exp ] . [ sumdim exp ]
    (36) id -> ID [ sumdim exp ] .

    [               shift and go to state 187
    =               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    ]               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    +               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    -               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    *               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    /               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    )               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    ;               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    ,               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    RED             reduce using rule 36 (id -> ID [ sumdim exp ] .)
    YELLOW          reduce using rule 36 (id -> ID [ sumdim exp ] .)
    BLUE            reduce using rule 36 (id -> ID [ sumdim exp ] .)
    GREEN           reduce using rule 36 (id -> ID [ sumdim exp ] .)
    BLACK           reduce using rule 36 (id -> ID [ sumdim exp ] .)
    WHITE           reduce using rule 36 (id -> ID [ sumdim exp ] .)
    ORANGE          reduce using rule 36 (id -> ID [ sumdim exp ] .)
    PURPLE          reduce using rule 36 (id -> ID [ sumdim exp ] .)
    CYAN            reduce using rule 36 (id -> ID [ sumdim exp ] .)
    (               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 36 (id -> ID [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 36 (id -> ID [ sumdim exp ] .)
    TRUE            reduce using rule 36 (id -> ID [ sumdim exp ] .)
    FALSE           reduce using rule 36 (id -> ID [ sumdim exp ] .)
    ID              reduce using rule 36 (id -> ID [ sumdim exp ] .)
    <               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    >               reduce using rule 36 (id -> ID [ sumdim exp ] .)
    AND             reduce using rule 36 (id -> ID [ sumdim exp ] .)
    OR              reduce using rule 36 (id -> ID [ sumdim exp ] .)


state 170

    (68) array -> ARR typeDim ID [ CTE_INTEGER . ] ;

    ]               shift and go to state 188


state 171

    (69) matrix -> MAT typeDim ID [ CTE_INTEGER . ] [ CTE_INTEGER ] ;

    ]               shift and go to state 189


state 172

    (25) module -> MOD typeMod # moduleID addMod . insertQuadMod moduleA endMod
    (127) insertQuadMod -> .

    (               reduce using rule 127 (insertQuadMod -> .)
    {               reduce using rule 127 (insertQuadMod -> .)

    insertQuadMod                  shift and go to state 190

state 173

    (84) expression -> exp < = exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 84 (expression -> exp < = exp .)
    ;               reduce using rule 84 (expression -> exp < = exp .)
    ,               reduce using rule 84 (expression -> exp < = exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 174

    (83) expression -> exp < > exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 83 (expression -> exp < > exp .)
    ;               reduce using rule 83 (expression -> exp < > exp .)
    ,               reduce using rule 83 (expression -> exp < > exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 175

    (82) expression -> exp = = exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 82 (expression -> exp = = exp .)
    ;               reduce using rule 82 (expression -> exp = = exp .)
    ,               reduce using rule 82 (expression -> exp = = exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 176

    (85) expression -> exp > = exp .
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    )               reduce using rule 85 (expression -> exp > = exp .)
    ;               reduce using rule 85 (expression -> exp > = exp .)
    ,               reduce using rule 85 (expression -> exp > = exp .)
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 177

    (47) callingB -> exp checkParam . callingC
    (49) callingC -> . , sumXparam callingB
    (50) callingC -> . empty
    (129) empty -> .

    ,               shift and go to state 191
    )               reduce using rule 129 (empty -> .)

    callingC                       shift and go to state 192
    empty                          shift and go to state 193

state 178

    (77) cycle -> WHILE gotoW ( expression ) gotoFalse . block continueGoW
    (52) block -> . { blockA

    {               shift and go to state 183

    block                          shift and go to state 194

state 179

    (78) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] . ;

    ;               shift and go to state 195


state 180

    (80) repeatB -> repeatA .

    ]               reduce using rule 80 (repeatB -> repeatA .)


state 181

    (79) repeatA -> command repeatB .

    ]               reduce using rule 79 (repeatA -> command repeatB .)


state 182

    (81) repeatB -> empty .

    ]               reduce using rule 81 (repeatB -> empty .)


state 183

    (52) block -> { . blockA
    (53) blockA -> . blockB }
    (54) blockA -> . }
    (55) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . return
    (58) assign -> . id = expression ;
    (59) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (62) read -> . INPUT typeDim ID # ;
    (63) write -> . ECHO ( writeA writeB ) ;
    (77) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (78) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (73) command -> . figure exp exp color ;
    (74) command -> . SAMPLE commandA
    (40) calling -> . # callID calling2 ;
    (68) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (69) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (96) return -> . RETURN exp ;
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (99) figure -> . OVAL
    (100) figure -> . TRIO
    (101) figure -> . QUAD
    (102) figure -> . ARC
    (43) callID -> . ID

    }               shift and go to state 197
    IF              shift and go to state 17
    INPUT           shift and go to state 26
    ECHO            shift and go to state 22
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 23
    #               shift and go to state 14
    ARR             shift and go to state 31
    MAT             shift and go to state 32
    RETURN          shift and go to state 3
    ID              shift and go to state 27
    OVAL            shift and go to state 7
    TRIO            shift and go to state 18
    QUAD            shift and go to state 10
    ARC             shift and go to state 34

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    array                          shift and go to state 12
    id                             shift and go to state 13
    matrix                         shift and go to state 15
    write                          shift and go to state 16
    command                        shift and go to state 35
    repeat                         shift and go to state 19
    return                         shift and go to state 11
    read                           shift and go to state 21
    condition                      shift and go to state 28
    cycle                          shift and go to state 29
    statute                        shift and go to state 196
    calling                        shift and go to state 33
    blockB                         shift and go to state 198
    blockA                         shift and go to state 199
    assign                         shift and go to state 37

state 184

    (59) condition -> IF ( expression ) gotoFalse block . conditionA continueGo
    (60) conditionA -> . ELSE gotoE block
    (61) conditionA -> . empty
    (129) empty -> .

    ELSE            shift and go to state 202
    MOD             reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    INPUT           reduce using rule 129 (empty -> .)
    ECHO            reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    REPLAY          reduce using rule 129 (empty -> .)
    SAMPLE          reduce using rule 129 (empty -> .)
    #               reduce using rule 129 (empty -> .)
    ARR             reduce using rule 129 (empty -> .)
    MAT             reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    OVAL            reduce using rule 129 (empty -> .)
    TRIO            reduce using rule 129 (empty -> .)
    QUAD            reduce using rule 129 (empty -> .)
    ARC             reduce using rule 129 (empty -> .)
    END             reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)

    conditionA                     shift and go to state 200
    empty                          shift and go to state 201

state 185

    (63) write -> ECHO ( writeA writeB ) ; .

    MOD             reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    IF              reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    INPUT           reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    ECHO            reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    WHILE           reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    REPLAY          reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    SAMPLE          reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    #               reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    ARR             reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    MAT             reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    RETURN          reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    ID              reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    OVAL            reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    TRIO            reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    QUAD            reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    ARC             reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    END             reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)
    }               reduce using rule 63 (write -> ECHO ( writeA writeB ) ; .)


state 186

    (75) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 203


state 187

    (35) id -> ID [ sumdim exp ] [ . sumdim exp ]
    (39) sumdim -> .

    (               reduce using rule 39 (sumdim -> .)
    CTE_INTEGER     reduce using rule 39 (sumdim -> .)
    CTE_FLOAT       reduce using rule 39 (sumdim -> .)
    TRUE            reduce using rule 39 (sumdim -> .)
    FALSE           reduce using rule 39 (sumdim -> .)
    ID              reduce using rule 39 (sumdim -> .)

    sumdim                         shift and go to state 204

state 188

    (68) array -> ARR typeDim ID [ CTE_INTEGER ] . ;

    ;               shift and go to state 205


state 189

    (69) matrix -> MAT typeDim ID [ CTE_INTEGER ] . [ CTE_INTEGER ] ;

    [               shift and go to state 206


state 190

    (25) module -> MOD typeMod # moduleID addMod insertQuadMod . moduleA endMod
    (26) moduleA -> . ( vars ) block
    (27) moduleA -> . block
    (52) block -> . { blockA

    (               shift and go to state 207
    {               shift and go to state 183

    block                          shift and go to state 208
    moduleA                        shift and go to state 209

state 191

    (49) callingC -> , . sumXparam callingB
    (51) sumXparam -> .

    (               reduce using rule 51 (sumXparam -> .)
    CTE_INTEGER     reduce using rule 51 (sumXparam -> .)
    CTE_FLOAT       reduce using rule 51 (sumXparam -> .)
    TRUE            reduce using rule 51 (sumXparam -> .)
    FALSE           reduce using rule 51 (sumXparam -> .)
    ID              reduce using rule 51 (sumXparam -> .)

    sumXparam                      shift and go to state 210

state 192

    (47) callingB -> exp checkParam callingC .

    )               reduce using rule 47 (callingB -> exp checkParam callingC .)


state 193

    (50) callingC -> empty .

    )               reduce using rule 50 (callingC -> empty .)


state 194

    (77) cycle -> WHILE gotoW ( expression ) gotoFalse block . continueGoW
    (126) continueGoW -> .

    MOD             reduce using rule 126 (continueGoW -> .)
    IF              reduce using rule 126 (continueGoW -> .)
    INPUT           reduce using rule 126 (continueGoW -> .)
    ECHO            reduce using rule 126 (continueGoW -> .)
    WHILE           reduce using rule 126 (continueGoW -> .)
    REPLAY          reduce using rule 126 (continueGoW -> .)
    SAMPLE          reduce using rule 126 (continueGoW -> .)
    #               reduce using rule 126 (continueGoW -> .)
    ARR             reduce using rule 126 (continueGoW -> .)
    MAT             reduce using rule 126 (continueGoW -> .)
    RETURN          reduce using rule 126 (continueGoW -> .)
    ID              reduce using rule 126 (continueGoW -> .)
    OVAL            reduce using rule 126 (continueGoW -> .)
    TRIO            reduce using rule 126 (continueGoW -> .)
    QUAD            reduce using rule 126 (continueGoW -> .)
    ARC             reduce using rule 126 (continueGoW -> .)
    END             reduce using rule 126 (continueGoW -> .)
    }               reduce using rule 126 (continueGoW -> .)

    continueGoW                    shift and go to state 211

state 195

    (78) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .

    IF              reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    INPUT           reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ECHO            reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHILE           reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    REPLAY          reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    SAMPLE          reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    #               reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARR             reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MAT             reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    RETURN          reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ID              reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    OVAL            reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    TRIO            reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    QUAD            reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARC             reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    }               reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MOD             reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    END             reduce using rule 78 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)


state 196

    (55) blockB -> statute . blockC
    (56) blockC -> . blockB
    (57) blockC -> . empty
    (55) blockB -> . statute blockC
    (129) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . read
    (12) statute -> . write
    (13) statute -> . cycle
    (14) statute -> . repeat
    (15) statute -> . command
    (16) statute -> . calling
    (17) statute -> . array
    (18) statute -> . matrix
    (19) statute -> . return
    (58) assign -> . id = expression ;
    (59) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (62) read -> . INPUT typeDim ID # ;
    (63) write -> . ECHO ( writeA writeB ) ;
    (77) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (78) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (73) command -> . figure exp exp color ;
    (74) command -> . SAMPLE commandA
    (40) calling -> . # callID calling2 ;
    (68) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (69) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (96) return -> . RETURN exp ;
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (99) figure -> . OVAL
    (100) figure -> . TRIO
    (101) figure -> . QUAD
    (102) figure -> . ARC
    (43) callID -> . ID

    }               reduce using rule 129 (empty -> .)
    IF              shift and go to state 17
    INPUT           shift and go to state 26
    ECHO            shift and go to state 22
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 23
    #               shift and go to state 14
    ARR             shift and go to state 31
    MAT             shift and go to state 32
    RETURN          shift and go to state 3
    ID              shift and go to state 27
    OVAL            shift and go to state 7
    TRIO            shift and go to state 18
    QUAD            shift and go to state 10
    ARC             shift and go to state 34

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    array                          shift and go to state 12
    id                             shift and go to state 13
    matrix                         shift and go to state 15
    write                          shift and go to state 16
    command                        shift and go to state 35
    empty                          shift and go to state 212
    repeat                         shift and go to state 19
    return                         shift and go to state 11
    read                           shift and go to state 21
    condition                      shift and go to state 28
    cycle                          shift and go to state 29
    statute                        shift and go to state 196
    calling                        shift and go to state 33
    blockC                         shift and go to state 213
    blockB                         shift and go to state 214
    assign                         shift and go to state 37

state 197

    (54) blockA -> } .

    ELSE            reduce using rule 54 (blockA -> } .)
    MOD             reduce using rule 54 (blockA -> } .)
    IF              reduce using rule 54 (blockA -> } .)
    INPUT           reduce using rule 54 (blockA -> } .)
    ECHO            reduce using rule 54 (blockA -> } .)
    WHILE           reduce using rule 54 (blockA -> } .)
    REPLAY          reduce using rule 54 (blockA -> } .)
    SAMPLE          reduce using rule 54 (blockA -> } .)
    #               reduce using rule 54 (blockA -> } .)
    ARR             reduce using rule 54 (blockA -> } .)
    MAT             reduce using rule 54 (blockA -> } .)
    RETURN          reduce using rule 54 (blockA -> } .)
    ID              reduce using rule 54 (blockA -> } .)
    OVAL            reduce using rule 54 (blockA -> } .)
    TRIO            reduce using rule 54 (blockA -> } .)
    QUAD            reduce using rule 54 (blockA -> } .)
    ARC             reduce using rule 54 (blockA -> } .)
    END             reduce using rule 54 (blockA -> } .)
    }               reduce using rule 54 (blockA -> } .)


state 198

    (53) blockA -> blockB . }

    }               shift and go to state 215


state 199

    (52) block -> { blockA .

    MOD             reduce using rule 52 (block -> { blockA .)
    IF              reduce using rule 52 (block -> { blockA .)
    INPUT           reduce using rule 52 (block -> { blockA .)
    ECHO            reduce using rule 52 (block -> { blockA .)
    WHILE           reduce using rule 52 (block -> { blockA .)
    REPLAY          reduce using rule 52 (block -> { blockA .)
    SAMPLE          reduce using rule 52 (block -> { blockA .)
    #               reduce using rule 52 (block -> { blockA .)
    ARR             reduce using rule 52 (block -> { blockA .)
    MAT             reduce using rule 52 (block -> { blockA .)
    RETURN          reduce using rule 52 (block -> { blockA .)
    ID              reduce using rule 52 (block -> { blockA .)
    OVAL            reduce using rule 52 (block -> { blockA .)
    TRIO            reduce using rule 52 (block -> { blockA .)
    QUAD            reduce using rule 52 (block -> { blockA .)
    ARC             reduce using rule 52 (block -> { blockA .)
    END             reduce using rule 52 (block -> { blockA .)
    }               reduce using rule 52 (block -> { blockA .)
    ELSE            reduce using rule 52 (block -> { blockA .)


state 200

    (59) condition -> IF ( expression ) gotoFalse block conditionA . continueGo
    (125) continueGo -> .

    MOD             reduce using rule 125 (continueGo -> .)
    IF              reduce using rule 125 (continueGo -> .)
    INPUT           reduce using rule 125 (continueGo -> .)
    ECHO            reduce using rule 125 (continueGo -> .)
    WHILE           reduce using rule 125 (continueGo -> .)
    REPLAY          reduce using rule 125 (continueGo -> .)
    SAMPLE          reduce using rule 125 (continueGo -> .)
    #               reduce using rule 125 (continueGo -> .)
    ARR             reduce using rule 125 (continueGo -> .)
    MAT             reduce using rule 125 (continueGo -> .)
    RETURN          reduce using rule 125 (continueGo -> .)
    ID              reduce using rule 125 (continueGo -> .)
    OVAL            reduce using rule 125 (continueGo -> .)
    TRIO            reduce using rule 125 (continueGo -> .)
    QUAD            reduce using rule 125 (continueGo -> .)
    ARC             reduce using rule 125 (continueGo -> .)
    END             reduce using rule 125 (continueGo -> .)
    }               reduce using rule 125 (continueGo -> .)

    continueGo                     shift and go to state 216

state 201

    (61) conditionA -> empty .

    MOD             reduce using rule 61 (conditionA -> empty .)
    IF              reduce using rule 61 (conditionA -> empty .)
    INPUT           reduce using rule 61 (conditionA -> empty .)
    ECHO            reduce using rule 61 (conditionA -> empty .)
    WHILE           reduce using rule 61 (conditionA -> empty .)
    REPLAY          reduce using rule 61 (conditionA -> empty .)
    SAMPLE          reduce using rule 61 (conditionA -> empty .)
    #               reduce using rule 61 (conditionA -> empty .)
    ARR             reduce using rule 61 (conditionA -> empty .)
    MAT             reduce using rule 61 (conditionA -> empty .)
    RETURN          reduce using rule 61 (conditionA -> empty .)
    ID              reduce using rule 61 (conditionA -> empty .)
    OVAL            reduce using rule 61 (conditionA -> empty .)
    TRIO            reduce using rule 61 (conditionA -> empty .)
    QUAD            reduce using rule 61 (conditionA -> empty .)
    ARC             reduce using rule 61 (conditionA -> empty .)
    END             reduce using rule 61 (conditionA -> empty .)
    }               reduce using rule 61 (conditionA -> empty .)


state 202

    (60) conditionA -> ELSE . gotoE block
    (122) gotoE -> .

    {               reduce using rule 122 (gotoE -> .)

    gotoE                          shift and go to state 217

state 203

    (75) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    INPUT           reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHILE           reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARR             reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    MAT             reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    RETURN          reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 75 (commandA -> ON move exp CTE_INTEGER color ; .)


state 204

    (35) id -> ID [ sumdim exp ] [ sumdim . exp ]
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    callID                         shift and go to state 5
    var_cte                        shift and go to state 39
    exp                            shift and go to state 218
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 205

    (68) array -> ARR typeDim ID [ CTE_INTEGER ] ; .

    IF              reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    INPUT           reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    #               reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    RETURN          reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ID              reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    }               reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    END             reduce using rule 68 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)


state 206

    (69) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 219


state 207

    (26) moduleA -> ( . vars ) block
    (29) vars -> . type ID varsA
    (32) type -> . INT
    (33) type -> . FLOAT
    (34) type -> . BOOL

    INT             shift and go to state 222
    FLOAT           shift and go to state 221
    BOOL            shift and go to state 223

    type                           shift and go to state 224
    vars                           shift and go to state 220

state 208

    (27) moduleA -> block .

    MOD             reduce using rule 27 (moduleA -> block .)
    IF              reduce using rule 27 (moduleA -> block .)
    INPUT           reduce using rule 27 (moduleA -> block .)
    ECHO            reduce using rule 27 (moduleA -> block .)
    WHILE           reduce using rule 27 (moduleA -> block .)
    REPLAY          reduce using rule 27 (moduleA -> block .)
    SAMPLE          reduce using rule 27 (moduleA -> block .)
    #               reduce using rule 27 (moduleA -> block .)
    ARR             reduce using rule 27 (moduleA -> block .)
    MAT             reduce using rule 27 (moduleA -> block .)
    RETURN          reduce using rule 27 (moduleA -> block .)
    ID              reduce using rule 27 (moduleA -> block .)
    OVAL            reduce using rule 27 (moduleA -> block .)
    TRIO            reduce using rule 27 (moduleA -> block .)
    QUAD            reduce using rule 27 (moduleA -> block .)
    ARC             reduce using rule 27 (moduleA -> block .)
    END             reduce using rule 27 (moduleA -> block .)


state 209

    (25) module -> MOD typeMod # moduleID addMod insertQuadMod moduleA . endMod
    (128) endMod -> .

    MOD             reduce using rule 128 (endMod -> .)
    IF              reduce using rule 128 (endMod -> .)
    INPUT           reduce using rule 128 (endMod -> .)
    ECHO            reduce using rule 128 (endMod -> .)
    WHILE           reduce using rule 128 (endMod -> .)
    REPLAY          reduce using rule 128 (endMod -> .)
    SAMPLE          reduce using rule 128 (endMod -> .)
    #               reduce using rule 128 (endMod -> .)
    ARR             reduce using rule 128 (endMod -> .)
    MAT             reduce using rule 128 (endMod -> .)
    RETURN          reduce using rule 128 (endMod -> .)
    ID              reduce using rule 128 (endMod -> .)
    OVAL            reduce using rule 128 (endMod -> .)
    TRIO            reduce using rule 128 (endMod -> .)
    QUAD            reduce using rule 128 (endMod -> .)
    ARC             reduce using rule 128 (endMod -> .)
    END             reduce using rule 128 (endMod -> .)

    endMod                         shift and go to state 225

state 210

    (49) callingC -> , sumXparam . callingB
    (47) callingB -> . exp checkParam callingC
    (91) exp -> . exp + exp
    (92) exp -> . exp - exp
    (93) exp -> . exp * exp
    (94) exp -> . exp / exp
    (95) exp -> . factor empty
    (97) factor -> . ( expression )
    (98) factor -> . var_cte
    (116) var_cte -> . id
    (117) var_cte -> . CTE_INTEGER
    (118) var_cte -> . CTE_FLOAT
    (119) var_cte -> . TRUE
    (120) var_cte -> . FALSE
    (35) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (36) id -> . ID [ sumdim exp ]
    (37) id -> . callID # calling2
    (38) id -> . ID empty
    (43) callID -> . ID

    (               shift and go to state 42
    CTE_INTEGER     shift and go to state 44
    CTE_FLOAT       shift and go to state 46
    TRUE            shift and go to state 40
    FALSE           shift and go to state 45
    ID              shift and go to state 27

    var_cte                        shift and go to state 39
    callID                         shift and go to state 5
    callingB                       shift and go to state 226
    exp                            shift and go to state 158
    factor                         shift and go to state 43
    id                             shift and go to state 41

state 211

    (77) cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .

    MOD             reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    IF              reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    INPUT           reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ECHO            reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHILE           reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    REPLAY          reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    SAMPLE          reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    #               reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARR             reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    MAT             reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    RETURN          reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ID              reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    OVAL            reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    TRIO            reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    QUAD            reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARC             reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    END             reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    }               reduce using rule 77 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)


state 212

    (57) blockC -> empty .

    }               reduce using rule 57 (blockC -> empty .)


state 213

    (55) blockB -> statute blockC .

    }               reduce using rule 55 (blockB -> statute blockC .)


state 214

    (56) blockC -> blockB .

    }               reduce using rule 56 (blockC -> blockB .)


state 215

    (53) blockA -> blockB } .

    ELSE            reduce using rule 53 (blockA -> blockB } .)
    MOD             reduce using rule 53 (blockA -> blockB } .)
    IF              reduce using rule 53 (blockA -> blockB } .)
    INPUT           reduce using rule 53 (blockA -> blockB } .)
    ECHO            reduce using rule 53 (blockA -> blockB } .)
    WHILE           reduce using rule 53 (blockA -> blockB } .)
    REPLAY          reduce using rule 53 (blockA -> blockB } .)
    SAMPLE          reduce using rule 53 (blockA -> blockB } .)
    #               reduce using rule 53 (blockA -> blockB } .)
    ARR             reduce using rule 53 (blockA -> blockB } .)
    MAT             reduce using rule 53 (blockA -> blockB } .)
    RETURN          reduce using rule 53 (blockA -> blockB } .)
    ID              reduce using rule 53 (blockA -> blockB } .)
    OVAL            reduce using rule 53 (blockA -> blockB } .)
    TRIO            reduce using rule 53 (blockA -> blockB } .)
    QUAD            reduce using rule 53 (blockA -> blockB } .)
    ARC             reduce using rule 53 (blockA -> blockB } .)
    END             reduce using rule 53 (blockA -> blockB } .)
    }               reduce using rule 53 (blockA -> blockB } .)


state 216

    (59) condition -> IF ( expression ) gotoFalse block conditionA continueGo .

    MOD             reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    IF              reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    INPUT           reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ECHO            reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHILE           reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    REPLAY          reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    SAMPLE          reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    #               reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARR             reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MAT             reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    RETURN          reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ID              reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    OVAL            reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    TRIO            reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    QUAD            reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARC             reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    END             reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    }               reduce using rule 59 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)


state 217

    (60) conditionA -> ELSE gotoE . block
    (52) block -> . { blockA

    {               shift and go to state 183

    block                          shift and go to state 227

state 218

    (35) id -> ID [ sumdim exp ] [ sumdim exp . ]
    (91) exp -> exp . + exp
    (92) exp -> exp . - exp
    (93) exp -> exp . * exp
    (94) exp -> exp . / exp

    ]               shift and go to state 228
    +               shift and go to state 80
    -               shift and go to state 82
    *               shift and go to state 81
    /               shift and go to state 83


state 219

    (69) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER . ] ;

    ]               shift and go to state 229


state 220

    (26) moduleA -> ( vars . ) block

    )               shift and go to state 230


state 221

    (33) type -> FLOAT .

    ID              reduce using rule 33 (type -> FLOAT .)


state 222

    (32) type -> INT .

    ID              reduce using rule 32 (type -> INT .)


state 223

    (34) type -> BOOL .

    ID              reduce using rule 34 (type -> BOOL .)


state 224

    (29) vars -> type . ID varsA

    ID              shift and go to state 231


state 225

    (25) module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .

    MOD             reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    IF              reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    INPUT           reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ECHO            reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    WHILE           reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    REPLAY          reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    SAMPLE          reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    #               reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ARR             reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    MAT             reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    RETURN          reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ID              reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    OVAL            reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    TRIO            reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    QUAD            reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ARC             reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    END             reduce using rule 25 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)


state 226

    (49) callingC -> , sumXparam callingB .

    )               reduce using rule 49 (callingC -> , sumXparam callingB .)


state 227

    (60) conditionA -> ELSE gotoE block .

    MOD             reduce using rule 60 (conditionA -> ELSE gotoE block .)
    IF              reduce using rule 60 (conditionA -> ELSE gotoE block .)
    INPUT           reduce using rule 60 (conditionA -> ELSE gotoE block .)
    ECHO            reduce using rule 60 (conditionA -> ELSE gotoE block .)
    WHILE           reduce using rule 60 (conditionA -> ELSE gotoE block .)
    REPLAY          reduce using rule 60 (conditionA -> ELSE gotoE block .)
    SAMPLE          reduce using rule 60 (conditionA -> ELSE gotoE block .)
    #               reduce using rule 60 (conditionA -> ELSE gotoE block .)
    ARR             reduce using rule 60 (conditionA -> ELSE gotoE block .)
    MAT             reduce using rule 60 (conditionA -> ELSE gotoE block .)
    RETURN          reduce using rule 60 (conditionA -> ELSE gotoE block .)
    ID              reduce using rule 60 (conditionA -> ELSE gotoE block .)
    OVAL            reduce using rule 60 (conditionA -> ELSE gotoE block .)
    TRIO            reduce using rule 60 (conditionA -> ELSE gotoE block .)
    QUAD            reduce using rule 60 (conditionA -> ELSE gotoE block .)
    ARC             reduce using rule 60 (conditionA -> ELSE gotoE block .)
    END             reduce using rule 60 (conditionA -> ELSE gotoE block .)
    }               reduce using rule 60 (conditionA -> ELSE gotoE block .)


state 228

    (35) id -> ID [ sumdim exp ] [ sumdim exp ] .

    =               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ]               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    +               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    -               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    *               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    /               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    )               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ;               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ,               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    RED             reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    YELLOW          reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    BLUE            reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    GREEN           reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    BLACK           reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    WHITE           reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ORANGE          reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    PURPLE          reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CYAN            reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    (               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    TRUE            reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    FALSE           reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ID              reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    <               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    >               reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    AND             reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    OR              reduce using rule 35 (id -> ID [ sumdim exp ] [ sumdim exp ] .)


state 229

    (69) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] . ;

    ;               shift and go to state 232


state 230

    (26) moduleA -> ( vars ) . block
    (52) block -> . { blockA

    {               shift and go to state 183

    block                          shift and go to state 233

state 231

    (29) vars -> type ID . varsA
    (30) varsA -> . , vars
    (31) varsA -> . empty
    (129) empty -> .

    ,               shift and go to state 235
    )               reduce using rule 129 (empty -> .)

    varsA                          shift and go to state 234
    empty                          shift and go to state 236

state 232

    (69) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .

    IF              reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    INPUT           reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    #               reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    RETURN          reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ID              reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    }               reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    END             reduce using rule 69 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)


state 233

    (26) moduleA -> ( vars ) block .

    MOD             reduce using rule 26 (moduleA -> ( vars ) block .)
    IF              reduce using rule 26 (moduleA -> ( vars ) block .)
    INPUT           reduce using rule 26 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 26 (moduleA -> ( vars ) block .)
    WHILE           reduce using rule 26 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 26 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 26 (moduleA -> ( vars ) block .)
    #               reduce using rule 26 (moduleA -> ( vars ) block .)
    ARR             reduce using rule 26 (moduleA -> ( vars ) block .)
    MAT             reduce using rule 26 (moduleA -> ( vars ) block .)
    RETURN          reduce using rule 26 (moduleA -> ( vars ) block .)
    ID              reduce using rule 26 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 26 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 26 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 26 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 26 (moduleA -> ( vars ) block .)
    END             reduce using rule 26 (moduleA -> ( vars ) block .)


state 234

    (29) vars -> type ID varsA .

    )               reduce using rule 29 (vars -> type ID varsA .)


state 235

    (30) varsA -> , . vars
    (29) vars -> . type ID varsA
    (32) type -> . INT
    (33) type -> . FLOAT
    (34) type -> . BOOL

    INT             shift and go to state 222
    FLOAT           shift and go to state 221
    BOOL            shift and go to state 223

    type                           shift and go to state 224
    vars                           shift and go to state 237

state 236

    (31) varsA -> empty .

    )               reduce using rule 31 (varsA -> empty .)


state 237

    (30) varsA -> , vars .

    )               reduce using rule 30 (varsA -> , vars .)

