Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> write
Rule 12    statute -> cycle
Rule 13    statute -> repeat
Rule 14    statute -> command
Rule 15    statute -> calling
Rule 16    statute -> array
Rule 17    statute -> matrix
Rule 18    statute -> pipeline
Rule 19    statute -> screen
Rule 20    module -> MOD # moduleID insertQuadMod moduleA endMod
Rule 21    moduleA -> ( vars ) block
Rule 22    moduleA -> block
Rule 23    moduleID -> ID
Rule 24    vars -> type ID varsA
Rule 25    varsA -> , vars
Rule 26    varsA -> empty
Rule 27    type -> INT
Rule 28    type -> FLOAT
Rule 29    type -> BOOL
Rule 30    id -> ID [ sumdim exp ] [ sumdim exp ]
Rule 31    id -> ID [ sumdim exp ]
Rule 32    id -> ID
Rule 33    sumdim -> <empty>
Rule 34    calling -> # callID ( insertEra callingA
Rule 35    callID -> ID
Rule 36    insertEra -> <empty>
Rule 37    callingA -> callingB ) ;
Rule 38    callingA -> ) ;
Rule 39    callingB -> expression checkParam callingC
Rule 40    checkParam -> <empty>
Rule 41    callingC -> , sumXparam callingB
Rule 42    callingC -> empty
Rule 43    sumXparam -> <empty>
Rule 44    block -> { blockA
Rule 45    blockA -> blockB }
Rule 46    blockA -> }
Rule 47    blockB -> statute blockC
Rule 48    blockC -> blockB
Rule 49    blockC -> empty
Rule 50    assign -> id = expression ;
Rule 51    condition -> IF ( expression ) gotoFalse block conditionA continueGo
Rule 52    conditionA -> ELSE gotoE block
Rule 53    conditionA -> empty
Rule 54    write -> ECHO writeA ;
Rule 55    writeA -> expression
Rule 56    writeA -> CTE_STRING
Rule 57    array -> ARR typeDim ID [ CTE_INTEGER ] ;
Rule 58    matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
Rule 59    pipeline -> PIPE ID pipelineA
Rule 60    pipelineA -> [ pipelineB ] ;
Rule 61    pipelineA -> IN ( var_cte ) ;
Rule 62    pipelineA -> OUT ( ) ;
Rule 63    pipelineA -> COUNT ;
Rule 64    pipelineB -> exp pipelineC
Rule 65    pipelineC -> , pipelineB
Rule 66    pipelineC -> empty
Rule 67    typeDim -> INT
Rule 68    typeDim -> FLOAT
Rule 69    typeDim -> BOOL
Rule 70    command -> figure exp exp color ;
Rule 71    command -> SAMPLE commandA
Rule 72    commandA -> ON move exp CTE_INTEGER color ;
Rule 73    commandA -> OFF move exp ;
Rule 74    cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW
Rule 75    repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ;
Rule 76    repeatA -> command repeatB
Rule 77    repeatB -> repeatA
Rule 78    repeatB -> empty
Rule 79    expression -> exp = = exp
Rule 80    expression -> exp < > exp
Rule 81    expression -> exp < = exp
Rule 82    expression -> exp > = exp
Rule 83    expression -> exp > exp
Rule 84    expression -> exp < exp
Rule 85    expression -> exp AND exp
Rule 86    expression -> exp OR exp
Rule 87    expression -> exp empty
Rule 88    exp -> exp + exp
Rule 89    exp -> exp - exp
Rule 90    exp -> exp * exp
Rule 91    exp -> exp / exp
Rule 92    exp -> factor empty
Rule 93    factor -> ( expression )
Rule 94    factor -> var_cte
Rule 95    figure -> OVAL
Rule 96    figure -> TRIO
Rule 97    figure -> QUAD
Rule 98    figure -> ARC
Rule 99    move -> UP
Rule 100   move -> DOWN
Rule 101   move -> LEFT
Rule 102   move -> RIGHT
Rule 103   color -> RED
Rule 104   color -> YELLOW
Rule 105   color -> BLUE
Rule 106   color -> GREEN
Rule 107   color -> BLACK
Rule 108   color -> WHITE
Rule 109   color -> ORANGE
Rule 110   color -> PURPLE
Rule 111   color -> CYAN
Rule 112   screen -> WHERE
Rule 113   screen -> CLEAR
Rule 114   var_cte -> ID
Rule 115   var_cte -> CTE_INTEGER
Rule 116   var_cte -> CTE_FLOAT
Rule 117   var_cte -> TRUE
Rule 118   var_cte -> FALSE
Rule 119   gotoFalse -> <empty>
Rule 120   gotoE -> <empty>
Rule 121   gotoW -> <empty>
Rule 122   gotoR -> <empty>
Rule 123   continueGo -> <empty>
Rule 124   continueGoW -> <empty>
Rule 125   insertQuadMod -> <empty>
Rule 126   endMod -> <empty>
Rule 127   empty -> <empty>

Terminals, with rules where they appear

#                    : 20 34
(                    : 21 34 51 61 62 74 93
)                    : 21 37 38 51 61 62 74 93
*                    : 90
+                    : 88
,                    : 25 41 65
-                    : 89
/                    : 91
;                    : 37 38 50 54 57 58 60 61 62 63 70 72 73 75
<                    : 80 81 84
=                    : 50 79 79 81 82
>                    : 80 82 83
AND                  : 85
ARC                  : 98
ARR                  : 57
BLACK                : 107
BLUE                 : 105
BOOL                 : 29 69
CLEAR                : 113
COUNT                : 63
CTE_FLOAT            : 116
CTE_INTEGER          : 57 58 58 72 75 115
CTE_STRING           : 56
CYAN                 : 111
DOWN                 : 100
ECHO                 : 54
ELSE                 : 52
END                  : 2 3
FALSE                : 118
FLOAT                : 28 68
GREEN                : 106
ID                   : 23 24 30 31 32 35 57 58 59 114
IF                   : 51
IN                   : 61
INIT                 : 1
INT                  : 27 67
LEFT                 : 101
MAT                  : 58
MOD                  : 20
OFF                  : 73
ON                   : 72
OR                   : 86
ORANGE               : 109
OUT                  : 62
OVAL                 : 95
PIPE                 : 59
PURPLE               : 110
QUAD                 : 97
RED                  : 103
REPLAY               : 75
RIGHT                : 102
SAMPLE               : 71
TRIO                 : 96
TRUE                 : 117
UP                   : 99
WHERE                : 112
WHILE                : 74
WHITE                : 108
YELLOW               : 104
[                    : 30 30 31 57 58 58 60 75
]                    : 30 30 31 57 58 58 60 75
error                : 
{                    : 44
}                    : 45 46

Nonterminals, with rules where they appear

array                : 16
assign               : 9
block                : 21 22 51 52 74
blockA               : 44
blockB               : 45 48
blockC               : 47
callID               : 34
calling              : 15
callingA             : 34
callingB             : 37 41
callingC             : 39
checkParam           : 39
color                : 70 72
command              : 14 76
commandA             : 71
condition            : 10
conditionA           : 51
continueGo           : 51
continueGoW          : 74
cycle                : 12
empty                : 6 26 42 49 53 66 78 87 92
endMod               : 20
exp                  : 30 30 31 64 70 70 72 73 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 88 88 89 89 90 90 91 91
expression           : 39 50 51 55 74 93
factor               : 92
figure               : 70
gotoE                : 52
gotoFalse            : 51 74
gotoR                : 75
gotoW                : 74
id                   : 50
insertEra            : 34
insertQuadMod        : 20
matrix               : 17
module               : 8
moduleA              : 20
moduleID             : 20
move                 : 72 73
pipeline             : 18
pipelineA            : 59
pipelineB            : 60 65
pipelineC            : 64
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
repeat               : 13
repeatA              : 75 77
repeatB              : 76
screen               : 19
statute              : 7 47
sumXparam            : 41
sumdim               : 30 30 31
type                 : 24
typeDim              : 57 58
var_cte              : 61 94
vars                 : 21 25
varsA                : 24
workspace            : 4
write                : 11
writeA               : 54

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (20) module -> . MOD # moduleID insertQuadMod moduleA endMod
    (50) assign -> . id = expression ;
    (51) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (54) write -> . ECHO writeA ;
    (74) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (75) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (70) command -> . figure exp exp color ;
    (71) command -> . SAMPLE commandA
    (34) calling -> . # callID ( insertEra callingA
    (57) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (58) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (59) pipeline -> . PIPE ID pipelineA
    (112) screen -> . WHERE
    (113) screen -> . CLEAR
    (30) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (31) id -> . ID [ sumdim exp ]
    (32) id -> . ID
    (95) figure -> . OVAL
    (96) figure -> . TRIO
    (97) figure -> . QUAD
    (98) figure -> . ARC

    END             shift and go to state 18
    MOD             shift and go to state 37
    IF              shift and go to state 14
    ECHO            shift and go to state 21
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 22
    #               shift and go to state 11
    ARR             shift and go to state 20
    MAT             shift and go to state 31
    PIPE            shift and go to state 10
    WHERE           shift and go to state 33
    CLEAR           shift and go to state 15
    ID              shift and go to state 26
    OVAL            shift and go to state 5
    TRIO            shift and go to state 16
    QUAD            shift and go to state 25
    ARC             shift and go to state 34

    figure                         shift and go to state 3
    module                         shift and go to state 4
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 12
    write                          shift and go to state 13
    condition                      shift and go to state 27
    repeat                         shift and go to state 17
    screen                         shift and go to state 19
    programA                       shift and go to state 23
    programB                       shift and go to state 24
    cycle                          shift and go to state 28
    statute                        shift and go to state 29
    pipeline                       shift and go to state 30
    calling                        shift and go to state 32
    command                        shift and go to state 35
    workspace                      shift and go to state 36
    assign                         shift and go to state 38

state 2

    (0) S' -> program .



state 3

    (70) command -> figure . exp exp color ;
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 44
    factor                         shift and go to state 45

state 4

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    WHILE           reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    ARR             reduce using rule 8 (workspace -> module .)
    MAT             reduce using rule 8 (workspace -> module .)
    PIPE            reduce using rule 8 (workspace -> module .)
    WHERE           reduce using rule 8 (workspace -> module .)
    CLEAR           reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 5

    (95) figure -> OVAL .

    (               reduce using rule 95 (figure -> OVAL .)
    ID              reduce using rule 95 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 95 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 95 (figure -> OVAL .)
    TRUE            reduce using rule 95 (figure -> OVAL .)
    FALSE           reduce using rule 95 (figure -> OVAL .)


state 6

    (74) cycle -> WHILE . gotoW ( expression ) gotoFalse block continueGoW
    (121) gotoW -> .

    (               reduce using rule 121 (gotoW -> .)

    gotoW                          shift and go to state 48

state 7

    (75) repeat -> REPLAY . CTE_INTEGER gotoR [ repeatA ] ;

    CTE_INTEGER     shift and go to state 49


state 8

    (16) statute -> array .

    IF              reduce using rule 16 (statute -> array .)
    ECHO            reduce using rule 16 (statute -> array .)
    WHILE           reduce using rule 16 (statute -> array .)
    REPLAY          reduce using rule 16 (statute -> array .)
    SAMPLE          reduce using rule 16 (statute -> array .)
    #               reduce using rule 16 (statute -> array .)
    ARR             reduce using rule 16 (statute -> array .)
    MAT             reduce using rule 16 (statute -> array .)
    PIPE            reduce using rule 16 (statute -> array .)
    WHERE           reduce using rule 16 (statute -> array .)
    CLEAR           reduce using rule 16 (statute -> array .)
    ID              reduce using rule 16 (statute -> array .)
    OVAL            reduce using rule 16 (statute -> array .)
    TRIO            reduce using rule 16 (statute -> array .)
    QUAD            reduce using rule 16 (statute -> array .)
    ARC             reduce using rule 16 (statute -> array .)
    }               reduce using rule 16 (statute -> array .)
    MOD             reduce using rule 16 (statute -> array .)
    END             reduce using rule 16 (statute -> array .)


state 9

    (50) assign -> id . = expression ;

    =               shift and go to state 50


state 10

    (59) pipeline -> PIPE . ID pipelineA

    ID              shift and go to state 51


state 11

    (34) calling -> # . callID ( insertEra callingA
    (35) callID -> . ID

    ID              shift and go to state 53

    callID                         shift and go to state 52

state 12

    (17) statute -> matrix .

    IF              reduce using rule 17 (statute -> matrix .)
    ECHO            reduce using rule 17 (statute -> matrix .)
    WHILE           reduce using rule 17 (statute -> matrix .)
    REPLAY          reduce using rule 17 (statute -> matrix .)
    SAMPLE          reduce using rule 17 (statute -> matrix .)
    #               reduce using rule 17 (statute -> matrix .)
    ARR             reduce using rule 17 (statute -> matrix .)
    MAT             reduce using rule 17 (statute -> matrix .)
    PIPE            reduce using rule 17 (statute -> matrix .)
    WHERE           reduce using rule 17 (statute -> matrix .)
    CLEAR           reduce using rule 17 (statute -> matrix .)
    ID              reduce using rule 17 (statute -> matrix .)
    OVAL            reduce using rule 17 (statute -> matrix .)
    TRIO            reduce using rule 17 (statute -> matrix .)
    QUAD            reduce using rule 17 (statute -> matrix .)
    ARC             reduce using rule 17 (statute -> matrix .)
    }               reduce using rule 17 (statute -> matrix .)
    MOD             reduce using rule 17 (statute -> matrix .)
    END             reduce using rule 17 (statute -> matrix .)


state 13

    (11) statute -> write .

    IF              reduce using rule 11 (statute -> write .)
    ECHO            reduce using rule 11 (statute -> write .)
    WHILE           reduce using rule 11 (statute -> write .)
    REPLAY          reduce using rule 11 (statute -> write .)
    SAMPLE          reduce using rule 11 (statute -> write .)
    #               reduce using rule 11 (statute -> write .)
    ARR             reduce using rule 11 (statute -> write .)
    MAT             reduce using rule 11 (statute -> write .)
    PIPE            reduce using rule 11 (statute -> write .)
    WHERE           reduce using rule 11 (statute -> write .)
    CLEAR           reduce using rule 11 (statute -> write .)
    ID              reduce using rule 11 (statute -> write .)
    OVAL            reduce using rule 11 (statute -> write .)
    TRIO            reduce using rule 11 (statute -> write .)
    QUAD            reduce using rule 11 (statute -> write .)
    ARC             reduce using rule 11 (statute -> write .)
    }               reduce using rule 11 (statute -> write .)
    MOD             reduce using rule 11 (statute -> write .)
    END             reduce using rule 11 (statute -> write .)


state 14

    (51) condition -> IF . ( expression ) gotoFalse block conditionA continueGo

    (               shift and go to state 54


state 15

    (113) screen -> CLEAR .

    MOD             reduce using rule 113 (screen -> CLEAR .)
    IF              reduce using rule 113 (screen -> CLEAR .)
    ECHO            reduce using rule 113 (screen -> CLEAR .)
    WHILE           reduce using rule 113 (screen -> CLEAR .)
    REPLAY          reduce using rule 113 (screen -> CLEAR .)
    SAMPLE          reduce using rule 113 (screen -> CLEAR .)
    #               reduce using rule 113 (screen -> CLEAR .)
    ARR             reduce using rule 113 (screen -> CLEAR .)
    MAT             reduce using rule 113 (screen -> CLEAR .)
    PIPE            reduce using rule 113 (screen -> CLEAR .)
    WHERE           reduce using rule 113 (screen -> CLEAR .)
    CLEAR           reduce using rule 113 (screen -> CLEAR .)
    ID              reduce using rule 113 (screen -> CLEAR .)
    OVAL            reduce using rule 113 (screen -> CLEAR .)
    TRIO            reduce using rule 113 (screen -> CLEAR .)
    QUAD            reduce using rule 113 (screen -> CLEAR .)
    ARC             reduce using rule 113 (screen -> CLEAR .)
    END             reduce using rule 113 (screen -> CLEAR .)
    }               reduce using rule 113 (screen -> CLEAR .)


state 16

    (96) figure -> TRIO .

    (               reduce using rule 96 (figure -> TRIO .)
    ID              reduce using rule 96 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 96 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 96 (figure -> TRIO .)
    TRUE            reduce using rule 96 (figure -> TRIO .)
    FALSE           reduce using rule 96 (figure -> TRIO .)


state 17

    (13) statute -> repeat .

    IF              reduce using rule 13 (statute -> repeat .)
    ECHO            reduce using rule 13 (statute -> repeat .)
    WHILE           reduce using rule 13 (statute -> repeat .)
    REPLAY          reduce using rule 13 (statute -> repeat .)
    SAMPLE          reduce using rule 13 (statute -> repeat .)
    #               reduce using rule 13 (statute -> repeat .)
    ARR             reduce using rule 13 (statute -> repeat .)
    MAT             reduce using rule 13 (statute -> repeat .)
    PIPE            reduce using rule 13 (statute -> repeat .)
    WHERE           reduce using rule 13 (statute -> repeat .)
    CLEAR           reduce using rule 13 (statute -> repeat .)
    ID              reduce using rule 13 (statute -> repeat .)
    OVAL            reduce using rule 13 (statute -> repeat .)
    TRIO            reduce using rule 13 (statute -> repeat .)
    QUAD            reduce using rule 13 (statute -> repeat .)
    ARC             reduce using rule 13 (statute -> repeat .)
    }               reduce using rule 13 (statute -> repeat .)
    MOD             reduce using rule 13 (statute -> repeat .)
    END             reduce using rule 13 (statute -> repeat .)


state 18

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 19

    (19) statute -> screen .

    IF              reduce using rule 19 (statute -> screen .)
    ECHO            reduce using rule 19 (statute -> screen .)
    WHILE           reduce using rule 19 (statute -> screen .)
    REPLAY          reduce using rule 19 (statute -> screen .)
    SAMPLE          reduce using rule 19 (statute -> screen .)
    #               reduce using rule 19 (statute -> screen .)
    ARR             reduce using rule 19 (statute -> screen .)
    MAT             reduce using rule 19 (statute -> screen .)
    PIPE            reduce using rule 19 (statute -> screen .)
    WHERE           reduce using rule 19 (statute -> screen .)
    CLEAR           reduce using rule 19 (statute -> screen .)
    ID              reduce using rule 19 (statute -> screen .)
    OVAL            reduce using rule 19 (statute -> screen .)
    TRIO            reduce using rule 19 (statute -> screen .)
    QUAD            reduce using rule 19 (statute -> screen .)
    ARC             reduce using rule 19 (statute -> screen .)
    }               reduce using rule 19 (statute -> screen .)
    MOD             reduce using rule 19 (statute -> screen .)
    END             reduce using rule 19 (statute -> screen .)


state 20

    (57) array -> ARR . typeDim ID [ CTE_INTEGER ] ;
    (67) typeDim -> . INT
    (68) typeDim -> . FLOAT
    (69) typeDim -> . BOOL

    INT             shift and go to state 55
    FLOAT           shift and go to state 56
    BOOL            shift and go to state 58

    typeDim                        shift and go to state 57

state 21

    (54) write -> ECHO . writeA ;
    (55) writeA -> . expression
    (56) writeA -> . CTE_STRING
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    CTE_STRING      shift and go to state 60
    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 61
    factor                         shift and go to state 45
    writeA                         shift and go to state 59
    expression                     shift and go to state 62

state 22

    (71) command -> SAMPLE . commandA
    (72) commandA -> . ON move exp CTE_INTEGER color ;
    (73) commandA -> . OFF move exp ;

    ON              shift and go to state 65
    OFF             shift and go to state 64

    commandA                       shift and go to state 63

state 23

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 24

    (2) programA -> programB . END

    END             shift and go to state 66


state 25

    (97) figure -> QUAD .

    (               reduce using rule 97 (figure -> QUAD .)
    ID              reduce using rule 97 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 97 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 97 (figure -> QUAD .)
    TRUE            reduce using rule 97 (figure -> QUAD .)
    FALSE           reduce using rule 97 (figure -> QUAD .)


state 26

    (30) id -> ID . [ sumdim exp ] [ sumdim exp ]
    (31) id -> ID . [ sumdim exp ]
    (32) id -> ID .

    [               shift and go to state 67
    =               reduce using rule 32 (id -> ID .)


state 27

    (10) statute -> condition .

    IF              reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    WHILE           reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    ARR             reduce using rule 10 (statute -> condition .)
    MAT             reduce using rule 10 (statute -> condition .)
    PIPE            reduce using rule 10 (statute -> condition .)
    WHERE           reduce using rule 10 (statute -> condition .)
    CLEAR           reduce using rule 10 (statute -> condition .)
    ID              reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)
    MOD             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)


state 28

    (12) statute -> cycle .

    IF              reduce using rule 12 (statute -> cycle .)
    ECHO            reduce using rule 12 (statute -> cycle .)
    WHILE           reduce using rule 12 (statute -> cycle .)
    REPLAY          reduce using rule 12 (statute -> cycle .)
    SAMPLE          reduce using rule 12 (statute -> cycle .)
    #               reduce using rule 12 (statute -> cycle .)
    ARR             reduce using rule 12 (statute -> cycle .)
    MAT             reduce using rule 12 (statute -> cycle .)
    PIPE            reduce using rule 12 (statute -> cycle .)
    WHERE           reduce using rule 12 (statute -> cycle .)
    CLEAR           reduce using rule 12 (statute -> cycle .)
    ID              reduce using rule 12 (statute -> cycle .)
    OVAL            reduce using rule 12 (statute -> cycle .)
    TRIO            reduce using rule 12 (statute -> cycle .)
    QUAD            reduce using rule 12 (statute -> cycle .)
    ARC             reduce using rule 12 (statute -> cycle .)
    }               reduce using rule 12 (statute -> cycle .)
    MOD             reduce using rule 12 (statute -> cycle .)
    END             reduce using rule 12 (statute -> cycle .)


state 29

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    WHILE           reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    ARR             reduce using rule 7 (workspace -> statute .)
    MAT             reduce using rule 7 (workspace -> statute .)
    PIPE            reduce using rule 7 (workspace -> statute .)
    WHERE           reduce using rule 7 (workspace -> statute .)
    CLEAR           reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 30

    (18) statute -> pipeline .

    IF              reduce using rule 18 (statute -> pipeline .)
    ECHO            reduce using rule 18 (statute -> pipeline .)
    WHILE           reduce using rule 18 (statute -> pipeline .)
    REPLAY          reduce using rule 18 (statute -> pipeline .)
    SAMPLE          reduce using rule 18 (statute -> pipeline .)
    #               reduce using rule 18 (statute -> pipeline .)
    ARR             reduce using rule 18 (statute -> pipeline .)
    MAT             reduce using rule 18 (statute -> pipeline .)
    PIPE            reduce using rule 18 (statute -> pipeline .)
    WHERE           reduce using rule 18 (statute -> pipeline .)
    CLEAR           reduce using rule 18 (statute -> pipeline .)
    ID              reduce using rule 18 (statute -> pipeline .)
    OVAL            reduce using rule 18 (statute -> pipeline .)
    TRIO            reduce using rule 18 (statute -> pipeline .)
    QUAD            reduce using rule 18 (statute -> pipeline .)
    ARC             reduce using rule 18 (statute -> pipeline .)
    }               reduce using rule 18 (statute -> pipeline .)
    MOD             reduce using rule 18 (statute -> pipeline .)
    END             reduce using rule 18 (statute -> pipeline .)


state 31

    (58) matrix -> MAT . typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (67) typeDim -> . INT
    (68) typeDim -> . FLOAT
    (69) typeDim -> . BOOL

    INT             shift and go to state 55
    FLOAT           shift and go to state 56
    BOOL            shift and go to state 58

    typeDim                        shift and go to state 68

state 32

    (15) statute -> calling .

    IF              reduce using rule 15 (statute -> calling .)
    ECHO            reduce using rule 15 (statute -> calling .)
    WHILE           reduce using rule 15 (statute -> calling .)
    REPLAY          reduce using rule 15 (statute -> calling .)
    SAMPLE          reduce using rule 15 (statute -> calling .)
    #               reduce using rule 15 (statute -> calling .)
    ARR             reduce using rule 15 (statute -> calling .)
    MAT             reduce using rule 15 (statute -> calling .)
    PIPE            reduce using rule 15 (statute -> calling .)
    WHERE           reduce using rule 15 (statute -> calling .)
    CLEAR           reduce using rule 15 (statute -> calling .)
    ID              reduce using rule 15 (statute -> calling .)
    OVAL            reduce using rule 15 (statute -> calling .)
    TRIO            reduce using rule 15 (statute -> calling .)
    QUAD            reduce using rule 15 (statute -> calling .)
    ARC             reduce using rule 15 (statute -> calling .)
    }               reduce using rule 15 (statute -> calling .)
    MOD             reduce using rule 15 (statute -> calling .)
    END             reduce using rule 15 (statute -> calling .)


state 33

    (112) screen -> WHERE .

    MOD             reduce using rule 112 (screen -> WHERE .)
    IF              reduce using rule 112 (screen -> WHERE .)
    ECHO            reduce using rule 112 (screen -> WHERE .)
    WHILE           reduce using rule 112 (screen -> WHERE .)
    REPLAY          reduce using rule 112 (screen -> WHERE .)
    SAMPLE          reduce using rule 112 (screen -> WHERE .)
    #               reduce using rule 112 (screen -> WHERE .)
    ARR             reduce using rule 112 (screen -> WHERE .)
    MAT             reduce using rule 112 (screen -> WHERE .)
    PIPE            reduce using rule 112 (screen -> WHERE .)
    WHERE           reduce using rule 112 (screen -> WHERE .)
    CLEAR           reduce using rule 112 (screen -> WHERE .)
    ID              reduce using rule 112 (screen -> WHERE .)
    OVAL            reduce using rule 112 (screen -> WHERE .)
    TRIO            reduce using rule 112 (screen -> WHERE .)
    QUAD            reduce using rule 112 (screen -> WHERE .)
    ARC             reduce using rule 112 (screen -> WHERE .)
    END             reduce using rule 112 (screen -> WHERE .)
    }               reduce using rule 112 (screen -> WHERE .)


state 34

    (98) figure -> ARC .

    (               reduce using rule 98 (figure -> ARC .)
    ID              reduce using rule 98 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 98 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 98 (figure -> ARC .)
    TRUE            reduce using rule 98 (figure -> ARC .)
    FALSE           reduce using rule 98 (figure -> ARC .)


state 35

    (14) statute -> command .

    IF              reduce using rule 14 (statute -> command .)
    ECHO            reduce using rule 14 (statute -> command .)
    WHILE           reduce using rule 14 (statute -> command .)
    REPLAY          reduce using rule 14 (statute -> command .)
    SAMPLE          reduce using rule 14 (statute -> command .)
    #               reduce using rule 14 (statute -> command .)
    ARR             reduce using rule 14 (statute -> command .)
    MAT             reduce using rule 14 (statute -> command .)
    PIPE            reduce using rule 14 (statute -> command .)
    WHERE           reduce using rule 14 (statute -> command .)
    CLEAR           reduce using rule 14 (statute -> command .)
    ID              reduce using rule 14 (statute -> command .)
    OVAL            reduce using rule 14 (statute -> command .)
    TRIO            reduce using rule 14 (statute -> command .)
    QUAD            reduce using rule 14 (statute -> command .)
    ARC             reduce using rule 14 (statute -> command .)
    }               reduce using rule 14 (statute -> command .)
    MOD             reduce using rule 14 (statute -> command .)
    END             reduce using rule 14 (statute -> command .)


state 36

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (127) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (20) module -> . MOD # moduleID insertQuadMod moduleA endMod
    (50) assign -> . id = expression ;
    (51) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (54) write -> . ECHO writeA ;
    (74) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (75) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (70) command -> . figure exp exp color ;
    (71) command -> . SAMPLE commandA
    (34) calling -> . # callID ( insertEra callingA
    (57) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (58) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (59) pipeline -> . PIPE ID pipelineA
    (112) screen -> . WHERE
    (113) screen -> . CLEAR
    (30) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (31) id -> . ID [ sumdim exp ]
    (32) id -> . ID
    (95) figure -> . OVAL
    (96) figure -> . TRIO
    (97) figure -> . QUAD
    (98) figure -> . ARC

    END             reduce using rule 127 (empty -> .)
    MOD             shift and go to state 37
    IF              shift and go to state 14
    ECHO            shift and go to state 21
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 22
    #               shift and go to state 11
    ARR             shift and go to state 20
    MAT             shift and go to state 31
    PIPE            shift and go to state 10
    WHERE           shift and go to state 33
    CLEAR           shift and go to state 15
    ID              shift and go to state 26
    OVAL            shift and go to state 5
    TRIO            shift and go to state 16
    QUAD            shift and go to state 25
    ARC             shift and go to state 34

    figure                         shift and go to state 3
    module                         shift and go to state 4
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 12
    write                          shift and go to state 13
    condition                      shift and go to state 27
    empty                          shift and go to state 69
    repeat                         shift and go to state 17
    screen                         shift and go to state 19
    programB                       shift and go to state 70
    programC                       shift and go to state 71
    cycle                          shift and go to state 28
    statute                        shift and go to state 29
    pipeline                       shift and go to state 30
    calling                        shift and go to state 32
    command                        shift and go to state 35
    workspace                      shift and go to state 36
    assign                         shift and go to state 38

state 37

    (20) module -> MOD . # moduleID insertQuadMod moduleA endMod

    #               shift and go to state 72


state 38

    (9) statute -> assign .

    IF              reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    WHILE           reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    ARR             reduce using rule 9 (statute -> assign .)
    MAT             reduce using rule 9 (statute -> assign .)
    PIPE            reduce using rule 9 (statute -> assign .)
    WHERE           reduce using rule 9 (statute -> assign .)
    CLEAR           reduce using rule 9 (statute -> assign .)
    ID              reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)
    MOD             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)


state 39

    (116) var_cte -> CTE_FLOAT .

    =               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 116 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 116 (var_cte -> CTE_FLOAT .)
    +               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 116 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 116 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 116 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    WHITE           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 116 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 116 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 116 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 116 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 116 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 116 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 116 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 116 (var_cte -> CTE_FLOAT .)


state 40

    (93) factor -> ( . expression )
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    expression                     shift and go to state 73
    exp                            shift and go to state 61
    factor                         shift and go to state 45

state 41

    (94) factor -> var_cte .

    +               reduce using rule 94 (factor -> var_cte .)
    -               reduce using rule 94 (factor -> var_cte .)
    *               reduce using rule 94 (factor -> var_cte .)
    /               reduce using rule 94 (factor -> var_cte .)
    ;               reduce using rule 94 (factor -> var_cte .)
    )               reduce using rule 94 (factor -> var_cte .)
    ,               reduce using rule 94 (factor -> var_cte .)
    =               reduce using rule 94 (factor -> var_cte .)
    <               reduce using rule 94 (factor -> var_cte .)
    >               reduce using rule 94 (factor -> var_cte .)
    AND             reduce using rule 94 (factor -> var_cte .)
    OR              reduce using rule 94 (factor -> var_cte .)
    (               reduce using rule 94 (factor -> var_cte .)
    ID              reduce using rule 94 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 94 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 94 (factor -> var_cte .)
    TRUE            reduce using rule 94 (factor -> var_cte .)
    FALSE           reduce using rule 94 (factor -> var_cte .)
    RED             reduce using rule 94 (factor -> var_cte .)
    YELLOW          reduce using rule 94 (factor -> var_cte .)
    BLUE            reduce using rule 94 (factor -> var_cte .)
    GREEN           reduce using rule 94 (factor -> var_cte .)
    BLACK           reduce using rule 94 (factor -> var_cte .)
    WHITE           reduce using rule 94 (factor -> var_cte .)
    ORANGE          reduce using rule 94 (factor -> var_cte .)
    PURPLE          reduce using rule 94 (factor -> var_cte .)
    CYAN            reduce using rule 94 (factor -> var_cte .)
    ]               reduce using rule 94 (factor -> var_cte .)


state 42

    (115) var_cte -> CTE_INTEGER .

    =               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 115 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 115 (var_cte -> CTE_INTEGER .)
    +               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 115 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 115 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 115 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    WHITE           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 115 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 115 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 115 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 115 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 115 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 115 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 115 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 115 (var_cte -> CTE_INTEGER .)


state 43

    (117) var_cte -> TRUE .

    =               reduce using rule 117 (var_cte -> TRUE .)
    <               reduce using rule 117 (var_cte -> TRUE .)
    >               reduce using rule 117 (var_cte -> TRUE .)
    AND             reduce using rule 117 (var_cte -> TRUE .)
    OR              reduce using rule 117 (var_cte -> TRUE .)
    +               reduce using rule 117 (var_cte -> TRUE .)
    -               reduce using rule 117 (var_cte -> TRUE .)
    *               reduce using rule 117 (var_cte -> TRUE .)
    /               reduce using rule 117 (var_cte -> TRUE .)
    ,               reduce using rule 117 (var_cte -> TRUE .)
    )               reduce using rule 117 (var_cte -> TRUE .)
    ]               reduce using rule 117 (var_cte -> TRUE .)
    ;               reduce using rule 117 (var_cte -> TRUE .)
    RED             reduce using rule 117 (var_cte -> TRUE .)
    YELLOW          reduce using rule 117 (var_cte -> TRUE .)
    BLUE            reduce using rule 117 (var_cte -> TRUE .)
    GREEN           reduce using rule 117 (var_cte -> TRUE .)
    BLACK           reduce using rule 117 (var_cte -> TRUE .)
    WHITE           reduce using rule 117 (var_cte -> TRUE .)
    ORANGE          reduce using rule 117 (var_cte -> TRUE .)
    PURPLE          reduce using rule 117 (var_cte -> TRUE .)
    CYAN            reduce using rule 117 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 117 (var_cte -> TRUE .)
    (               reduce using rule 117 (var_cte -> TRUE .)
    ID              reduce using rule 117 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 117 (var_cte -> TRUE .)
    TRUE            reduce using rule 117 (var_cte -> TRUE .)
    FALSE           reduce using rule 117 (var_cte -> TRUE .)


state 44

    (70) command -> figure exp . exp color ;
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77
    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 78
    factor                         shift and go to state 45

state 45

    (92) exp -> factor . empty
    (127) empty -> .

    +               reduce using rule 127 (empty -> .)
    -               reduce using rule 127 (empty -> .)
    *               reduce using rule 127 (empty -> .)
    /               reduce using rule 127 (empty -> .)
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INTEGER     reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    TRUE            reduce using rule 127 (empty -> .)
    FALSE           reduce using rule 127 (empty -> .)
    =               reduce using rule 127 (empty -> .)
    <               reduce using rule 127 (empty -> .)
    >               reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    RED             reduce using rule 127 (empty -> .)
    YELLOW          reduce using rule 127 (empty -> .)
    BLUE            reduce using rule 127 (empty -> .)
    GREEN           reduce using rule 127 (empty -> .)
    BLACK           reduce using rule 127 (empty -> .)
    WHITE           reduce using rule 127 (empty -> .)
    ORANGE          reduce using rule 127 (empty -> .)
    PURPLE          reduce using rule 127 (empty -> .)
    CYAN            reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)
    ]               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 79

state 46

    (118) var_cte -> FALSE .

    =               reduce using rule 118 (var_cte -> FALSE .)
    <               reduce using rule 118 (var_cte -> FALSE .)
    >               reduce using rule 118 (var_cte -> FALSE .)
    AND             reduce using rule 118 (var_cte -> FALSE .)
    OR              reduce using rule 118 (var_cte -> FALSE .)
    +               reduce using rule 118 (var_cte -> FALSE .)
    -               reduce using rule 118 (var_cte -> FALSE .)
    *               reduce using rule 118 (var_cte -> FALSE .)
    /               reduce using rule 118 (var_cte -> FALSE .)
    ,               reduce using rule 118 (var_cte -> FALSE .)
    )               reduce using rule 118 (var_cte -> FALSE .)
    ]               reduce using rule 118 (var_cte -> FALSE .)
    ;               reduce using rule 118 (var_cte -> FALSE .)
    RED             reduce using rule 118 (var_cte -> FALSE .)
    YELLOW          reduce using rule 118 (var_cte -> FALSE .)
    BLUE            reduce using rule 118 (var_cte -> FALSE .)
    GREEN           reduce using rule 118 (var_cte -> FALSE .)
    BLACK           reduce using rule 118 (var_cte -> FALSE .)
    WHITE           reduce using rule 118 (var_cte -> FALSE .)
    ORANGE          reduce using rule 118 (var_cte -> FALSE .)
    PURPLE          reduce using rule 118 (var_cte -> FALSE .)
    CYAN            reduce using rule 118 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 118 (var_cte -> FALSE .)
    (               reduce using rule 118 (var_cte -> FALSE .)
    ID              reduce using rule 118 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 118 (var_cte -> FALSE .)
    TRUE            reduce using rule 118 (var_cte -> FALSE .)
    FALSE           reduce using rule 118 (var_cte -> FALSE .)


state 47

    (114) var_cte -> ID .

    =               reduce using rule 114 (var_cte -> ID .)
    <               reduce using rule 114 (var_cte -> ID .)
    >               reduce using rule 114 (var_cte -> ID .)
    AND             reduce using rule 114 (var_cte -> ID .)
    OR              reduce using rule 114 (var_cte -> ID .)
    +               reduce using rule 114 (var_cte -> ID .)
    -               reduce using rule 114 (var_cte -> ID .)
    *               reduce using rule 114 (var_cte -> ID .)
    /               reduce using rule 114 (var_cte -> ID .)
    ,               reduce using rule 114 (var_cte -> ID .)
    )               reduce using rule 114 (var_cte -> ID .)
    ]               reduce using rule 114 (var_cte -> ID .)
    ;               reduce using rule 114 (var_cte -> ID .)
    RED             reduce using rule 114 (var_cte -> ID .)
    YELLOW          reduce using rule 114 (var_cte -> ID .)
    BLUE            reduce using rule 114 (var_cte -> ID .)
    GREEN           reduce using rule 114 (var_cte -> ID .)
    BLACK           reduce using rule 114 (var_cte -> ID .)
    WHITE           reduce using rule 114 (var_cte -> ID .)
    ORANGE          reduce using rule 114 (var_cte -> ID .)
    PURPLE          reduce using rule 114 (var_cte -> ID .)
    CYAN            reduce using rule 114 (var_cte -> ID .)
    CTE_INTEGER     reduce using rule 114 (var_cte -> ID .)
    (               reduce using rule 114 (var_cte -> ID .)
    ID              reduce using rule 114 (var_cte -> ID .)
    CTE_FLOAT       reduce using rule 114 (var_cte -> ID .)
    TRUE            reduce using rule 114 (var_cte -> ID .)
    FALSE           reduce using rule 114 (var_cte -> ID .)


state 48

    (74) cycle -> WHILE gotoW . ( expression ) gotoFalse block continueGoW

    (               shift and go to state 80


state 49

    (75) repeat -> REPLAY CTE_INTEGER . gotoR [ repeatA ] ;
    (122) gotoR -> .

    [               reduce using rule 122 (gotoR -> .)

    gotoR                          shift and go to state 81

state 50

    (50) assign -> id = . expression ;
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 61
    factor                         shift and go to state 45
    expression                     shift and go to state 82

state 51

    (59) pipeline -> PIPE ID . pipelineA
    (60) pipelineA -> . [ pipelineB ] ;
    (61) pipelineA -> . IN ( var_cte ) ;
    (62) pipelineA -> . OUT ( ) ;
    (63) pipelineA -> . COUNT ;

    [               shift and go to state 86
    IN              shift and go to state 84
    OUT             shift and go to state 87
    COUNT           shift and go to state 83

    pipelineA                      shift and go to state 85

state 52

    (34) calling -> # callID . ( insertEra callingA

    (               shift and go to state 88


state 53

    (35) callID -> ID .

    (               reduce using rule 35 (callID -> ID .)


state 54

    (51) condition -> IF ( . expression ) gotoFalse block conditionA continueGo
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    exp                            shift and go to state 61
    factor                         shift and go to state 45
    var_cte                        shift and go to state 41
    expression                     shift and go to state 89

state 55

    (67) typeDim -> INT .

    ID              reduce using rule 67 (typeDim -> INT .)


state 56

    (68) typeDim -> FLOAT .

    ID              reduce using rule 68 (typeDim -> FLOAT .)


state 57

    (57) array -> ARR typeDim . ID [ CTE_INTEGER ] ;

    ID              shift and go to state 90


state 58

    (69) typeDim -> BOOL .

    ID              reduce using rule 69 (typeDim -> BOOL .)


state 59

    (54) write -> ECHO writeA . ;

    ;               shift and go to state 91


state 60

    (56) writeA -> CTE_STRING .

    ;               reduce using rule 56 (writeA -> CTE_STRING .)


state 61

    (79) expression -> exp . = = exp
    (80) expression -> exp . < > exp
    (81) expression -> exp . < = exp
    (82) expression -> exp . > = exp
    (83) expression -> exp . > exp
    (84) expression -> exp . < exp
    (85) expression -> exp . AND exp
    (86) expression -> exp . OR exp
    (87) expression -> exp . empty
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp
    (127) empty -> .

    =               shift and go to state 94
    <               shift and go to state 93
    >               shift and go to state 97
    AND             shift and go to state 92
    OR              shift and go to state 95
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 96

state 62

    (55) writeA -> expression .

    ;               reduce using rule 55 (writeA -> expression .)


state 63

    (71) command -> SAMPLE commandA .

    SAMPLE          reduce using rule 71 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 71 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 71 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 71 (command -> SAMPLE commandA .)
    ARC             reduce using rule 71 (command -> SAMPLE commandA .)
    ]               reduce using rule 71 (command -> SAMPLE commandA .)
    IF              reduce using rule 71 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 71 (command -> SAMPLE commandA .)
    WHILE           reduce using rule 71 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 71 (command -> SAMPLE commandA .)
    #               reduce using rule 71 (command -> SAMPLE commandA .)
    ARR             reduce using rule 71 (command -> SAMPLE commandA .)
    MAT             reduce using rule 71 (command -> SAMPLE commandA .)
    PIPE            reduce using rule 71 (command -> SAMPLE commandA .)
    WHERE           reduce using rule 71 (command -> SAMPLE commandA .)
    CLEAR           reduce using rule 71 (command -> SAMPLE commandA .)
    ID              reduce using rule 71 (command -> SAMPLE commandA .)
    }               reduce using rule 71 (command -> SAMPLE commandA .)
    MOD             reduce using rule 71 (command -> SAMPLE commandA .)
    END             reduce using rule 71 (command -> SAMPLE commandA .)


state 64

    (73) commandA -> OFF . move exp ;
    (99) move -> . UP
    (100) move -> . DOWN
    (101) move -> . LEFT
    (102) move -> . RIGHT

    UP              shift and go to state 100
    DOWN            shift and go to state 101
    LEFT            shift and go to state 102
    RIGHT           shift and go to state 98

    move                           shift and go to state 99

state 65

    (72) commandA -> ON . move exp CTE_INTEGER color ;
    (99) move -> . UP
    (100) move -> . DOWN
    (101) move -> . LEFT
    (102) move -> . RIGHT

    UP              shift and go to state 100
    DOWN            shift and go to state 101
    LEFT            shift and go to state 102
    RIGHT           shift and go to state 98

    move                           shift and go to state 103

state 66

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 67

    (30) id -> ID [ . sumdim exp ] [ sumdim exp ]
    (31) id -> ID [ . sumdim exp ]
    (33) sumdim -> .

    (               reduce using rule 33 (sumdim -> .)
    ID              reduce using rule 33 (sumdim -> .)
    CTE_INTEGER     reduce using rule 33 (sumdim -> .)
    CTE_FLOAT       reduce using rule 33 (sumdim -> .)
    TRUE            reduce using rule 33 (sumdim -> .)
    FALSE           reduce using rule 33 (sumdim -> .)

    sumdim                         shift and go to state 104

state 68

    (58) matrix -> MAT typeDim . ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    ID              shift and go to state 105


state 69

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 70

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 71

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 72

    (20) module -> MOD # . moduleID insertQuadMod moduleA endMod
    (23) moduleID -> . ID

    ID              shift and go to state 106

    moduleID                       shift and go to state 107

state 73

    (93) factor -> ( expression . )

    )               shift and go to state 108


state 74

    (88) exp -> exp + . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 109
    factor                         shift and go to state 45

state 75

    (90) exp -> exp * . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 110
    factor                         shift and go to state 45

state 76

    (89) exp -> exp - . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 111
    factor                         shift and go to state 45

state 77

    (91) exp -> exp / . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 112
    factor                         shift and go to state 45

state 78

    (70) command -> figure exp exp . color ;
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp
    (103) color -> . RED
    (104) color -> . YELLOW
    (105) color -> . BLUE
    (106) color -> . GREEN
    (107) color -> . BLACK
    (108) color -> . WHITE
    (109) color -> . ORANGE
    (110) color -> . PURPLE
    (111) color -> . CYAN

    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77
    RED             shift and go to state 122
    YELLOW          shift and go to state 117
    BLUE            shift and go to state 113
    GREEN           shift and go to state 116
    BLACK           shift and go to state 120
    WHITE           shift and go to state 121
    ORANGE          shift and go to state 119
    PURPLE          shift and go to state 115
    CYAN            shift and go to state 118

    color                          shift and go to state 114

state 79

    (92) exp -> factor empty .

    =               reduce using rule 92 (exp -> factor empty .)
    <               reduce using rule 92 (exp -> factor empty .)
    >               reduce using rule 92 (exp -> factor empty .)
    AND             reduce using rule 92 (exp -> factor empty .)
    OR              reduce using rule 92 (exp -> factor empty .)
    +               reduce using rule 92 (exp -> factor empty .)
    -               reduce using rule 92 (exp -> factor empty .)
    *               reduce using rule 92 (exp -> factor empty .)
    /               reduce using rule 92 (exp -> factor empty .)
    ;               reduce using rule 92 (exp -> factor empty .)
    (               reduce using rule 92 (exp -> factor empty .)
    ID              reduce using rule 92 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 92 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 92 (exp -> factor empty .)
    TRUE            reduce using rule 92 (exp -> factor empty .)
    FALSE           reduce using rule 92 (exp -> factor empty .)
    ,               reduce using rule 92 (exp -> factor empty .)
    )               reduce using rule 92 (exp -> factor empty .)
    RED             reduce using rule 92 (exp -> factor empty .)
    YELLOW          reduce using rule 92 (exp -> factor empty .)
    BLUE            reduce using rule 92 (exp -> factor empty .)
    GREEN           reduce using rule 92 (exp -> factor empty .)
    BLACK           reduce using rule 92 (exp -> factor empty .)
    WHITE           reduce using rule 92 (exp -> factor empty .)
    ORANGE          reduce using rule 92 (exp -> factor empty .)
    PURPLE          reduce using rule 92 (exp -> factor empty .)
    CYAN            reduce using rule 92 (exp -> factor empty .)
    ]               reduce using rule 92 (exp -> factor empty .)


state 80

    (74) cycle -> WHILE gotoW ( . expression ) gotoFalse block continueGoW
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 61
    factor                         shift and go to state 45
    expression                     shift and go to state 123

state 81

    (75) repeat -> REPLAY CTE_INTEGER gotoR . [ repeatA ] ;

    [               shift and go to state 124


state 82

    (50) assign -> id = expression . ;

    ;               shift and go to state 125


state 83

    (63) pipelineA -> COUNT . ;

    ;               shift and go to state 126


state 84

    (61) pipelineA -> IN . ( var_cte ) ;

    (               shift and go to state 127


state 85

    (59) pipeline -> PIPE ID pipelineA .

    MOD             reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    IF              reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    ECHO            reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    WHILE           reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    REPLAY          reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    SAMPLE          reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    #               reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    ARR             reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    MAT             reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    PIPE            reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    WHERE           reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    CLEAR           reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    ID              reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    OVAL            reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    TRIO            reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    QUAD            reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    ARC             reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    END             reduce using rule 59 (pipeline -> PIPE ID pipelineA .)
    }               reduce using rule 59 (pipeline -> PIPE ID pipelineA .)


state 86

    (60) pipelineA -> [ . pipelineB ] ;
    (64) pipelineB -> . exp pipelineC
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    pipelineB                      shift and go to state 128
    exp                            shift and go to state 129
    factor                         shift and go to state 45

state 87

    (62) pipelineA -> OUT . ( ) ;

    (               shift and go to state 130


state 88

    (34) calling -> # callID ( . insertEra callingA
    (36) insertEra -> .

    )               reduce using rule 36 (insertEra -> .)
    (               reduce using rule 36 (insertEra -> .)
    ID              reduce using rule 36 (insertEra -> .)
    CTE_INTEGER     reduce using rule 36 (insertEra -> .)
    CTE_FLOAT       reduce using rule 36 (insertEra -> .)
    TRUE            reduce using rule 36 (insertEra -> .)
    FALSE           reduce using rule 36 (insertEra -> .)

    insertEra                      shift and go to state 131

state 89

    (51) condition -> IF ( expression . ) gotoFalse block conditionA continueGo

    )               shift and go to state 132


state 90

    (57) array -> ARR typeDim ID . [ CTE_INTEGER ] ;

    [               shift and go to state 133


state 91

    (54) write -> ECHO writeA ; .

    IF              reduce using rule 54 (write -> ECHO writeA ; .)
    ECHO            reduce using rule 54 (write -> ECHO writeA ; .)
    WHILE           reduce using rule 54 (write -> ECHO writeA ; .)
    REPLAY          reduce using rule 54 (write -> ECHO writeA ; .)
    SAMPLE          reduce using rule 54 (write -> ECHO writeA ; .)
    #               reduce using rule 54 (write -> ECHO writeA ; .)
    ARR             reduce using rule 54 (write -> ECHO writeA ; .)
    MAT             reduce using rule 54 (write -> ECHO writeA ; .)
    PIPE            reduce using rule 54 (write -> ECHO writeA ; .)
    WHERE           reduce using rule 54 (write -> ECHO writeA ; .)
    CLEAR           reduce using rule 54 (write -> ECHO writeA ; .)
    ID              reduce using rule 54 (write -> ECHO writeA ; .)
    OVAL            reduce using rule 54 (write -> ECHO writeA ; .)
    TRIO            reduce using rule 54 (write -> ECHO writeA ; .)
    QUAD            reduce using rule 54 (write -> ECHO writeA ; .)
    ARC             reduce using rule 54 (write -> ECHO writeA ; .)
    }               reduce using rule 54 (write -> ECHO writeA ; .)
    MOD             reduce using rule 54 (write -> ECHO writeA ; .)
    END             reduce using rule 54 (write -> ECHO writeA ; .)


state 92

    (85) expression -> exp AND . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 134
    factor                         shift and go to state 45

state 93

    (80) expression -> exp < . > exp
    (81) expression -> exp < . = exp
    (84) expression -> exp < . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    >               shift and go to state 137
    =               shift and go to state 136
    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 135
    factor                         shift and go to state 45

state 94

    (79) expression -> exp = . = exp

    =               shift and go to state 138


state 95

    (86) expression -> exp OR . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 139
    factor                         shift and go to state 45

state 96

    (87) expression -> exp empty .

    )               reduce using rule 87 (expression -> exp empty .)
    ;               reduce using rule 87 (expression -> exp empty .)
    ,               reduce using rule 87 (expression -> exp empty .)


state 97

    (82) expression -> exp > . = exp
    (83) expression -> exp > . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    =               shift and go to state 141
    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 140
    factor                         shift and go to state 45

state 98

    (102) move -> RIGHT .

    (               reduce using rule 102 (move -> RIGHT .)
    ID              reduce using rule 102 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 102 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 102 (move -> RIGHT .)
    TRUE            reduce using rule 102 (move -> RIGHT .)
    FALSE           reduce using rule 102 (move -> RIGHT .)


state 99

    (73) commandA -> OFF move . exp ;
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 142
    factor                         shift and go to state 45

state 100

    (99) move -> UP .

    (               reduce using rule 99 (move -> UP .)
    ID              reduce using rule 99 (move -> UP .)
    CTE_INTEGER     reduce using rule 99 (move -> UP .)
    CTE_FLOAT       reduce using rule 99 (move -> UP .)
    TRUE            reduce using rule 99 (move -> UP .)
    FALSE           reduce using rule 99 (move -> UP .)


state 101

    (100) move -> DOWN .

    (               reduce using rule 100 (move -> DOWN .)
    ID              reduce using rule 100 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 100 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 100 (move -> DOWN .)
    TRUE            reduce using rule 100 (move -> DOWN .)
    FALSE           reduce using rule 100 (move -> DOWN .)


state 102

    (101) move -> LEFT .

    (               reduce using rule 101 (move -> LEFT .)
    ID              reduce using rule 101 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 101 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 101 (move -> LEFT .)
    TRUE            reduce using rule 101 (move -> LEFT .)
    FALSE           reduce using rule 101 (move -> LEFT .)


state 103

    (72) commandA -> ON move . exp CTE_INTEGER color ;
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 143
    factor                         shift and go to state 45

state 104

    (30) id -> ID [ sumdim . exp ] [ sumdim exp ]
    (31) id -> ID [ sumdim . exp ]
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 144
    factor                         shift and go to state 45

state 105

    (58) matrix -> MAT typeDim ID . [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    [               shift and go to state 145


state 106

    (23) moduleID -> ID .

    (               reduce using rule 23 (moduleID -> ID .)
    {               reduce using rule 23 (moduleID -> ID .)


state 107

    (20) module -> MOD # moduleID . insertQuadMod moduleA endMod
    (125) insertQuadMod -> .

    (               reduce using rule 125 (insertQuadMod -> .)
    {               reduce using rule 125 (insertQuadMod -> .)

    insertQuadMod                  shift and go to state 146

state 108

    (93) factor -> ( expression ) .

    +               reduce using rule 93 (factor -> ( expression ) .)
    -               reduce using rule 93 (factor -> ( expression ) .)
    *               reduce using rule 93 (factor -> ( expression ) .)
    /               reduce using rule 93 (factor -> ( expression ) .)
    ;               reduce using rule 93 (factor -> ( expression ) .)
    )               reduce using rule 93 (factor -> ( expression ) .)
    ,               reduce using rule 93 (factor -> ( expression ) .)
    =               reduce using rule 93 (factor -> ( expression ) .)
    <               reduce using rule 93 (factor -> ( expression ) .)
    >               reduce using rule 93 (factor -> ( expression ) .)
    AND             reduce using rule 93 (factor -> ( expression ) .)
    OR              reduce using rule 93 (factor -> ( expression ) .)
    (               reduce using rule 93 (factor -> ( expression ) .)
    ID              reduce using rule 93 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 93 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 93 (factor -> ( expression ) .)
    TRUE            reduce using rule 93 (factor -> ( expression ) .)
    FALSE           reduce using rule 93 (factor -> ( expression ) .)
    RED             reduce using rule 93 (factor -> ( expression ) .)
    YELLOW          reduce using rule 93 (factor -> ( expression ) .)
    BLUE            reduce using rule 93 (factor -> ( expression ) .)
    GREEN           reduce using rule 93 (factor -> ( expression ) .)
    BLACK           reduce using rule 93 (factor -> ( expression ) .)
    WHITE           reduce using rule 93 (factor -> ( expression ) .)
    ORANGE          reduce using rule 93 (factor -> ( expression ) .)
    PURPLE          reduce using rule 93 (factor -> ( expression ) .)
    CYAN            reduce using rule 93 (factor -> ( expression ) .)
    ]               reduce using rule 93 (factor -> ( expression ) .)


state 109

    (88) exp -> exp + exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    =               reduce using rule 88 (exp -> exp + exp .)
    <               reduce using rule 88 (exp -> exp + exp .)
    >               reduce using rule 88 (exp -> exp + exp .)
    AND             reduce using rule 88 (exp -> exp + exp .)
    OR              reduce using rule 88 (exp -> exp + exp .)
    +               reduce using rule 88 (exp -> exp + exp .)
    -               reduce using rule 88 (exp -> exp + exp .)
    ;               reduce using rule 88 (exp -> exp + exp .)
    (               reduce using rule 88 (exp -> exp + exp .)
    ID              reduce using rule 88 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 88 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 88 (exp -> exp + exp .)
    TRUE            reduce using rule 88 (exp -> exp + exp .)
    FALSE           reduce using rule 88 (exp -> exp + exp .)
    ,               reduce using rule 88 (exp -> exp + exp .)
    )               reduce using rule 88 (exp -> exp + exp .)
    RED             reduce using rule 88 (exp -> exp + exp .)
    YELLOW          reduce using rule 88 (exp -> exp + exp .)
    BLUE            reduce using rule 88 (exp -> exp + exp .)
    GREEN           reduce using rule 88 (exp -> exp + exp .)
    BLACK           reduce using rule 88 (exp -> exp + exp .)
    WHITE           reduce using rule 88 (exp -> exp + exp .)
    ORANGE          reduce using rule 88 (exp -> exp + exp .)
    PURPLE          reduce using rule 88 (exp -> exp + exp .)
    CYAN            reduce using rule 88 (exp -> exp + exp .)
    ]               reduce using rule 88 (exp -> exp + exp .)
    *               shift and go to state 75
    /               shift and go to state 77

  ! *               [ reduce using rule 88 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 88 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 76 ]


state 110

    (90) exp -> exp * exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    =               reduce using rule 90 (exp -> exp * exp .)
    <               reduce using rule 90 (exp -> exp * exp .)
    >               reduce using rule 90 (exp -> exp * exp .)
    AND             reduce using rule 90 (exp -> exp * exp .)
    OR              reduce using rule 90 (exp -> exp * exp .)
    +               reduce using rule 90 (exp -> exp * exp .)
    -               reduce using rule 90 (exp -> exp * exp .)
    *               reduce using rule 90 (exp -> exp * exp .)
    /               reduce using rule 90 (exp -> exp * exp .)
    ;               reduce using rule 90 (exp -> exp * exp .)
    (               reduce using rule 90 (exp -> exp * exp .)
    ID              reduce using rule 90 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 90 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 90 (exp -> exp * exp .)
    TRUE            reduce using rule 90 (exp -> exp * exp .)
    FALSE           reduce using rule 90 (exp -> exp * exp .)
    ,               reduce using rule 90 (exp -> exp * exp .)
    )               reduce using rule 90 (exp -> exp * exp .)
    RED             reduce using rule 90 (exp -> exp * exp .)
    YELLOW          reduce using rule 90 (exp -> exp * exp .)
    BLUE            reduce using rule 90 (exp -> exp * exp .)
    GREEN           reduce using rule 90 (exp -> exp * exp .)
    BLACK           reduce using rule 90 (exp -> exp * exp .)
    WHITE           reduce using rule 90 (exp -> exp * exp .)
    ORANGE          reduce using rule 90 (exp -> exp * exp .)
    PURPLE          reduce using rule 90 (exp -> exp * exp .)
    CYAN            reduce using rule 90 (exp -> exp * exp .)
    ]               reduce using rule 90 (exp -> exp * exp .)

  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 76 ]
  ! *               [ shift and go to state 75 ]
  ! /               [ shift and go to state 77 ]


state 111

    (89) exp -> exp - exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    =               reduce using rule 89 (exp -> exp - exp .)
    <               reduce using rule 89 (exp -> exp - exp .)
    >               reduce using rule 89 (exp -> exp - exp .)
    AND             reduce using rule 89 (exp -> exp - exp .)
    OR              reduce using rule 89 (exp -> exp - exp .)
    +               reduce using rule 89 (exp -> exp - exp .)
    -               reduce using rule 89 (exp -> exp - exp .)
    ;               reduce using rule 89 (exp -> exp - exp .)
    (               reduce using rule 89 (exp -> exp - exp .)
    ID              reduce using rule 89 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 89 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 89 (exp -> exp - exp .)
    TRUE            reduce using rule 89 (exp -> exp - exp .)
    FALSE           reduce using rule 89 (exp -> exp - exp .)
    ,               reduce using rule 89 (exp -> exp - exp .)
    )               reduce using rule 89 (exp -> exp - exp .)
    RED             reduce using rule 89 (exp -> exp - exp .)
    YELLOW          reduce using rule 89 (exp -> exp - exp .)
    BLUE            reduce using rule 89 (exp -> exp - exp .)
    GREEN           reduce using rule 89 (exp -> exp - exp .)
    BLACK           reduce using rule 89 (exp -> exp - exp .)
    WHITE           reduce using rule 89 (exp -> exp - exp .)
    ORANGE          reduce using rule 89 (exp -> exp - exp .)
    PURPLE          reduce using rule 89 (exp -> exp - exp .)
    CYAN            reduce using rule 89 (exp -> exp - exp .)
    ]               reduce using rule 89 (exp -> exp - exp .)
    *               shift and go to state 75
    /               shift and go to state 77

  ! *               [ reduce using rule 89 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 89 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 76 ]


state 112

    (91) exp -> exp / exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    =               reduce using rule 91 (exp -> exp / exp .)
    <               reduce using rule 91 (exp -> exp / exp .)
    >               reduce using rule 91 (exp -> exp / exp .)
    AND             reduce using rule 91 (exp -> exp / exp .)
    OR              reduce using rule 91 (exp -> exp / exp .)
    +               reduce using rule 91 (exp -> exp / exp .)
    -               reduce using rule 91 (exp -> exp / exp .)
    *               reduce using rule 91 (exp -> exp / exp .)
    /               reduce using rule 91 (exp -> exp / exp .)
    ;               reduce using rule 91 (exp -> exp / exp .)
    (               reduce using rule 91 (exp -> exp / exp .)
    ID              reduce using rule 91 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 91 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 91 (exp -> exp / exp .)
    TRUE            reduce using rule 91 (exp -> exp / exp .)
    FALSE           reduce using rule 91 (exp -> exp / exp .)
    ,               reduce using rule 91 (exp -> exp / exp .)
    )               reduce using rule 91 (exp -> exp / exp .)
    RED             reduce using rule 91 (exp -> exp / exp .)
    YELLOW          reduce using rule 91 (exp -> exp / exp .)
    BLUE            reduce using rule 91 (exp -> exp / exp .)
    GREEN           reduce using rule 91 (exp -> exp / exp .)
    BLACK           reduce using rule 91 (exp -> exp / exp .)
    WHITE           reduce using rule 91 (exp -> exp / exp .)
    ORANGE          reduce using rule 91 (exp -> exp / exp .)
    PURPLE          reduce using rule 91 (exp -> exp / exp .)
    CYAN            reduce using rule 91 (exp -> exp / exp .)
    ]               reduce using rule 91 (exp -> exp / exp .)

  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 76 ]
  ! *               [ shift and go to state 75 ]
  ! /               [ shift and go to state 77 ]


state 113

    (105) color -> BLUE .

    ;               reduce using rule 105 (color -> BLUE .)


state 114

    (70) command -> figure exp exp color . ;

    ;               shift and go to state 147


state 115

    (110) color -> PURPLE .

    ;               reduce using rule 110 (color -> PURPLE .)


state 116

    (106) color -> GREEN .

    ;               reduce using rule 106 (color -> GREEN .)


state 117

    (104) color -> YELLOW .

    ;               reduce using rule 104 (color -> YELLOW .)


state 118

    (111) color -> CYAN .

    ;               reduce using rule 111 (color -> CYAN .)


state 119

    (109) color -> ORANGE .

    ;               reduce using rule 109 (color -> ORANGE .)


state 120

    (107) color -> BLACK .

    ;               reduce using rule 107 (color -> BLACK .)


state 121

    (108) color -> WHITE .

    ;               reduce using rule 108 (color -> WHITE .)


state 122

    (103) color -> RED .

    ;               reduce using rule 103 (color -> RED .)


state 123

    (74) cycle -> WHILE gotoW ( expression . ) gotoFalse block continueGoW

    )               shift and go to state 148


state 124

    (75) repeat -> REPLAY CTE_INTEGER gotoR [ . repeatA ] ;
    (76) repeatA -> . command repeatB
    (70) command -> . figure exp exp color ;
    (71) command -> . SAMPLE commandA
    (95) figure -> . OVAL
    (96) figure -> . TRIO
    (97) figure -> . QUAD
    (98) figure -> . ARC

    SAMPLE          shift and go to state 22
    OVAL            shift and go to state 5
    TRIO            shift and go to state 16
    QUAD            shift and go to state 25
    ARC             shift and go to state 34

    figure                         shift and go to state 3
    repeatA                        shift and go to state 149
    command                        shift and go to state 150

state 125

    (50) assign -> id = expression ; .

    IF              reduce using rule 50 (assign -> id = expression ; .)
    ECHO            reduce using rule 50 (assign -> id = expression ; .)
    WHILE           reduce using rule 50 (assign -> id = expression ; .)
    REPLAY          reduce using rule 50 (assign -> id = expression ; .)
    SAMPLE          reduce using rule 50 (assign -> id = expression ; .)
    #               reduce using rule 50 (assign -> id = expression ; .)
    ARR             reduce using rule 50 (assign -> id = expression ; .)
    MAT             reduce using rule 50 (assign -> id = expression ; .)
    PIPE            reduce using rule 50 (assign -> id = expression ; .)
    WHERE           reduce using rule 50 (assign -> id = expression ; .)
    CLEAR           reduce using rule 50 (assign -> id = expression ; .)
    ID              reduce using rule 50 (assign -> id = expression ; .)
    OVAL            reduce using rule 50 (assign -> id = expression ; .)
    TRIO            reduce using rule 50 (assign -> id = expression ; .)
    QUAD            reduce using rule 50 (assign -> id = expression ; .)
    ARC             reduce using rule 50 (assign -> id = expression ; .)
    }               reduce using rule 50 (assign -> id = expression ; .)
    MOD             reduce using rule 50 (assign -> id = expression ; .)
    END             reduce using rule 50 (assign -> id = expression ; .)


state 126

    (63) pipelineA -> COUNT ; .

    MOD             reduce using rule 63 (pipelineA -> COUNT ; .)
    IF              reduce using rule 63 (pipelineA -> COUNT ; .)
    ECHO            reduce using rule 63 (pipelineA -> COUNT ; .)
    WHILE           reduce using rule 63 (pipelineA -> COUNT ; .)
    REPLAY          reduce using rule 63 (pipelineA -> COUNT ; .)
    SAMPLE          reduce using rule 63 (pipelineA -> COUNT ; .)
    #               reduce using rule 63 (pipelineA -> COUNT ; .)
    ARR             reduce using rule 63 (pipelineA -> COUNT ; .)
    MAT             reduce using rule 63 (pipelineA -> COUNT ; .)
    PIPE            reduce using rule 63 (pipelineA -> COUNT ; .)
    WHERE           reduce using rule 63 (pipelineA -> COUNT ; .)
    CLEAR           reduce using rule 63 (pipelineA -> COUNT ; .)
    ID              reduce using rule 63 (pipelineA -> COUNT ; .)
    OVAL            reduce using rule 63 (pipelineA -> COUNT ; .)
    TRIO            reduce using rule 63 (pipelineA -> COUNT ; .)
    QUAD            reduce using rule 63 (pipelineA -> COUNT ; .)
    ARC             reduce using rule 63 (pipelineA -> COUNT ; .)
    END             reduce using rule 63 (pipelineA -> COUNT ; .)
    }               reduce using rule 63 (pipelineA -> COUNT ; .)


state 127

    (61) pipelineA -> IN ( . var_cte ) ;
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 151

state 128

    (60) pipelineA -> [ pipelineB . ] ;

    ]               shift and go to state 152


state 129

    (64) pipelineB -> exp . pipelineC
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp
    (65) pipelineC -> . , pipelineB
    (66) pipelineC -> . empty
    (127) empty -> .

    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77
    ,               shift and go to state 153
    ]               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 155
    pipelineC                      shift and go to state 154

state 130

    (62) pipelineA -> OUT ( . ) ;

    )               shift and go to state 156


state 131

    (34) calling -> # callID ( insertEra . callingA
    (37) callingA -> . callingB ) ;
    (38) callingA -> . ) ;
    (39) callingB -> . expression checkParam callingC
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    )               shift and go to state 157
    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    factor                         shift and go to state 45
    var_cte                        shift and go to state 41
    callingA                       shift and go to state 158
    callingB                       shift and go to state 159
    exp                            shift and go to state 61
    expression                     shift and go to state 160

state 132

    (51) condition -> IF ( expression ) . gotoFalse block conditionA continueGo
    (119) gotoFalse -> .

    {               reduce using rule 119 (gotoFalse -> .)

    gotoFalse                      shift and go to state 161

state 133

    (57) array -> ARR typeDim ID [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 162


state 134

    (85) expression -> exp AND exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 85 (expression -> exp AND exp .)
    ;               reduce using rule 85 (expression -> exp AND exp .)
    ,               reduce using rule 85 (expression -> exp AND exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 135

    (84) expression -> exp < exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 84 (expression -> exp < exp .)
    ;               reduce using rule 84 (expression -> exp < exp .)
    ,               reduce using rule 84 (expression -> exp < exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 136

    (81) expression -> exp < = . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 163
    factor                         shift and go to state 45

state 137

    (80) expression -> exp < > . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 164
    factor                         shift and go to state 45

state 138

    (79) expression -> exp = = . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 165
    factor                         shift and go to state 45

state 139

    (86) expression -> exp OR exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 86 (expression -> exp OR exp .)
    ;               reduce using rule 86 (expression -> exp OR exp .)
    ,               reduce using rule 86 (expression -> exp OR exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 140

    (83) expression -> exp > exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 83 (expression -> exp > exp .)
    ;               reduce using rule 83 (expression -> exp > exp .)
    ,               reduce using rule 83 (expression -> exp > exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 141

    (82) expression -> exp > = . exp
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 166
    factor                         shift and go to state 45

state 142

    (73) commandA -> OFF move exp . ;
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    ;               shift and go to state 167
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 143

    (72) commandA -> ON move exp . CTE_INTEGER color ;
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 168
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 144

    (30) id -> ID [ sumdim exp . ] [ sumdim exp ]
    (31) id -> ID [ sumdim exp . ]
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    ]               shift and go to state 169
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 145

    (58) matrix -> MAT typeDim ID [ . CTE_INTEGER ] [ CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 170


state 146

    (20) module -> MOD # moduleID insertQuadMod . moduleA endMod
    (21) moduleA -> . ( vars ) block
    (22) moduleA -> . block
    (44) block -> . { blockA

    (               shift and go to state 171
    {               shift and go to state 173

    moduleA                        shift and go to state 174
    block                          shift and go to state 172

state 147

    (70) command -> figure exp exp color ; .

    SAMPLE          reduce using rule 70 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 70 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 70 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 70 (command -> figure exp exp color ; .)
    ARC             reduce using rule 70 (command -> figure exp exp color ; .)
    ]               reduce using rule 70 (command -> figure exp exp color ; .)
    IF              reduce using rule 70 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 70 (command -> figure exp exp color ; .)
    WHILE           reduce using rule 70 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 70 (command -> figure exp exp color ; .)
    #               reduce using rule 70 (command -> figure exp exp color ; .)
    ARR             reduce using rule 70 (command -> figure exp exp color ; .)
    MAT             reduce using rule 70 (command -> figure exp exp color ; .)
    PIPE            reduce using rule 70 (command -> figure exp exp color ; .)
    WHERE           reduce using rule 70 (command -> figure exp exp color ; .)
    CLEAR           reduce using rule 70 (command -> figure exp exp color ; .)
    ID              reduce using rule 70 (command -> figure exp exp color ; .)
    }               reduce using rule 70 (command -> figure exp exp color ; .)
    MOD             reduce using rule 70 (command -> figure exp exp color ; .)
    END             reduce using rule 70 (command -> figure exp exp color ; .)


state 148

    (74) cycle -> WHILE gotoW ( expression ) . gotoFalse block continueGoW
    (119) gotoFalse -> .

    {               reduce using rule 119 (gotoFalse -> .)

    gotoFalse                      shift and go to state 175

state 149

    (75) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA . ] ;

    ]               shift and go to state 176


state 150

    (76) repeatA -> command . repeatB
    (77) repeatB -> . repeatA
    (78) repeatB -> . empty
    (76) repeatA -> . command repeatB
    (127) empty -> .
    (70) command -> . figure exp exp color ;
    (71) command -> . SAMPLE commandA
    (95) figure -> . OVAL
    (96) figure -> . TRIO
    (97) figure -> . QUAD
    (98) figure -> . ARC

    ]               reduce using rule 127 (empty -> .)
    SAMPLE          shift and go to state 22
    OVAL            shift and go to state 5
    TRIO            shift and go to state 16
    QUAD            shift and go to state 25
    ARC             shift and go to state 34

    figure                         shift and go to state 3
    repeatA                        shift and go to state 177
    repeatB                        shift and go to state 178
    command                        shift and go to state 150
    empty                          shift and go to state 179

state 151

    (61) pipelineA -> IN ( var_cte . ) ;

    )               shift and go to state 180


state 152

    (60) pipelineA -> [ pipelineB ] . ;

    ;               shift and go to state 181


state 153

    (65) pipelineC -> , . pipelineB
    (64) pipelineB -> . exp pipelineC
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    pipelineB                      shift and go to state 182
    exp                            shift and go to state 129
    factor                         shift and go to state 45

state 154

    (64) pipelineB -> exp pipelineC .

    ]               reduce using rule 64 (pipelineB -> exp pipelineC .)


state 155

    (66) pipelineC -> empty .

    ]               reduce using rule 66 (pipelineC -> empty .)


state 156

    (62) pipelineA -> OUT ( ) . ;

    ;               shift and go to state 183


state 157

    (38) callingA -> ) . ;

    ;               shift and go to state 184


state 158

    (34) calling -> # callID ( insertEra callingA .

    MOD             reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    IF              reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    ECHO            reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    WHILE           reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    REPLAY          reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    SAMPLE          reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    #               reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    ARR             reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    MAT             reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    PIPE            reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    WHERE           reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    CLEAR           reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    ID              reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    OVAL            reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    TRIO            reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    QUAD            reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    ARC             reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    END             reduce using rule 34 (calling -> # callID ( insertEra callingA .)
    }               reduce using rule 34 (calling -> # callID ( insertEra callingA .)


state 159

    (37) callingA -> callingB . ) ;

    )               shift and go to state 185


state 160

    (39) callingB -> expression . checkParam callingC
    (40) checkParam -> .

    ,               reduce using rule 40 (checkParam -> .)
    )               reduce using rule 40 (checkParam -> .)

    checkParam                     shift and go to state 186

state 161

    (51) condition -> IF ( expression ) gotoFalse . block conditionA continueGo
    (44) block -> . { blockA

    {               shift and go to state 173

    block                          shift and go to state 187

state 162

    (57) array -> ARR typeDim ID [ CTE_INTEGER . ] ;

    ]               shift and go to state 188


state 163

    (81) expression -> exp < = exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 81 (expression -> exp < = exp .)
    ;               reduce using rule 81 (expression -> exp < = exp .)
    ,               reduce using rule 81 (expression -> exp < = exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 164

    (80) expression -> exp < > exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 80 (expression -> exp < > exp .)
    ;               reduce using rule 80 (expression -> exp < > exp .)
    ,               reduce using rule 80 (expression -> exp < > exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 165

    (79) expression -> exp = = exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 79 (expression -> exp = = exp .)
    ;               reduce using rule 79 (expression -> exp = = exp .)
    ,               reduce using rule 79 (expression -> exp = = exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 166

    (82) expression -> exp > = exp .
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    )               reduce using rule 82 (expression -> exp > = exp .)
    ;               reduce using rule 82 (expression -> exp > = exp .)
    ,               reduce using rule 82 (expression -> exp > = exp .)
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 167

    (73) commandA -> OFF move exp ; .

    MOD             reduce using rule 73 (commandA -> OFF move exp ; .)
    IF              reduce using rule 73 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 73 (commandA -> OFF move exp ; .)
    WHILE           reduce using rule 73 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 73 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 73 (commandA -> OFF move exp ; .)
    #               reduce using rule 73 (commandA -> OFF move exp ; .)
    ARR             reduce using rule 73 (commandA -> OFF move exp ; .)
    MAT             reduce using rule 73 (commandA -> OFF move exp ; .)
    PIPE            reduce using rule 73 (commandA -> OFF move exp ; .)
    WHERE           reduce using rule 73 (commandA -> OFF move exp ; .)
    CLEAR           reduce using rule 73 (commandA -> OFF move exp ; .)
    ID              reduce using rule 73 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 73 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 73 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 73 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 73 (commandA -> OFF move exp ; .)
    END             reduce using rule 73 (commandA -> OFF move exp ; .)
    ]               reduce using rule 73 (commandA -> OFF move exp ; .)
    }               reduce using rule 73 (commandA -> OFF move exp ; .)


state 168

    (72) commandA -> ON move exp CTE_INTEGER . color ;
    (103) color -> . RED
    (104) color -> . YELLOW
    (105) color -> . BLUE
    (106) color -> . GREEN
    (107) color -> . BLACK
    (108) color -> . WHITE
    (109) color -> . ORANGE
    (110) color -> . PURPLE
    (111) color -> . CYAN

    RED             shift and go to state 122
    YELLOW          shift and go to state 117
    BLUE            shift and go to state 113
    GREEN           shift and go to state 116
    BLACK           shift and go to state 120
    WHITE           shift and go to state 121
    ORANGE          shift and go to state 119
    PURPLE          shift and go to state 115
    CYAN            shift and go to state 118

    color                          shift and go to state 189

state 169

    (30) id -> ID [ sumdim exp ] . [ sumdim exp ]
    (31) id -> ID [ sumdim exp ] .

    [               shift and go to state 190
    =               reduce using rule 31 (id -> ID [ sumdim exp ] .)


state 170

    (58) matrix -> MAT typeDim ID [ CTE_INTEGER . ] [ CTE_INTEGER ] ;

    ]               shift and go to state 191


state 171

    (21) moduleA -> ( . vars ) block
    (24) vars -> . type ID varsA
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOL

    INT             shift and go to state 194
    FLOAT           shift and go to state 193
    BOOL            shift and go to state 195

    type                           shift and go to state 196
    vars                           shift and go to state 192

state 172

    (22) moduleA -> block .

    MOD             reduce using rule 22 (moduleA -> block .)
    IF              reduce using rule 22 (moduleA -> block .)
    ECHO            reduce using rule 22 (moduleA -> block .)
    WHILE           reduce using rule 22 (moduleA -> block .)
    REPLAY          reduce using rule 22 (moduleA -> block .)
    SAMPLE          reduce using rule 22 (moduleA -> block .)
    #               reduce using rule 22 (moduleA -> block .)
    ARR             reduce using rule 22 (moduleA -> block .)
    MAT             reduce using rule 22 (moduleA -> block .)
    PIPE            reduce using rule 22 (moduleA -> block .)
    WHERE           reduce using rule 22 (moduleA -> block .)
    CLEAR           reduce using rule 22 (moduleA -> block .)
    ID              reduce using rule 22 (moduleA -> block .)
    OVAL            reduce using rule 22 (moduleA -> block .)
    TRIO            reduce using rule 22 (moduleA -> block .)
    QUAD            reduce using rule 22 (moduleA -> block .)
    ARC             reduce using rule 22 (moduleA -> block .)
    END             reduce using rule 22 (moduleA -> block .)


state 173

    (44) block -> { . blockA
    (45) blockA -> . blockB }
    (46) blockA -> . }
    (47) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (50) assign -> . id = expression ;
    (51) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (54) write -> . ECHO writeA ;
    (74) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (75) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (70) command -> . figure exp exp color ;
    (71) command -> . SAMPLE commandA
    (34) calling -> . # callID ( insertEra callingA
    (57) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (58) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (59) pipeline -> . PIPE ID pipelineA
    (112) screen -> . WHERE
    (113) screen -> . CLEAR
    (30) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (31) id -> . ID [ sumdim exp ]
    (32) id -> . ID
    (95) figure -> . OVAL
    (96) figure -> . TRIO
    (97) figure -> . QUAD
    (98) figure -> . ARC

    }               shift and go to state 198
    IF              shift and go to state 14
    ECHO            shift and go to state 21
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 22
    #               shift and go to state 11
    ARR             shift and go to state 20
    MAT             shift and go to state 31
    PIPE            shift and go to state 10
    WHERE           shift and go to state 33
    CLEAR           shift and go to state 15
    ID              shift and go to state 26
    OVAL            shift and go to state 5
    TRIO            shift and go to state 16
    QUAD            shift and go to state 25
    ARC             shift and go to state 34

    figure                         shift and go to state 3
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 12
    write                          shift and go to state 13
    command                        shift and go to state 35
    repeat                         shift and go to state 17
    screen                         shift and go to state 19
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    statute                        shift and go to state 197
    pipeline                       shift and go to state 30
    calling                        shift and go to state 32
    blockB                         shift and go to state 199
    blockA                         shift and go to state 200
    assign                         shift and go to state 38

state 174

    (20) module -> MOD # moduleID insertQuadMod moduleA . endMod
    (126) endMod -> .

    MOD             reduce using rule 126 (endMod -> .)
    IF              reduce using rule 126 (endMod -> .)
    ECHO            reduce using rule 126 (endMod -> .)
    WHILE           reduce using rule 126 (endMod -> .)
    REPLAY          reduce using rule 126 (endMod -> .)
    SAMPLE          reduce using rule 126 (endMod -> .)
    #               reduce using rule 126 (endMod -> .)
    ARR             reduce using rule 126 (endMod -> .)
    MAT             reduce using rule 126 (endMod -> .)
    PIPE            reduce using rule 126 (endMod -> .)
    WHERE           reduce using rule 126 (endMod -> .)
    CLEAR           reduce using rule 126 (endMod -> .)
    ID              reduce using rule 126 (endMod -> .)
    OVAL            reduce using rule 126 (endMod -> .)
    TRIO            reduce using rule 126 (endMod -> .)
    QUAD            reduce using rule 126 (endMod -> .)
    ARC             reduce using rule 126 (endMod -> .)
    END             reduce using rule 126 (endMod -> .)

    endMod                         shift and go to state 201

state 175

    (74) cycle -> WHILE gotoW ( expression ) gotoFalse . block continueGoW
    (44) block -> . { blockA

    {               shift and go to state 173

    block                          shift and go to state 202

state 176

    (75) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] . ;

    ;               shift and go to state 203


state 177

    (77) repeatB -> repeatA .

    ]               reduce using rule 77 (repeatB -> repeatA .)


state 178

    (76) repeatA -> command repeatB .

    ]               reduce using rule 76 (repeatA -> command repeatB .)


state 179

    (78) repeatB -> empty .

    ]               reduce using rule 78 (repeatB -> empty .)


state 180

    (61) pipelineA -> IN ( var_cte ) . ;

    ;               shift and go to state 204


state 181

    (60) pipelineA -> [ pipelineB ] ; .

    MOD             reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    IF              reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    ECHO            reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    WHILE           reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    REPLAY          reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    SAMPLE          reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    #               reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    ARR             reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    MAT             reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    PIPE            reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    WHERE           reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    CLEAR           reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    ID              reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    OVAL            reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    TRIO            reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    QUAD            reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    ARC             reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    END             reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)
    }               reduce using rule 60 (pipelineA -> [ pipelineB ] ; .)


state 182

    (65) pipelineC -> , pipelineB .

    ]               reduce using rule 65 (pipelineC -> , pipelineB .)


state 183

    (62) pipelineA -> OUT ( ) ; .

    MOD             reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    IF              reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    ECHO            reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    WHILE           reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    REPLAY          reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    SAMPLE          reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    #               reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    ARR             reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    MAT             reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    PIPE            reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    WHERE           reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    CLEAR           reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    ID              reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    OVAL            reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    TRIO            reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    QUAD            reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    ARC             reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    END             reduce using rule 62 (pipelineA -> OUT ( ) ; .)
    }               reduce using rule 62 (pipelineA -> OUT ( ) ; .)


state 184

    (38) callingA -> ) ; .

    MOD             reduce using rule 38 (callingA -> ) ; .)
    IF              reduce using rule 38 (callingA -> ) ; .)
    ECHO            reduce using rule 38 (callingA -> ) ; .)
    WHILE           reduce using rule 38 (callingA -> ) ; .)
    REPLAY          reduce using rule 38 (callingA -> ) ; .)
    SAMPLE          reduce using rule 38 (callingA -> ) ; .)
    #               reduce using rule 38 (callingA -> ) ; .)
    ARR             reduce using rule 38 (callingA -> ) ; .)
    MAT             reduce using rule 38 (callingA -> ) ; .)
    PIPE            reduce using rule 38 (callingA -> ) ; .)
    WHERE           reduce using rule 38 (callingA -> ) ; .)
    CLEAR           reduce using rule 38 (callingA -> ) ; .)
    ID              reduce using rule 38 (callingA -> ) ; .)
    OVAL            reduce using rule 38 (callingA -> ) ; .)
    TRIO            reduce using rule 38 (callingA -> ) ; .)
    QUAD            reduce using rule 38 (callingA -> ) ; .)
    ARC             reduce using rule 38 (callingA -> ) ; .)
    END             reduce using rule 38 (callingA -> ) ; .)
    }               reduce using rule 38 (callingA -> ) ; .)


state 185

    (37) callingA -> callingB ) . ;

    ;               shift and go to state 205


state 186

    (39) callingB -> expression checkParam . callingC
    (41) callingC -> . , sumXparam callingB
    (42) callingC -> . empty
    (127) empty -> .

    ,               shift and go to state 206
    )               reduce using rule 127 (empty -> .)

    callingC                       shift and go to state 207
    empty                          shift and go to state 208

state 187

    (51) condition -> IF ( expression ) gotoFalse block . conditionA continueGo
    (52) conditionA -> . ELSE gotoE block
    (53) conditionA -> . empty
    (127) empty -> .

    ELSE            shift and go to state 211
    MOD             reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    ECHO            reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    REPLAY          reduce using rule 127 (empty -> .)
    SAMPLE          reduce using rule 127 (empty -> .)
    #               reduce using rule 127 (empty -> .)
    ARR             reduce using rule 127 (empty -> .)
    MAT             reduce using rule 127 (empty -> .)
    PIPE            reduce using rule 127 (empty -> .)
    WHERE           reduce using rule 127 (empty -> .)
    CLEAR           reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    OVAL            reduce using rule 127 (empty -> .)
    TRIO            reduce using rule 127 (empty -> .)
    QUAD            reduce using rule 127 (empty -> .)
    ARC             reduce using rule 127 (empty -> .)
    END             reduce using rule 127 (empty -> .)
    }               reduce using rule 127 (empty -> .)

    conditionA                     shift and go to state 209
    empty                          shift and go to state 210

state 188

    (57) array -> ARR typeDim ID [ CTE_INTEGER ] . ;

    ;               shift and go to state 212


state 189

    (72) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 213


state 190

    (30) id -> ID [ sumdim exp ] [ . sumdim exp ]
    (33) sumdim -> .

    (               reduce using rule 33 (sumdim -> .)
    ID              reduce using rule 33 (sumdim -> .)
    CTE_INTEGER     reduce using rule 33 (sumdim -> .)
    CTE_FLOAT       reduce using rule 33 (sumdim -> .)
    TRUE            reduce using rule 33 (sumdim -> .)
    FALSE           reduce using rule 33 (sumdim -> .)

    sumdim                         shift and go to state 214

state 191

    (58) matrix -> MAT typeDim ID [ CTE_INTEGER ] . [ CTE_INTEGER ] ;

    [               shift and go to state 215


state 192

    (21) moduleA -> ( vars . ) block

    )               shift and go to state 216


state 193

    (28) type -> FLOAT .

    ID              reduce using rule 28 (type -> FLOAT .)


state 194

    (27) type -> INT .

    ID              reduce using rule 27 (type -> INT .)


state 195

    (29) type -> BOOL .

    ID              reduce using rule 29 (type -> BOOL .)


state 196

    (24) vars -> type . ID varsA

    ID              shift and go to state 217


state 197

    (47) blockB -> statute . blockC
    (48) blockC -> . blockB
    (49) blockC -> . empty
    (47) blockB -> . statute blockC
    (127) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . pipeline
    (19) statute -> . screen
    (50) assign -> . id = expression ;
    (51) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (54) write -> . ECHO writeA ;
    (74) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (75) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (70) command -> . figure exp exp color ;
    (71) command -> . SAMPLE commandA
    (34) calling -> . # callID ( insertEra callingA
    (57) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (58) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (59) pipeline -> . PIPE ID pipelineA
    (112) screen -> . WHERE
    (113) screen -> . CLEAR
    (30) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (31) id -> . ID [ sumdim exp ]
    (32) id -> . ID
    (95) figure -> . OVAL
    (96) figure -> . TRIO
    (97) figure -> . QUAD
    (98) figure -> . ARC

    }               reduce using rule 127 (empty -> .)
    IF              shift and go to state 14
    ECHO            shift and go to state 21
    WHILE           shift and go to state 6
    REPLAY          shift and go to state 7
    SAMPLE          shift and go to state 22
    #               shift and go to state 11
    ARR             shift and go to state 20
    MAT             shift and go to state 31
    PIPE            shift and go to state 10
    WHERE           shift and go to state 33
    CLEAR           shift and go to state 15
    ID              shift and go to state 26
    OVAL            shift and go to state 5
    TRIO            shift and go to state 16
    QUAD            shift and go to state 25
    ARC             shift and go to state 34

    figure                         shift and go to state 3
    array                          shift and go to state 8
    id                             shift and go to state 9
    matrix                         shift and go to state 12
    write                          shift and go to state 13
    command                        shift and go to state 35
    empty                          shift and go to state 218
    repeat                         shift and go to state 17
    screen                         shift and go to state 19
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    statute                        shift and go to state 197
    pipeline                       shift and go to state 30
    calling                        shift and go to state 32
    blockC                         shift and go to state 219
    blockB                         shift and go to state 220
    assign                         shift and go to state 38

state 198

    (46) blockA -> } .

    MOD             reduce using rule 46 (blockA -> } .)
    IF              reduce using rule 46 (blockA -> } .)
    ECHO            reduce using rule 46 (blockA -> } .)
    WHILE           reduce using rule 46 (blockA -> } .)
    REPLAY          reduce using rule 46 (blockA -> } .)
    SAMPLE          reduce using rule 46 (blockA -> } .)
    #               reduce using rule 46 (blockA -> } .)
    ARR             reduce using rule 46 (blockA -> } .)
    MAT             reduce using rule 46 (blockA -> } .)
    PIPE            reduce using rule 46 (blockA -> } .)
    WHERE           reduce using rule 46 (blockA -> } .)
    CLEAR           reduce using rule 46 (blockA -> } .)
    ID              reduce using rule 46 (blockA -> } .)
    OVAL            reduce using rule 46 (blockA -> } .)
    TRIO            reduce using rule 46 (blockA -> } .)
    QUAD            reduce using rule 46 (blockA -> } .)
    ARC             reduce using rule 46 (blockA -> } .)
    END             reduce using rule 46 (blockA -> } .)
    ELSE            reduce using rule 46 (blockA -> } .)
    }               reduce using rule 46 (blockA -> } .)


state 199

    (45) blockA -> blockB . }

    }               shift and go to state 221


state 200

    (44) block -> { blockA .

    MOD             reduce using rule 44 (block -> { blockA .)
    IF              reduce using rule 44 (block -> { blockA .)
    ECHO            reduce using rule 44 (block -> { blockA .)
    WHILE           reduce using rule 44 (block -> { blockA .)
    REPLAY          reduce using rule 44 (block -> { blockA .)
    SAMPLE          reduce using rule 44 (block -> { blockA .)
    #               reduce using rule 44 (block -> { blockA .)
    ARR             reduce using rule 44 (block -> { blockA .)
    MAT             reduce using rule 44 (block -> { blockA .)
    PIPE            reduce using rule 44 (block -> { blockA .)
    WHERE           reduce using rule 44 (block -> { blockA .)
    CLEAR           reduce using rule 44 (block -> { blockA .)
    ID              reduce using rule 44 (block -> { blockA .)
    OVAL            reduce using rule 44 (block -> { blockA .)
    TRIO            reduce using rule 44 (block -> { blockA .)
    QUAD            reduce using rule 44 (block -> { blockA .)
    ARC             reduce using rule 44 (block -> { blockA .)
    END             reduce using rule 44 (block -> { blockA .)
    }               reduce using rule 44 (block -> { blockA .)
    ELSE            reduce using rule 44 (block -> { blockA .)


state 201

    (20) module -> MOD # moduleID insertQuadMod moduleA endMod .

    MOD             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    IF              reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ECHO            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    WHILE           reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    REPLAY          reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    SAMPLE          reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    #               reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ARR             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    MAT             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    PIPE            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    WHERE           reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    CLEAR           reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ID              reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    OVAL            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    TRIO            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    QUAD            reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    ARC             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)
    END             reduce using rule 20 (module -> MOD # moduleID insertQuadMod moduleA endMod .)


state 202

    (74) cycle -> WHILE gotoW ( expression ) gotoFalse block . continueGoW
    (124) continueGoW -> .

    MOD             reduce using rule 124 (continueGoW -> .)
    IF              reduce using rule 124 (continueGoW -> .)
    ECHO            reduce using rule 124 (continueGoW -> .)
    WHILE           reduce using rule 124 (continueGoW -> .)
    REPLAY          reduce using rule 124 (continueGoW -> .)
    SAMPLE          reduce using rule 124 (continueGoW -> .)
    #               reduce using rule 124 (continueGoW -> .)
    ARR             reduce using rule 124 (continueGoW -> .)
    MAT             reduce using rule 124 (continueGoW -> .)
    PIPE            reduce using rule 124 (continueGoW -> .)
    WHERE           reduce using rule 124 (continueGoW -> .)
    CLEAR           reduce using rule 124 (continueGoW -> .)
    ID              reduce using rule 124 (continueGoW -> .)
    OVAL            reduce using rule 124 (continueGoW -> .)
    TRIO            reduce using rule 124 (continueGoW -> .)
    QUAD            reduce using rule 124 (continueGoW -> .)
    ARC             reduce using rule 124 (continueGoW -> .)
    END             reduce using rule 124 (continueGoW -> .)
    }               reduce using rule 124 (continueGoW -> .)

    continueGoW                    shift and go to state 222

state 203

    (75) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .

    MOD             reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    IF              reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ECHO            reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHILE           reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    REPLAY          reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    SAMPLE          reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    #               reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARR             reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MAT             reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    PIPE            reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHERE           reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    CLEAR           reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ID              reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    OVAL            reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    TRIO            reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    QUAD            reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARC             reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    END             reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    }               reduce using rule 75 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)


state 204

    (61) pipelineA -> IN ( var_cte ) ; .

    MOD             reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    IF              reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    ECHO            reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    WHILE           reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    REPLAY          reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    SAMPLE          reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    #               reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    ARR             reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    MAT             reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    PIPE            reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    WHERE           reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    CLEAR           reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    ID              reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    OVAL            reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    TRIO            reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    QUAD            reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    ARC             reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    END             reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)
    }               reduce using rule 61 (pipelineA -> IN ( var_cte ) ; .)


state 205

    (37) callingA -> callingB ) ; .

    MOD             reduce using rule 37 (callingA -> callingB ) ; .)
    IF              reduce using rule 37 (callingA -> callingB ) ; .)
    ECHO            reduce using rule 37 (callingA -> callingB ) ; .)
    WHILE           reduce using rule 37 (callingA -> callingB ) ; .)
    REPLAY          reduce using rule 37 (callingA -> callingB ) ; .)
    SAMPLE          reduce using rule 37 (callingA -> callingB ) ; .)
    #               reduce using rule 37 (callingA -> callingB ) ; .)
    ARR             reduce using rule 37 (callingA -> callingB ) ; .)
    MAT             reduce using rule 37 (callingA -> callingB ) ; .)
    PIPE            reduce using rule 37 (callingA -> callingB ) ; .)
    WHERE           reduce using rule 37 (callingA -> callingB ) ; .)
    CLEAR           reduce using rule 37 (callingA -> callingB ) ; .)
    ID              reduce using rule 37 (callingA -> callingB ) ; .)
    OVAL            reduce using rule 37 (callingA -> callingB ) ; .)
    TRIO            reduce using rule 37 (callingA -> callingB ) ; .)
    QUAD            reduce using rule 37 (callingA -> callingB ) ; .)
    ARC             reduce using rule 37 (callingA -> callingB ) ; .)
    END             reduce using rule 37 (callingA -> callingB ) ; .)
    }               reduce using rule 37 (callingA -> callingB ) ; .)


state 206

    (41) callingC -> , . sumXparam callingB
    (43) sumXparam -> .

    (               reduce using rule 43 (sumXparam -> .)
    ID              reduce using rule 43 (sumXparam -> .)
    CTE_INTEGER     reduce using rule 43 (sumXparam -> .)
    CTE_FLOAT       reduce using rule 43 (sumXparam -> .)
    TRUE            reduce using rule 43 (sumXparam -> .)
    FALSE           reduce using rule 43 (sumXparam -> .)

    sumXparam                      shift and go to state 223

state 207

    (39) callingB -> expression checkParam callingC .

    )               reduce using rule 39 (callingB -> expression checkParam callingC .)


state 208

    (42) callingC -> empty .

    )               reduce using rule 42 (callingC -> empty .)


state 209

    (51) condition -> IF ( expression ) gotoFalse block conditionA . continueGo
    (123) continueGo -> .

    MOD             reduce using rule 123 (continueGo -> .)
    IF              reduce using rule 123 (continueGo -> .)
    ECHO            reduce using rule 123 (continueGo -> .)
    WHILE           reduce using rule 123 (continueGo -> .)
    REPLAY          reduce using rule 123 (continueGo -> .)
    SAMPLE          reduce using rule 123 (continueGo -> .)
    #               reduce using rule 123 (continueGo -> .)
    ARR             reduce using rule 123 (continueGo -> .)
    MAT             reduce using rule 123 (continueGo -> .)
    PIPE            reduce using rule 123 (continueGo -> .)
    WHERE           reduce using rule 123 (continueGo -> .)
    CLEAR           reduce using rule 123 (continueGo -> .)
    ID              reduce using rule 123 (continueGo -> .)
    OVAL            reduce using rule 123 (continueGo -> .)
    TRIO            reduce using rule 123 (continueGo -> .)
    QUAD            reduce using rule 123 (continueGo -> .)
    ARC             reduce using rule 123 (continueGo -> .)
    END             reduce using rule 123 (continueGo -> .)
    }               reduce using rule 123 (continueGo -> .)

    continueGo                     shift and go to state 224

state 210

    (53) conditionA -> empty .

    MOD             reduce using rule 53 (conditionA -> empty .)
    IF              reduce using rule 53 (conditionA -> empty .)
    ECHO            reduce using rule 53 (conditionA -> empty .)
    WHILE           reduce using rule 53 (conditionA -> empty .)
    REPLAY          reduce using rule 53 (conditionA -> empty .)
    SAMPLE          reduce using rule 53 (conditionA -> empty .)
    #               reduce using rule 53 (conditionA -> empty .)
    ARR             reduce using rule 53 (conditionA -> empty .)
    MAT             reduce using rule 53 (conditionA -> empty .)
    PIPE            reduce using rule 53 (conditionA -> empty .)
    WHERE           reduce using rule 53 (conditionA -> empty .)
    CLEAR           reduce using rule 53 (conditionA -> empty .)
    ID              reduce using rule 53 (conditionA -> empty .)
    OVAL            reduce using rule 53 (conditionA -> empty .)
    TRIO            reduce using rule 53 (conditionA -> empty .)
    QUAD            reduce using rule 53 (conditionA -> empty .)
    ARC             reduce using rule 53 (conditionA -> empty .)
    END             reduce using rule 53 (conditionA -> empty .)
    }               reduce using rule 53 (conditionA -> empty .)


state 211

    (52) conditionA -> ELSE . gotoE block
    (120) gotoE -> .

    {               reduce using rule 120 (gotoE -> .)

    gotoE                          shift and go to state 225

state 212

    (57) array -> ARR typeDim ID [ CTE_INTEGER ] ; .

    IF              reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    #               reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    PIPE            reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHERE           reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    CLEAR           reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ID              reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    }               reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    END             reduce using rule 57 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)


state 213

    (72) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHILE           reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARR             reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    MAT             reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    PIPE            reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHERE           reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    CLEAR           reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 72 (commandA -> ON move exp CTE_INTEGER color ; .)


state 214

    (30) id -> ID [ sumdim exp ] [ sumdim . exp ]
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    exp                            shift and go to state 226
    factor                         shift and go to state 45

state 215

    (58) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 227


state 216

    (21) moduleA -> ( vars ) . block
    (44) block -> . { blockA

    {               shift and go to state 173

    block                          shift and go to state 228

state 217

    (24) vars -> type ID . varsA
    (25) varsA -> . , vars
    (26) varsA -> . empty
    (127) empty -> .

    ,               shift and go to state 230
    )               reduce using rule 127 (empty -> .)

    varsA                          shift and go to state 229
    empty                          shift and go to state 231

state 218

    (49) blockC -> empty .

    }               reduce using rule 49 (blockC -> empty .)


state 219

    (47) blockB -> statute blockC .

    }               reduce using rule 47 (blockB -> statute blockC .)


state 220

    (48) blockC -> blockB .

    }               reduce using rule 48 (blockC -> blockB .)


state 221

    (45) blockA -> blockB } .

    MOD             reduce using rule 45 (blockA -> blockB } .)
    IF              reduce using rule 45 (blockA -> blockB } .)
    ECHO            reduce using rule 45 (blockA -> blockB } .)
    WHILE           reduce using rule 45 (blockA -> blockB } .)
    REPLAY          reduce using rule 45 (blockA -> blockB } .)
    SAMPLE          reduce using rule 45 (blockA -> blockB } .)
    #               reduce using rule 45 (blockA -> blockB } .)
    ARR             reduce using rule 45 (blockA -> blockB } .)
    MAT             reduce using rule 45 (blockA -> blockB } .)
    PIPE            reduce using rule 45 (blockA -> blockB } .)
    WHERE           reduce using rule 45 (blockA -> blockB } .)
    CLEAR           reduce using rule 45 (blockA -> blockB } .)
    ID              reduce using rule 45 (blockA -> blockB } .)
    OVAL            reduce using rule 45 (blockA -> blockB } .)
    TRIO            reduce using rule 45 (blockA -> blockB } .)
    QUAD            reduce using rule 45 (blockA -> blockB } .)
    ARC             reduce using rule 45 (blockA -> blockB } .)
    END             reduce using rule 45 (blockA -> blockB } .)
    ELSE            reduce using rule 45 (blockA -> blockB } .)
    }               reduce using rule 45 (blockA -> blockB } .)


state 222

    (74) cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .

    MOD             reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    IF              reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ECHO            reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHILE           reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    REPLAY          reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    SAMPLE          reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    #               reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARR             reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    MAT             reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    PIPE            reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHERE           reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    CLEAR           reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ID              reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    OVAL            reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    TRIO            reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    QUAD            reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARC             reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    END             reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    }               reduce using rule 74 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)


state 223

    (41) callingC -> , sumXparam . callingB
    (39) callingB -> . expression checkParam callingC
    (79) expression -> . exp = = exp
    (80) expression -> . exp < > exp
    (81) expression -> . exp < = exp
    (82) expression -> . exp > = exp
    (83) expression -> . exp > exp
    (84) expression -> . exp < exp
    (85) expression -> . exp AND exp
    (86) expression -> . exp OR exp
    (87) expression -> . exp empty
    (88) exp -> . exp + exp
    (89) exp -> . exp - exp
    (90) exp -> . exp * exp
    (91) exp -> . exp / exp
    (92) exp -> . factor empty
    (93) factor -> . ( expression )
    (94) factor -> . var_cte
    (114) var_cte -> . ID
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE

    (               shift and go to state 40
    ID              shift and go to state 47
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 39
    TRUE            shift and go to state 43
    FALSE           shift and go to state 46

    var_cte                        shift and go to state 41
    callingB                       shift and go to state 232
    exp                            shift and go to state 61
    factor                         shift and go to state 45
    expression                     shift and go to state 160

state 224

    (51) condition -> IF ( expression ) gotoFalse block conditionA continueGo .

    MOD             reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    IF              reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ECHO            reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHILE           reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    REPLAY          reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    SAMPLE          reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    #               reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARR             reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MAT             reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    PIPE            reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHERE           reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    CLEAR           reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ID              reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    OVAL            reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    TRIO            reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    QUAD            reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARC             reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    END             reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    }               reduce using rule 51 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)


state 225

    (52) conditionA -> ELSE gotoE . block
    (44) block -> . { blockA

    {               shift and go to state 173

    block                          shift and go to state 233

state 226

    (30) id -> ID [ sumdim exp ] [ sumdim exp . ]
    (88) exp -> exp . + exp
    (89) exp -> exp . - exp
    (90) exp -> exp . * exp
    (91) exp -> exp . / exp

    ]               shift and go to state 234
    +               shift and go to state 74
    -               shift and go to state 76
    *               shift and go to state 75
    /               shift and go to state 77


state 227

    (58) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER . ] ;

    ]               shift and go to state 235


state 228

    (21) moduleA -> ( vars ) block .

    MOD             reduce using rule 21 (moduleA -> ( vars ) block .)
    IF              reduce using rule 21 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 21 (moduleA -> ( vars ) block .)
    WHILE           reduce using rule 21 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 21 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 21 (moduleA -> ( vars ) block .)
    #               reduce using rule 21 (moduleA -> ( vars ) block .)
    ARR             reduce using rule 21 (moduleA -> ( vars ) block .)
    MAT             reduce using rule 21 (moduleA -> ( vars ) block .)
    PIPE            reduce using rule 21 (moduleA -> ( vars ) block .)
    WHERE           reduce using rule 21 (moduleA -> ( vars ) block .)
    CLEAR           reduce using rule 21 (moduleA -> ( vars ) block .)
    ID              reduce using rule 21 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 21 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 21 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 21 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 21 (moduleA -> ( vars ) block .)
    END             reduce using rule 21 (moduleA -> ( vars ) block .)


state 229

    (24) vars -> type ID varsA .

    )               reduce using rule 24 (vars -> type ID varsA .)


state 230

    (25) varsA -> , . vars
    (24) vars -> . type ID varsA
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOL

    INT             shift and go to state 194
    FLOAT           shift and go to state 193
    BOOL            shift and go to state 195

    type                           shift and go to state 196
    vars                           shift and go to state 236

state 231

    (26) varsA -> empty .

    )               reduce using rule 26 (varsA -> empty .)


state 232

    (41) callingC -> , sumXparam callingB .

    )               reduce using rule 41 (callingC -> , sumXparam callingB .)


state 233

    (52) conditionA -> ELSE gotoE block .

    MOD             reduce using rule 52 (conditionA -> ELSE gotoE block .)
    IF              reduce using rule 52 (conditionA -> ELSE gotoE block .)
    ECHO            reduce using rule 52 (conditionA -> ELSE gotoE block .)
    WHILE           reduce using rule 52 (conditionA -> ELSE gotoE block .)
    REPLAY          reduce using rule 52 (conditionA -> ELSE gotoE block .)
    SAMPLE          reduce using rule 52 (conditionA -> ELSE gotoE block .)
    #               reduce using rule 52 (conditionA -> ELSE gotoE block .)
    ARR             reduce using rule 52 (conditionA -> ELSE gotoE block .)
    MAT             reduce using rule 52 (conditionA -> ELSE gotoE block .)
    PIPE            reduce using rule 52 (conditionA -> ELSE gotoE block .)
    WHERE           reduce using rule 52 (conditionA -> ELSE gotoE block .)
    CLEAR           reduce using rule 52 (conditionA -> ELSE gotoE block .)
    ID              reduce using rule 52 (conditionA -> ELSE gotoE block .)
    OVAL            reduce using rule 52 (conditionA -> ELSE gotoE block .)
    TRIO            reduce using rule 52 (conditionA -> ELSE gotoE block .)
    QUAD            reduce using rule 52 (conditionA -> ELSE gotoE block .)
    ARC             reduce using rule 52 (conditionA -> ELSE gotoE block .)
    END             reduce using rule 52 (conditionA -> ELSE gotoE block .)
    }               reduce using rule 52 (conditionA -> ELSE gotoE block .)


state 234

    (30) id -> ID [ sumdim exp ] [ sumdim exp ] .

    =               reduce using rule 30 (id -> ID [ sumdim exp ] [ sumdim exp ] .)


state 235

    (58) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] . ;

    ;               shift and go to state 237


state 236

    (25) varsA -> , vars .

    )               reduce using rule 25 (varsA -> , vars .)


state 237

    (58) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .

    MOD             reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    IF              reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    #               reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    PIPE            reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHERE           reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    CLEAR           reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ID              reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    END             reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    }               reduce using rule 58 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)

