Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> INIT programA
Rule 2     programA -> programB END
Rule 3     programA -> END
Rule 4     programB -> workspace programC
Rule 5     programC -> programB
Rule 6     programC -> empty
Rule 7     workspace -> statute
Rule 8     workspace -> module
Rule 9     statute -> assign
Rule 10    statute -> condition
Rule 11    statute -> write
Rule 12    statute -> cycle
Rule 13    statute -> repeat
Rule 14    statute -> command
Rule 15    statute -> calling
Rule 16    statute -> array
Rule 17    statute -> matrix
Rule 18    statute -> return
Rule 19    typeMod -> INT
Rule 20    typeMod -> FLOAT
Rule 21    typeMod -> BOOL
Rule 22    typeMod -> empty
Rule 23    addMod -> <empty>
Rule 24    module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
Rule 25    moduleA -> ( vars ) block
Rule 26    moduleA -> block
Rule 27    moduleID -> ID
Rule 28    vars -> type ID varsA
Rule 29    varsA -> , vars
Rule 30    varsA -> empty
Rule 31    type -> INT
Rule 32    type -> FLOAT
Rule 33    type -> BOOL
Rule 34    id -> ID [ sumdim exp ] [ sumdim exp ]
Rule 35    id -> ID [ sumdim exp ]
Rule 36    id -> callID # calling2
Rule 37    id -> ID empty
Rule 38    sumdim -> <empty>
Rule 39    calling -> # callID calling2 ;
Rule 40    calling2 -> ( maincalling )
Rule 41    maincalling -> insertEra callingA
Rule 42    callID -> ID
Rule 43    insertEra -> <empty>
Rule 44    callingA -> callingB
Rule 45    callingA -> empty
Rule 46    callingB -> exp checkParam callingC
Rule 47    checkParam -> <empty>
Rule 48    callingC -> , sumXparam callingB
Rule 49    callingC -> empty
Rule 50    sumXparam -> <empty>
Rule 51    block -> { blockA
Rule 52    blockA -> blockB }
Rule 53    blockA -> }
Rule 54    blockB -> statute blockC
Rule 55    blockC -> blockB
Rule 56    blockC -> empty
Rule 57    assign -> id = expression ;
Rule 58    condition -> IF ( expression ) gotoFalse block conditionA continueGo
Rule 59    conditionA -> ELSE gotoE block
Rule 60    conditionA -> empty
Rule 61    write -> ECHO ( writeA writeB ) ;
Rule 62    writeA -> expression
Rule 63    writeA -> CTE_STRING
Rule 64    writeB -> , writeA
Rule 65    writeB -> empty
Rule 66    array -> ARR typeDim ID [ CTE_INTEGER ] ;
Rule 67    matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
Rule 68    typeDim -> INT
Rule 69    typeDim -> FLOAT
Rule 70    typeDim -> BOOL
Rule 71    command -> figure exp exp color ;
Rule 72    command -> SAMPLE commandA
Rule 73    commandA -> ON move exp CTE_INTEGER color ;
Rule 74    commandA -> OFF move exp ;
Rule 75    cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW
Rule 76    repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ;
Rule 77    repeatA -> command repeatB
Rule 78    repeatB -> repeatA
Rule 79    repeatB -> empty
Rule 80    expression -> exp = = exp
Rule 81    expression -> exp < > exp
Rule 82    expression -> exp < = exp
Rule 83    expression -> exp > = exp
Rule 84    expression -> exp > exp
Rule 85    expression -> exp < exp
Rule 86    expression -> exp AND exp
Rule 87    expression -> exp OR exp
Rule 88    expression -> exp empty
Rule 89    exp -> exp + exp
Rule 90    exp -> exp - exp
Rule 91    exp -> exp * exp
Rule 92    exp -> exp / exp
Rule 93    exp -> factor empty
Rule 94    return -> RETURN exp ;
Rule 95    factor -> ( expression )
Rule 96    factor -> var_cte
Rule 97    figure -> OVAL
Rule 98    figure -> TRIO
Rule 99    figure -> QUAD
Rule 100   figure -> ARC
Rule 101   move -> UP
Rule 102   move -> DOWN
Rule 103   move -> LEFT
Rule 104   move -> RIGHT
Rule 105   color -> RED
Rule 106   color -> YELLOW
Rule 107   color -> BLUE
Rule 108   color -> GREEN
Rule 109   color -> BLACK
Rule 110   color -> WHITE
Rule 111   color -> ORANGE
Rule 112   color -> PURPLE
Rule 113   color -> CYAN
Rule 114   var_cte -> id
Rule 115   var_cte -> CTE_INTEGER
Rule 116   var_cte -> CTE_FLOAT
Rule 117   var_cte -> TRUE
Rule 118   var_cte -> FALSE
Rule 119   gotoFalse -> <empty>
Rule 120   gotoE -> <empty>
Rule 121   gotoW -> <empty>
Rule 122   gotoR -> <empty>
Rule 123   continueGo -> <empty>
Rule 124   continueGoW -> <empty>
Rule 125   insertQuadMod -> <empty>
Rule 126   endMod -> <empty>
Rule 127   empty -> <empty>

Terminals, with rules where they appear

#                    : 24 36 39
(                    : 25 40 58 61 75 95
)                    : 25 40 58 61 75 95
*                    : 91
+                    : 89
,                    : 29 48 64
-                    : 90
/                    : 92
;                    : 39 57 61 66 67 71 73 74 76 94
<                    : 81 82 85
=                    : 57 80 80 82 83
>                    : 81 83 84
AND                  : 86
ARC                  : 100
ARR                  : 66
BLACK                : 109
BLUE                 : 107
BOOL                 : 21 33 70
CTE_FLOAT            : 116
CTE_INTEGER          : 66 67 67 73 76 115
CTE_STRING           : 63
CYAN                 : 113
DOWN                 : 102
ECHO                 : 61
ELSE                 : 59
END                  : 2 3
FALSE                : 118
FLOAT                : 20 32 69
GREEN                : 108
ID                   : 27 28 34 35 37 42 66 67
IF                   : 58
INIT                 : 1
INT                  : 19 31 68
LEFT                 : 103
MAT                  : 67
MOD                  : 24
OFF                  : 74
ON                   : 73
OR                   : 87
ORANGE               : 111
OVAL                 : 97
PURPLE               : 112
QUAD                 : 99
RED                  : 105
REPLAY               : 76
RETURN               : 94
RIGHT                : 104
SAMPLE               : 72
TRIO                 : 98
TRUE                 : 117
UP                   : 101
WHILE                : 75
WHITE                : 110
YELLOW               : 106
[                    : 34 34 35 66 67 67 76
]                    : 34 34 35 66 67 67 76
error                : 
{                    : 51
}                    : 52 53

Nonterminals, with rules where they appear

addMod               : 24
array                : 16
assign               : 9
block                : 25 26 58 59 75
blockA               : 51
blockB               : 52 55
blockC               : 54
callID               : 36 39
calling              : 15
calling2             : 36 39
callingA             : 41
callingB             : 44 48
callingC             : 46
checkParam           : 46
color                : 71 73
command              : 14 77
commandA             : 72
condition            : 10
conditionA           : 58
continueGo           : 58
continueGoW          : 75
cycle                : 12
empty                : 6 22 30 37 45 49 56 60 65 79 88 93
endMod               : 24
exp                  : 34 34 35 46 71 71 73 74 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 89 89 90 90 91 91 92 92 94
expression           : 57 58 62 75 95
factor               : 93
figure               : 71
gotoE                : 59
gotoFalse            : 58 75
gotoR                : 76
gotoW                : 75
id                   : 57 114
insertEra            : 41
insertQuadMod        : 24
maincalling          : 40
matrix               : 17
module               : 8
moduleA              : 24
moduleID             : 24
move                 : 73 74
program              : 0
programA             : 1
programB             : 2 5
programC             : 4
repeat               : 13
repeatA              : 76 78
repeatB              : 77
return               : 18
statute              : 7 54
sumXparam            : 48
sumdim               : 34 34 35
type                 : 28
typeDim              : 66 67
typeMod              : 24
var_cte              : 96
vars                 : 25 29
varsA                : 28
workspace            : 4
write                : 11
writeA               : 61 64
writeB               : 61

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . INIT programA

    INIT            shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> INIT . programA
    (2) programA -> . programB END
    (3) programA -> . END
    (4) programB -> . workspace programC
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . return
    (24) module -> . MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
    (57) assign -> . id = expression ;
    (58) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (61) write -> . ECHO ( writeA writeB ) ;
    (75) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (76) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (71) command -> . figure exp exp color ;
    (72) command -> . SAMPLE commandA
    (39) calling -> . # callID calling2 ;
    (66) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (67) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (94) return -> . RETURN exp ;
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (97) figure -> . OVAL
    (98) figure -> . TRIO
    (99) figure -> . QUAD
    (100) figure -> . ARC
    (42) callID -> . ID

    END             shift and go to state 19
    MOD             shift and go to state 35
    IF              shift and go to state 16
    ECHO            shift and go to state 20
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 21
    #               shift and go to state 13
    ARR             shift and go to state 29
    MAT             shift and go to state 30
    RETURN          shift and go to state 3
    ID              shift and go to state 25
    OVAL            shift and go to state 7
    TRIO            shift and go to state 17
    QUAD            shift and go to state 24
    ARC             shift and go to state 32

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    module                         shift and go to state 6
    array                          shift and go to state 11
    id                             shift and go to state 12
    matrix                         shift and go to state 14
    write                          shift and go to state 15
    condition                      shift and go to state 26
    repeat                         shift and go to state 18
    return                         shift and go to state 10
    programA                       shift and go to state 22
    programB                       shift and go to state 23
    cycle                          shift and go to state 27
    statute                        shift and go to state 28
    calling                        shift and go to state 31
    command                        shift and go to state 33
    workspace                      shift and go to state 34
    assign                         shift and go to state 36

state 2

    (0) S' -> program .



state 3

    (94) return -> RETURN . exp ;
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 45
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 4

    (71) command -> figure . exp exp color ;
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 5

    (36) id -> callID . # calling2

    #               shift and go to state 47


state 6

    (8) workspace -> module .

    MOD             reduce using rule 8 (workspace -> module .)
    IF              reduce using rule 8 (workspace -> module .)
    ECHO            reduce using rule 8 (workspace -> module .)
    WHILE           reduce using rule 8 (workspace -> module .)
    REPLAY          reduce using rule 8 (workspace -> module .)
    SAMPLE          reduce using rule 8 (workspace -> module .)
    #               reduce using rule 8 (workspace -> module .)
    ARR             reduce using rule 8 (workspace -> module .)
    MAT             reduce using rule 8 (workspace -> module .)
    RETURN          reduce using rule 8 (workspace -> module .)
    ID              reduce using rule 8 (workspace -> module .)
    OVAL            reduce using rule 8 (workspace -> module .)
    TRIO            reduce using rule 8 (workspace -> module .)
    QUAD            reduce using rule 8 (workspace -> module .)
    ARC             reduce using rule 8 (workspace -> module .)
    END             reduce using rule 8 (workspace -> module .)


state 7

    (97) figure -> OVAL .

    (               reduce using rule 97 (figure -> OVAL .)
    CTE_INTEGER     reduce using rule 97 (figure -> OVAL .)
    CTE_FLOAT       reduce using rule 97 (figure -> OVAL .)
    TRUE            reduce using rule 97 (figure -> OVAL .)
    FALSE           reduce using rule 97 (figure -> OVAL .)
    ID              reduce using rule 97 (figure -> OVAL .)


state 8

    (75) cycle -> WHILE . gotoW ( expression ) gotoFalse block continueGoW
    (121) gotoW -> .

    (               reduce using rule 121 (gotoW -> .)

    gotoW                          shift and go to state 48

state 9

    (76) repeat -> REPLAY . CTE_INTEGER gotoR [ repeatA ] ;

    CTE_INTEGER     shift and go to state 49


state 10

    (18) statute -> return .

    IF              reduce using rule 18 (statute -> return .)
    ECHO            reduce using rule 18 (statute -> return .)
    WHILE           reduce using rule 18 (statute -> return .)
    REPLAY          reduce using rule 18 (statute -> return .)
    SAMPLE          reduce using rule 18 (statute -> return .)
    #               reduce using rule 18 (statute -> return .)
    ARR             reduce using rule 18 (statute -> return .)
    MAT             reduce using rule 18 (statute -> return .)
    RETURN          reduce using rule 18 (statute -> return .)
    ID              reduce using rule 18 (statute -> return .)
    OVAL            reduce using rule 18 (statute -> return .)
    TRIO            reduce using rule 18 (statute -> return .)
    QUAD            reduce using rule 18 (statute -> return .)
    ARC             reduce using rule 18 (statute -> return .)
    }               reduce using rule 18 (statute -> return .)
    MOD             reduce using rule 18 (statute -> return .)
    END             reduce using rule 18 (statute -> return .)


state 11

    (16) statute -> array .

    IF              reduce using rule 16 (statute -> array .)
    ECHO            reduce using rule 16 (statute -> array .)
    WHILE           reduce using rule 16 (statute -> array .)
    REPLAY          reduce using rule 16 (statute -> array .)
    SAMPLE          reduce using rule 16 (statute -> array .)
    #               reduce using rule 16 (statute -> array .)
    ARR             reduce using rule 16 (statute -> array .)
    MAT             reduce using rule 16 (statute -> array .)
    RETURN          reduce using rule 16 (statute -> array .)
    ID              reduce using rule 16 (statute -> array .)
    OVAL            reduce using rule 16 (statute -> array .)
    TRIO            reduce using rule 16 (statute -> array .)
    QUAD            reduce using rule 16 (statute -> array .)
    ARC             reduce using rule 16 (statute -> array .)
    }               reduce using rule 16 (statute -> array .)
    MOD             reduce using rule 16 (statute -> array .)
    END             reduce using rule 16 (statute -> array .)


state 12

    (57) assign -> id . = expression ;

    =               shift and go to state 50


state 13

    (39) calling -> # . callID calling2 ;
    (42) callID -> . ID

    ID              shift and go to state 52

    callID                         shift and go to state 51

state 14

    (17) statute -> matrix .

    IF              reduce using rule 17 (statute -> matrix .)
    ECHO            reduce using rule 17 (statute -> matrix .)
    WHILE           reduce using rule 17 (statute -> matrix .)
    REPLAY          reduce using rule 17 (statute -> matrix .)
    SAMPLE          reduce using rule 17 (statute -> matrix .)
    #               reduce using rule 17 (statute -> matrix .)
    ARR             reduce using rule 17 (statute -> matrix .)
    MAT             reduce using rule 17 (statute -> matrix .)
    RETURN          reduce using rule 17 (statute -> matrix .)
    ID              reduce using rule 17 (statute -> matrix .)
    OVAL            reduce using rule 17 (statute -> matrix .)
    TRIO            reduce using rule 17 (statute -> matrix .)
    QUAD            reduce using rule 17 (statute -> matrix .)
    ARC             reduce using rule 17 (statute -> matrix .)
    }               reduce using rule 17 (statute -> matrix .)
    MOD             reduce using rule 17 (statute -> matrix .)
    END             reduce using rule 17 (statute -> matrix .)


state 15

    (11) statute -> write .

    IF              reduce using rule 11 (statute -> write .)
    ECHO            reduce using rule 11 (statute -> write .)
    WHILE           reduce using rule 11 (statute -> write .)
    REPLAY          reduce using rule 11 (statute -> write .)
    SAMPLE          reduce using rule 11 (statute -> write .)
    #               reduce using rule 11 (statute -> write .)
    ARR             reduce using rule 11 (statute -> write .)
    MAT             reduce using rule 11 (statute -> write .)
    RETURN          reduce using rule 11 (statute -> write .)
    ID              reduce using rule 11 (statute -> write .)
    OVAL            reduce using rule 11 (statute -> write .)
    TRIO            reduce using rule 11 (statute -> write .)
    QUAD            reduce using rule 11 (statute -> write .)
    ARC             reduce using rule 11 (statute -> write .)
    }               reduce using rule 11 (statute -> write .)
    MOD             reduce using rule 11 (statute -> write .)
    END             reduce using rule 11 (statute -> write .)


state 16

    (58) condition -> IF . ( expression ) gotoFalse block conditionA continueGo

    (               shift and go to state 53


state 17

    (98) figure -> TRIO .

    (               reduce using rule 98 (figure -> TRIO .)
    CTE_INTEGER     reduce using rule 98 (figure -> TRIO .)
    CTE_FLOAT       reduce using rule 98 (figure -> TRIO .)
    TRUE            reduce using rule 98 (figure -> TRIO .)
    FALSE           reduce using rule 98 (figure -> TRIO .)
    ID              reduce using rule 98 (figure -> TRIO .)


state 18

    (13) statute -> repeat .

    IF              reduce using rule 13 (statute -> repeat .)
    ECHO            reduce using rule 13 (statute -> repeat .)
    WHILE           reduce using rule 13 (statute -> repeat .)
    REPLAY          reduce using rule 13 (statute -> repeat .)
    SAMPLE          reduce using rule 13 (statute -> repeat .)
    #               reduce using rule 13 (statute -> repeat .)
    ARR             reduce using rule 13 (statute -> repeat .)
    MAT             reduce using rule 13 (statute -> repeat .)
    RETURN          reduce using rule 13 (statute -> repeat .)
    ID              reduce using rule 13 (statute -> repeat .)
    OVAL            reduce using rule 13 (statute -> repeat .)
    TRIO            reduce using rule 13 (statute -> repeat .)
    QUAD            reduce using rule 13 (statute -> repeat .)
    ARC             reduce using rule 13 (statute -> repeat .)
    }               reduce using rule 13 (statute -> repeat .)
    MOD             reduce using rule 13 (statute -> repeat .)
    END             reduce using rule 13 (statute -> repeat .)


state 19

    (3) programA -> END .

    $end            reduce using rule 3 (programA -> END .)


state 20

    (61) write -> ECHO . ( writeA writeB ) ;

    (               shift and go to state 54


state 21

    (72) command -> SAMPLE . commandA
    (73) commandA -> . ON move exp CTE_INTEGER color ;
    (74) commandA -> . OFF move exp ;

    ON              shift and go to state 57
    OFF             shift and go to state 56

    commandA                       shift and go to state 55

state 22

    (1) program -> INIT programA .

    $end            reduce using rule 1 (program -> INIT programA .)


state 23

    (2) programA -> programB . END

    END             shift and go to state 58


state 24

    (99) figure -> QUAD .

    (               reduce using rule 99 (figure -> QUAD .)
    CTE_INTEGER     reduce using rule 99 (figure -> QUAD .)
    CTE_FLOAT       reduce using rule 99 (figure -> QUAD .)
    TRUE            reduce using rule 99 (figure -> QUAD .)
    FALSE           reduce using rule 99 (figure -> QUAD .)
    ID              reduce using rule 99 (figure -> QUAD .)


state 25

    (34) id -> ID . [ sumdim exp ] [ sumdim exp ]
    (35) id -> ID . [ sumdim exp ]
    (37) id -> ID . empty
    (42) callID -> ID .
    (127) empty -> .

    [               shift and go to state 59
    #               reduce using rule 42 (callID -> ID .)
    =               reduce using rule 127 (empty -> .)
    ;               reduce using rule 127 (empty -> .)
    +               reduce using rule 127 (empty -> .)
    -               reduce using rule 127 (empty -> .)
    *               reduce using rule 127 (empty -> .)
    /               reduce using rule 127 (empty -> .)
    (               reduce using rule 127 (empty -> .)
    CTE_INTEGER     reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    TRUE            reduce using rule 127 (empty -> .)
    FALSE           reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    <               reduce using rule 127 (empty -> .)
    >               reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    RED             reduce using rule 127 (empty -> .)
    YELLOW          reduce using rule 127 (empty -> .)
    BLUE            reduce using rule 127 (empty -> .)
    GREEN           reduce using rule 127 (empty -> .)
    BLACK           reduce using rule 127 (empty -> .)
    WHITE           reduce using rule 127 (empty -> .)
    ORANGE          reduce using rule 127 (empty -> .)
    PURPLE          reduce using rule 127 (empty -> .)
    CYAN            reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)
    ]               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 60

state 26

    (10) statute -> condition .

    IF              reduce using rule 10 (statute -> condition .)
    ECHO            reduce using rule 10 (statute -> condition .)
    WHILE           reduce using rule 10 (statute -> condition .)
    REPLAY          reduce using rule 10 (statute -> condition .)
    SAMPLE          reduce using rule 10 (statute -> condition .)
    #               reduce using rule 10 (statute -> condition .)
    ARR             reduce using rule 10 (statute -> condition .)
    MAT             reduce using rule 10 (statute -> condition .)
    RETURN          reduce using rule 10 (statute -> condition .)
    ID              reduce using rule 10 (statute -> condition .)
    OVAL            reduce using rule 10 (statute -> condition .)
    TRIO            reduce using rule 10 (statute -> condition .)
    QUAD            reduce using rule 10 (statute -> condition .)
    ARC             reduce using rule 10 (statute -> condition .)
    }               reduce using rule 10 (statute -> condition .)
    MOD             reduce using rule 10 (statute -> condition .)
    END             reduce using rule 10 (statute -> condition .)


state 27

    (12) statute -> cycle .

    IF              reduce using rule 12 (statute -> cycle .)
    ECHO            reduce using rule 12 (statute -> cycle .)
    WHILE           reduce using rule 12 (statute -> cycle .)
    REPLAY          reduce using rule 12 (statute -> cycle .)
    SAMPLE          reduce using rule 12 (statute -> cycle .)
    #               reduce using rule 12 (statute -> cycle .)
    ARR             reduce using rule 12 (statute -> cycle .)
    MAT             reduce using rule 12 (statute -> cycle .)
    RETURN          reduce using rule 12 (statute -> cycle .)
    ID              reduce using rule 12 (statute -> cycle .)
    OVAL            reduce using rule 12 (statute -> cycle .)
    TRIO            reduce using rule 12 (statute -> cycle .)
    QUAD            reduce using rule 12 (statute -> cycle .)
    ARC             reduce using rule 12 (statute -> cycle .)
    }               reduce using rule 12 (statute -> cycle .)
    MOD             reduce using rule 12 (statute -> cycle .)
    END             reduce using rule 12 (statute -> cycle .)


state 28

    (7) workspace -> statute .

    MOD             reduce using rule 7 (workspace -> statute .)
    IF              reduce using rule 7 (workspace -> statute .)
    ECHO            reduce using rule 7 (workspace -> statute .)
    WHILE           reduce using rule 7 (workspace -> statute .)
    REPLAY          reduce using rule 7 (workspace -> statute .)
    SAMPLE          reduce using rule 7 (workspace -> statute .)
    #               reduce using rule 7 (workspace -> statute .)
    ARR             reduce using rule 7 (workspace -> statute .)
    MAT             reduce using rule 7 (workspace -> statute .)
    RETURN          reduce using rule 7 (workspace -> statute .)
    ID              reduce using rule 7 (workspace -> statute .)
    OVAL            reduce using rule 7 (workspace -> statute .)
    TRIO            reduce using rule 7 (workspace -> statute .)
    QUAD            reduce using rule 7 (workspace -> statute .)
    ARC             reduce using rule 7 (workspace -> statute .)
    END             reduce using rule 7 (workspace -> statute .)


state 29

    (66) array -> ARR . typeDim ID [ CTE_INTEGER ] ;
    (68) typeDim -> . INT
    (69) typeDim -> . FLOAT
    (70) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 63

state 30

    (67) matrix -> MAT . typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (68) typeDim -> . INT
    (69) typeDim -> . FLOAT
    (70) typeDim -> . BOOL

    INT             shift and go to state 61
    FLOAT           shift and go to state 62
    BOOL            shift and go to state 64

    typeDim                        shift and go to state 65

state 31

    (15) statute -> calling .

    IF              reduce using rule 15 (statute -> calling .)
    ECHO            reduce using rule 15 (statute -> calling .)
    WHILE           reduce using rule 15 (statute -> calling .)
    REPLAY          reduce using rule 15 (statute -> calling .)
    SAMPLE          reduce using rule 15 (statute -> calling .)
    #               reduce using rule 15 (statute -> calling .)
    ARR             reduce using rule 15 (statute -> calling .)
    MAT             reduce using rule 15 (statute -> calling .)
    RETURN          reduce using rule 15 (statute -> calling .)
    ID              reduce using rule 15 (statute -> calling .)
    OVAL            reduce using rule 15 (statute -> calling .)
    TRIO            reduce using rule 15 (statute -> calling .)
    QUAD            reduce using rule 15 (statute -> calling .)
    ARC             reduce using rule 15 (statute -> calling .)
    }               reduce using rule 15 (statute -> calling .)
    MOD             reduce using rule 15 (statute -> calling .)
    END             reduce using rule 15 (statute -> calling .)


state 32

    (100) figure -> ARC .

    (               reduce using rule 100 (figure -> ARC .)
    CTE_INTEGER     reduce using rule 100 (figure -> ARC .)
    CTE_FLOAT       reduce using rule 100 (figure -> ARC .)
    TRUE            reduce using rule 100 (figure -> ARC .)
    FALSE           reduce using rule 100 (figure -> ARC .)
    ID              reduce using rule 100 (figure -> ARC .)


state 33

    (14) statute -> command .

    IF              reduce using rule 14 (statute -> command .)
    ECHO            reduce using rule 14 (statute -> command .)
    WHILE           reduce using rule 14 (statute -> command .)
    REPLAY          reduce using rule 14 (statute -> command .)
    SAMPLE          reduce using rule 14 (statute -> command .)
    #               reduce using rule 14 (statute -> command .)
    ARR             reduce using rule 14 (statute -> command .)
    MAT             reduce using rule 14 (statute -> command .)
    RETURN          reduce using rule 14 (statute -> command .)
    ID              reduce using rule 14 (statute -> command .)
    OVAL            reduce using rule 14 (statute -> command .)
    TRIO            reduce using rule 14 (statute -> command .)
    QUAD            reduce using rule 14 (statute -> command .)
    ARC             reduce using rule 14 (statute -> command .)
    }               reduce using rule 14 (statute -> command .)
    MOD             reduce using rule 14 (statute -> command .)
    END             reduce using rule 14 (statute -> command .)


state 34

    (4) programB -> workspace . programC
    (5) programC -> . programB
    (6) programC -> . empty
    (4) programB -> . workspace programC
    (127) empty -> .
    (7) workspace -> . statute
    (8) workspace -> . module
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . return
    (24) module -> . MOD typeMod # moduleID addMod insertQuadMod moduleA endMod
    (57) assign -> . id = expression ;
    (58) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (61) write -> . ECHO ( writeA writeB ) ;
    (75) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (76) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (71) command -> . figure exp exp color ;
    (72) command -> . SAMPLE commandA
    (39) calling -> . # callID calling2 ;
    (66) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (67) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (94) return -> . RETURN exp ;
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (97) figure -> . OVAL
    (98) figure -> . TRIO
    (99) figure -> . QUAD
    (100) figure -> . ARC
    (42) callID -> . ID

    END             reduce using rule 127 (empty -> .)
    MOD             shift and go to state 35
    IF              shift and go to state 16
    ECHO            shift and go to state 20
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 21
    #               shift and go to state 13
    ARR             shift and go to state 29
    MAT             shift and go to state 30
    RETURN          shift and go to state 3
    ID              shift and go to state 25
    OVAL            shift and go to state 7
    TRIO            shift and go to state 17
    QUAD            shift and go to state 24
    ARC             shift and go to state 32

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    module                         shift and go to state 6
    array                          shift and go to state 11
    id                             shift and go to state 12
    matrix                         shift and go to state 14
    write                          shift and go to state 15
    condition                      shift and go to state 26
    empty                          shift and go to state 66
    repeat                         shift and go to state 18
    return                         shift and go to state 10
    programB                       shift and go to state 67
    programC                       shift and go to state 68
    cycle                          shift and go to state 27
    statute                        shift and go to state 28
    calling                        shift and go to state 31
    command                        shift and go to state 33
    workspace                      shift and go to state 34
    assign                         shift and go to state 36

state 35

    (24) module -> MOD . typeMod # moduleID addMod insertQuadMod moduleA endMod
    (19) typeMod -> . INT
    (20) typeMod -> . FLOAT
    (21) typeMod -> . BOOL
    (22) typeMod -> . empty
    (127) empty -> .

    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    BOOL            shift and go to state 72
    #               reduce using rule 127 (empty -> .)

    typeMod                        shift and go to state 69
    empty                          shift and go to state 73

state 36

    (9) statute -> assign .

    IF              reduce using rule 9 (statute -> assign .)
    ECHO            reduce using rule 9 (statute -> assign .)
    WHILE           reduce using rule 9 (statute -> assign .)
    REPLAY          reduce using rule 9 (statute -> assign .)
    SAMPLE          reduce using rule 9 (statute -> assign .)
    #               reduce using rule 9 (statute -> assign .)
    ARR             reduce using rule 9 (statute -> assign .)
    MAT             reduce using rule 9 (statute -> assign .)
    RETURN          reduce using rule 9 (statute -> assign .)
    ID              reduce using rule 9 (statute -> assign .)
    OVAL            reduce using rule 9 (statute -> assign .)
    TRIO            reduce using rule 9 (statute -> assign .)
    QUAD            reduce using rule 9 (statute -> assign .)
    ARC             reduce using rule 9 (statute -> assign .)
    }               reduce using rule 9 (statute -> assign .)
    MOD             reduce using rule 9 (statute -> assign .)
    END             reduce using rule 9 (statute -> assign .)


state 37

    (96) factor -> var_cte .

    +               reduce using rule 96 (factor -> var_cte .)
    -               reduce using rule 96 (factor -> var_cte .)
    *               reduce using rule 96 (factor -> var_cte .)
    /               reduce using rule 96 (factor -> var_cte .)
    (               reduce using rule 96 (factor -> var_cte .)
    CTE_INTEGER     reduce using rule 96 (factor -> var_cte .)
    CTE_FLOAT       reduce using rule 96 (factor -> var_cte .)
    TRUE            reduce using rule 96 (factor -> var_cte .)
    FALSE           reduce using rule 96 (factor -> var_cte .)
    ID              reduce using rule 96 (factor -> var_cte .)
    )               reduce using rule 96 (factor -> var_cte .)
    ;               reduce using rule 96 (factor -> var_cte .)
    ,               reduce using rule 96 (factor -> var_cte .)
    =               reduce using rule 96 (factor -> var_cte .)
    <               reduce using rule 96 (factor -> var_cte .)
    >               reduce using rule 96 (factor -> var_cte .)
    AND             reduce using rule 96 (factor -> var_cte .)
    OR              reduce using rule 96 (factor -> var_cte .)
    RED             reduce using rule 96 (factor -> var_cte .)
    YELLOW          reduce using rule 96 (factor -> var_cte .)
    BLUE            reduce using rule 96 (factor -> var_cte .)
    GREEN           reduce using rule 96 (factor -> var_cte .)
    BLACK           reduce using rule 96 (factor -> var_cte .)
    WHITE           reduce using rule 96 (factor -> var_cte .)
    ORANGE          reduce using rule 96 (factor -> var_cte .)
    PURPLE          reduce using rule 96 (factor -> var_cte .)
    CYAN            reduce using rule 96 (factor -> var_cte .)
    ]               reduce using rule 96 (factor -> var_cte .)


state 38

    (117) var_cte -> TRUE .

    =               reduce using rule 117 (var_cte -> TRUE .)
    <               reduce using rule 117 (var_cte -> TRUE .)
    >               reduce using rule 117 (var_cte -> TRUE .)
    AND             reduce using rule 117 (var_cte -> TRUE .)
    OR              reduce using rule 117 (var_cte -> TRUE .)
    +               reduce using rule 117 (var_cte -> TRUE .)
    -               reduce using rule 117 (var_cte -> TRUE .)
    *               reduce using rule 117 (var_cte -> TRUE .)
    /               reduce using rule 117 (var_cte -> TRUE .)
    )               reduce using rule 117 (var_cte -> TRUE .)
    ;               reduce using rule 117 (var_cte -> TRUE .)
    ,               reduce using rule 117 (var_cte -> TRUE .)
    (               reduce using rule 117 (var_cte -> TRUE .)
    CTE_INTEGER     reduce using rule 117 (var_cte -> TRUE .)
    CTE_FLOAT       reduce using rule 117 (var_cte -> TRUE .)
    TRUE            reduce using rule 117 (var_cte -> TRUE .)
    FALSE           reduce using rule 117 (var_cte -> TRUE .)
    ID              reduce using rule 117 (var_cte -> TRUE .)
    RED             reduce using rule 117 (var_cte -> TRUE .)
    YELLOW          reduce using rule 117 (var_cte -> TRUE .)
    BLUE            reduce using rule 117 (var_cte -> TRUE .)
    GREEN           reduce using rule 117 (var_cte -> TRUE .)
    BLACK           reduce using rule 117 (var_cte -> TRUE .)
    WHITE           reduce using rule 117 (var_cte -> TRUE .)
    ORANGE          reduce using rule 117 (var_cte -> TRUE .)
    PURPLE          reduce using rule 117 (var_cte -> TRUE .)
    CYAN            reduce using rule 117 (var_cte -> TRUE .)
    ]               reduce using rule 117 (var_cte -> TRUE .)


state 39

    (114) var_cte -> id .

    =               reduce using rule 114 (var_cte -> id .)
    <               reduce using rule 114 (var_cte -> id .)
    >               reduce using rule 114 (var_cte -> id .)
    AND             reduce using rule 114 (var_cte -> id .)
    OR              reduce using rule 114 (var_cte -> id .)
    +               reduce using rule 114 (var_cte -> id .)
    -               reduce using rule 114 (var_cte -> id .)
    *               reduce using rule 114 (var_cte -> id .)
    /               reduce using rule 114 (var_cte -> id .)
    )               reduce using rule 114 (var_cte -> id .)
    ;               reduce using rule 114 (var_cte -> id .)
    ,               reduce using rule 114 (var_cte -> id .)
    (               reduce using rule 114 (var_cte -> id .)
    CTE_INTEGER     reduce using rule 114 (var_cte -> id .)
    CTE_FLOAT       reduce using rule 114 (var_cte -> id .)
    TRUE            reduce using rule 114 (var_cte -> id .)
    FALSE           reduce using rule 114 (var_cte -> id .)
    ID              reduce using rule 114 (var_cte -> id .)
    RED             reduce using rule 114 (var_cte -> id .)
    YELLOW          reduce using rule 114 (var_cte -> id .)
    BLUE            reduce using rule 114 (var_cte -> id .)
    GREEN           reduce using rule 114 (var_cte -> id .)
    BLACK           reduce using rule 114 (var_cte -> id .)
    WHITE           reduce using rule 114 (var_cte -> id .)
    ORANGE          reduce using rule 114 (var_cte -> id .)
    PURPLE          reduce using rule 114 (var_cte -> id .)
    CYAN            reduce using rule 114 (var_cte -> id .)
    ]               reduce using rule 114 (var_cte -> id .)


state 40

    (95) factor -> ( . expression )
    (80) expression -> . exp = = exp
    (81) expression -> . exp < > exp
    (82) expression -> . exp < = exp
    (83) expression -> . exp > = exp
    (84) expression -> . exp > exp
    (85) expression -> . exp < exp
    (86) expression -> . exp AND exp
    (87) expression -> . exp OR exp
    (88) expression -> . exp empty
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 74
    factor                         shift and go to state 41
    expression                     shift and go to state 75
    id                             shift and go to state 39

state 41

    (93) exp -> factor . empty
    (127) empty -> .

    ;               reduce using rule 127 (empty -> .)
    +               reduce using rule 127 (empty -> .)
    -               reduce using rule 127 (empty -> .)
    *               reduce using rule 127 (empty -> .)
    /               reduce using rule 127 (empty -> .)
    (               reduce using rule 127 (empty -> .)
    CTE_INTEGER     reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    TRUE            reduce using rule 127 (empty -> .)
    FALSE           reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    =               reduce using rule 127 (empty -> .)
    <               reduce using rule 127 (empty -> .)
    >               reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    RED             reduce using rule 127 (empty -> .)
    YELLOW          reduce using rule 127 (empty -> .)
    BLUE            reduce using rule 127 (empty -> .)
    GREEN           reduce using rule 127 (empty -> .)
    BLACK           reduce using rule 127 (empty -> .)
    WHITE           reduce using rule 127 (empty -> .)
    ORANGE          reduce using rule 127 (empty -> .)
    PURPLE          reduce using rule 127 (empty -> .)
    CYAN            reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)
    ]               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 76

state 42

    (115) var_cte -> CTE_INTEGER .

    =               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    <               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    >               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    AND             reduce using rule 115 (var_cte -> CTE_INTEGER .)
    OR              reduce using rule 115 (var_cte -> CTE_INTEGER .)
    +               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    -               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    *               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    /               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    )               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ;               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ,               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    (               reduce using rule 115 (var_cte -> CTE_INTEGER .)
    CTE_INTEGER     reduce using rule 115 (var_cte -> CTE_INTEGER .)
    CTE_FLOAT       reduce using rule 115 (var_cte -> CTE_INTEGER .)
    TRUE            reduce using rule 115 (var_cte -> CTE_INTEGER .)
    FALSE           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ID              reduce using rule 115 (var_cte -> CTE_INTEGER .)
    RED             reduce using rule 115 (var_cte -> CTE_INTEGER .)
    YELLOW          reduce using rule 115 (var_cte -> CTE_INTEGER .)
    BLUE            reduce using rule 115 (var_cte -> CTE_INTEGER .)
    GREEN           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    BLACK           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    WHITE           reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ORANGE          reduce using rule 115 (var_cte -> CTE_INTEGER .)
    PURPLE          reduce using rule 115 (var_cte -> CTE_INTEGER .)
    CYAN            reduce using rule 115 (var_cte -> CTE_INTEGER .)
    ]               reduce using rule 115 (var_cte -> CTE_INTEGER .)


state 43

    (118) var_cte -> FALSE .

    =               reduce using rule 118 (var_cte -> FALSE .)
    <               reduce using rule 118 (var_cte -> FALSE .)
    >               reduce using rule 118 (var_cte -> FALSE .)
    AND             reduce using rule 118 (var_cte -> FALSE .)
    OR              reduce using rule 118 (var_cte -> FALSE .)
    +               reduce using rule 118 (var_cte -> FALSE .)
    -               reduce using rule 118 (var_cte -> FALSE .)
    *               reduce using rule 118 (var_cte -> FALSE .)
    /               reduce using rule 118 (var_cte -> FALSE .)
    )               reduce using rule 118 (var_cte -> FALSE .)
    ;               reduce using rule 118 (var_cte -> FALSE .)
    ,               reduce using rule 118 (var_cte -> FALSE .)
    (               reduce using rule 118 (var_cte -> FALSE .)
    CTE_INTEGER     reduce using rule 118 (var_cte -> FALSE .)
    CTE_FLOAT       reduce using rule 118 (var_cte -> FALSE .)
    TRUE            reduce using rule 118 (var_cte -> FALSE .)
    FALSE           reduce using rule 118 (var_cte -> FALSE .)
    ID              reduce using rule 118 (var_cte -> FALSE .)
    RED             reduce using rule 118 (var_cte -> FALSE .)
    YELLOW          reduce using rule 118 (var_cte -> FALSE .)
    BLUE            reduce using rule 118 (var_cte -> FALSE .)
    GREEN           reduce using rule 118 (var_cte -> FALSE .)
    BLACK           reduce using rule 118 (var_cte -> FALSE .)
    WHITE           reduce using rule 118 (var_cte -> FALSE .)
    ORANGE          reduce using rule 118 (var_cte -> FALSE .)
    PURPLE          reduce using rule 118 (var_cte -> FALSE .)
    CYAN            reduce using rule 118 (var_cte -> FALSE .)
    ]               reduce using rule 118 (var_cte -> FALSE .)


state 44

    (116) var_cte -> CTE_FLOAT .

    =               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    <               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    >               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    AND             reduce using rule 116 (var_cte -> CTE_FLOAT .)
    OR              reduce using rule 116 (var_cte -> CTE_FLOAT .)
    +               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    -               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    *               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    /               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    )               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ;               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ,               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    (               reduce using rule 116 (var_cte -> CTE_FLOAT .)
    CTE_INTEGER     reduce using rule 116 (var_cte -> CTE_FLOAT .)
    CTE_FLOAT       reduce using rule 116 (var_cte -> CTE_FLOAT .)
    TRUE            reduce using rule 116 (var_cte -> CTE_FLOAT .)
    FALSE           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ID              reduce using rule 116 (var_cte -> CTE_FLOAT .)
    RED             reduce using rule 116 (var_cte -> CTE_FLOAT .)
    YELLOW          reduce using rule 116 (var_cte -> CTE_FLOAT .)
    BLUE            reduce using rule 116 (var_cte -> CTE_FLOAT .)
    GREEN           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    BLACK           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    WHITE           reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ORANGE          reduce using rule 116 (var_cte -> CTE_FLOAT .)
    PURPLE          reduce using rule 116 (var_cte -> CTE_FLOAT .)
    CYAN            reduce using rule 116 (var_cte -> CTE_FLOAT .)
    ]               reduce using rule 116 (var_cte -> CTE_FLOAT .)


state 45

    (94) return -> RETURN exp . ;
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    ;               shift and go to state 81
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 46

    (71) command -> figure exp . exp color ;
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 82
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 47

    (36) id -> callID # . calling2
    (40) calling2 -> . ( maincalling )

    (               shift and go to state 84

    calling2                       shift and go to state 83

state 48

    (75) cycle -> WHILE gotoW . ( expression ) gotoFalse block continueGoW

    (               shift and go to state 85


state 49

    (76) repeat -> REPLAY CTE_INTEGER . gotoR [ repeatA ] ;
    (122) gotoR -> .

    [               reduce using rule 122 (gotoR -> .)

    gotoR                          shift and go to state 86

state 50

    (57) assign -> id = . expression ;
    (80) expression -> . exp = = exp
    (81) expression -> . exp < > exp
    (82) expression -> . exp < = exp
    (83) expression -> . exp > = exp
    (84) expression -> . exp > exp
    (85) expression -> . exp < exp
    (86) expression -> . exp AND exp
    (87) expression -> . exp OR exp
    (88) expression -> . exp empty
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 74
    factor                         shift and go to state 41
    expression                     shift and go to state 87
    id                             shift and go to state 39

state 51

    (39) calling -> # callID . calling2 ;
    (40) calling2 -> . ( maincalling )

    (               shift and go to state 84

    calling2                       shift and go to state 88

state 52

    (42) callID -> ID .

    (               reduce using rule 42 (callID -> ID .)


state 53

    (58) condition -> IF ( . expression ) gotoFalse block conditionA continueGo
    (80) expression -> . exp = = exp
    (81) expression -> . exp < > exp
    (82) expression -> . exp < = exp
    (83) expression -> . exp > = exp
    (84) expression -> . exp > exp
    (85) expression -> . exp < exp
    (86) expression -> . exp AND exp
    (87) expression -> . exp OR exp
    (88) expression -> . exp empty
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    exp                            shift and go to state 74
    factor                         shift and go to state 41
    var_cte                        shift and go to state 37
    expression                     shift and go to state 89
    id                             shift and go to state 39

state 54

    (61) write -> ECHO ( . writeA writeB ) ;
    (62) writeA -> . expression
    (63) writeA -> . CTE_STRING
    (80) expression -> . exp = = exp
    (81) expression -> . exp < > exp
    (82) expression -> . exp < = exp
    (83) expression -> . exp > = exp
    (84) expression -> . exp > exp
    (85) expression -> . exp < exp
    (86) expression -> . exp AND exp
    (87) expression -> . exp OR exp
    (88) expression -> . exp empty
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    CTE_STRING      shift and go to state 91
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 74
    factor                         shift and go to state 41
    writeA                         shift and go to state 90
    expression                     shift and go to state 92
    id                             shift and go to state 39

state 55

    (72) command -> SAMPLE commandA .

    IF              reduce using rule 72 (command -> SAMPLE commandA .)
    ECHO            reduce using rule 72 (command -> SAMPLE commandA .)
    WHILE           reduce using rule 72 (command -> SAMPLE commandA .)
    REPLAY          reduce using rule 72 (command -> SAMPLE commandA .)
    SAMPLE          reduce using rule 72 (command -> SAMPLE commandA .)
    #               reduce using rule 72 (command -> SAMPLE commandA .)
    ARR             reduce using rule 72 (command -> SAMPLE commandA .)
    MAT             reduce using rule 72 (command -> SAMPLE commandA .)
    RETURN          reduce using rule 72 (command -> SAMPLE commandA .)
    ID              reduce using rule 72 (command -> SAMPLE commandA .)
    OVAL            reduce using rule 72 (command -> SAMPLE commandA .)
    TRIO            reduce using rule 72 (command -> SAMPLE commandA .)
    QUAD            reduce using rule 72 (command -> SAMPLE commandA .)
    ARC             reduce using rule 72 (command -> SAMPLE commandA .)
    }               reduce using rule 72 (command -> SAMPLE commandA .)
    ]               reduce using rule 72 (command -> SAMPLE commandA .)
    MOD             reduce using rule 72 (command -> SAMPLE commandA .)
    END             reduce using rule 72 (command -> SAMPLE commandA .)


state 56

    (74) commandA -> OFF . move exp ;
    (101) move -> . UP
    (102) move -> . DOWN
    (103) move -> . LEFT
    (104) move -> . RIGHT

    UP              shift and go to state 95
    DOWN            shift and go to state 96
    LEFT            shift and go to state 97
    RIGHT           shift and go to state 93

    move                           shift and go to state 94

state 57

    (73) commandA -> ON . move exp CTE_INTEGER color ;
    (101) move -> . UP
    (102) move -> . DOWN
    (103) move -> . LEFT
    (104) move -> . RIGHT

    UP              shift and go to state 95
    DOWN            shift and go to state 96
    LEFT            shift and go to state 97
    RIGHT           shift and go to state 93

    move                           shift and go to state 98

state 58

    (2) programA -> programB END .

    $end            reduce using rule 2 (programA -> programB END .)


state 59

    (34) id -> ID [ . sumdim exp ] [ sumdim exp ]
    (35) id -> ID [ . sumdim exp ]
    (38) sumdim -> .

    (               reduce using rule 38 (sumdim -> .)
    CTE_INTEGER     reduce using rule 38 (sumdim -> .)
    CTE_FLOAT       reduce using rule 38 (sumdim -> .)
    TRUE            reduce using rule 38 (sumdim -> .)
    FALSE           reduce using rule 38 (sumdim -> .)
    ID              reduce using rule 38 (sumdim -> .)

    sumdim                         shift and go to state 99

state 60

    (37) id -> ID empty .

    =               reduce using rule 37 (id -> ID empty .)
    <               reduce using rule 37 (id -> ID empty .)
    >               reduce using rule 37 (id -> ID empty .)
    AND             reduce using rule 37 (id -> ID empty .)
    OR              reduce using rule 37 (id -> ID empty .)
    +               reduce using rule 37 (id -> ID empty .)
    -               reduce using rule 37 (id -> ID empty .)
    *               reduce using rule 37 (id -> ID empty .)
    /               reduce using rule 37 (id -> ID empty .)
    )               reduce using rule 37 (id -> ID empty .)
    ;               reduce using rule 37 (id -> ID empty .)
    ,               reduce using rule 37 (id -> ID empty .)
    (               reduce using rule 37 (id -> ID empty .)
    CTE_INTEGER     reduce using rule 37 (id -> ID empty .)
    CTE_FLOAT       reduce using rule 37 (id -> ID empty .)
    TRUE            reduce using rule 37 (id -> ID empty .)
    FALSE           reduce using rule 37 (id -> ID empty .)
    ID              reduce using rule 37 (id -> ID empty .)
    RED             reduce using rule 37 (id -> ID empty .)
    YELLOW          reduce using rule 37 (id -> ID empty .)
    BLUE            reduce using rule 37 (id -> ID empty .)
    GREEN           reduce using rule 37 (id -> ID empty .)
    BLACK           reduce using rule 37 (id -> ID empty .)
    WHITE           reduce using rule 37 (id -> ID empty .)
    ORANGE          reduce using rule 37 (id -> ID empty .)
    PURPLE          reduce using rule 37 (id -> ID empty .)
    CYAN            reduce using rule 37 (id -> ID empty .)
    ]               reduce using rule 37 (id -> ID empty .)


state 61

    (68) typeDim -> INT .

    ID              reduce using rule 68 (typeDim -> INT .)


state 62

    (69) typeDim -> FLOAT .

    ID              reduce using rule 69 (typeDim -> FLOAT .)


state 63

    (66) array -> ARR typeDim . ID [ CTE_INTEGER ] ;

    ID              shift and go to state 100


state 64

    (70) typeDim -> BOOL .

    ID              reduce using rule 70 (typeDim -> BOOL .)


state 65

    (67) matrix -> MAT typeDim . ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    ID              shift and go to state 101


state 66

    (6) programC -> empty .

    END             reduce using rule 6 (programC -> empty .)


state 67

    (5) programC -> programB .

    END             reduce using rule 5 (programC -> programB .)


state 68

    (4) programB -> workspace programC .

    END             reduce using rule 4 (programB -> workspace programC .)


state 69

    (24) module -> MOD typeMod . # moduleID addMod insertQuadMod moduleA endMod

    #               shift and go to state 102


state 70

    (19) typeMod -> INT .

    #               reduce using rule 19 (typeMod -> INT .)


state 71

    (20) typeMod -> FLOAT .

    #               reduce using rule 20 (typeMod -> FLOAT .)


state 72

    (21) typeMod -> BOOL .

    #               reduce using rule 21 (typeMod -> BOOL .)


state 73

    (22) typeMod -> empty .

    #               reduce using rule 22 (typeMod -> empty .)


state 74

    (80) expression -> exp . = = exp
    (81) expression -> exp . < > exp
    (82) expression -> exp . < = exp
    (83) expression -> exp . > = exp
    (84) expression -> exp . > exp
    (85) expression -> exp . < exp
    (86) expression -> exp . AND exp
    (87) expression -> exp . OR exp
    (88) expression -> exp . empty
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp
    (127) empty -> .

    =               shift and go to state 105
    <               shift and go to state 104
    >               shift and go to state 108
    AND             shift and go to state 103
    OR              shift and go to state 106
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80
    )               reduce using rule 127 (empty -> .)
    ;               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 107

state 75

    (95) factor -> ( expression . )

    )               shift and go to state 109


state 76

    (93) exp -> factor empty .

    =               reduce using rule 93 (exp -> factor empty .)
    <               reduce using rule 93 (exp -> factor empty .)
    >               reduce using rule 93 (exp -> factor empty .)
    AND             reduce using rule 93 (exp -> factor empty .)
    OR              reduce using rule 93 (exp -> factor empty .)
    +               reduce using rule 93 (exp -> factor empty .)
    -               reduce using rule 93 (exp -> factor empty .)
    *               reduce using rule 93 (exp -> factor empty .)
    /               reduce using rule 93 (exp -> factor empty .)
    ;               reduce using rule 93 (exp -> factor empty .)
    )               reduce using rule 93 (exp -> factor empty .)
    ,               reduce using rule 93 (exp -> factor empty .)
    (               reduce using rule 93 (exp -> factor empty .)
    CTE_INTEGER     reduce using rule 93 (exp -> factor empty .)
    CTE_FLOAT       reduce using rule 93 (exp -> factor empty .)
    TRUE            reduce using rule 93 (exp -> factor empty .)
    FALSE           reduce using rule 93 (exp -> factor empty .)
    ID              reduce using rule 93 (exp -> factor empty .)
    RED             reduce using rule 93 (exp -> factor empty .)
    YELLOW          reduce using rule 93 (exp -> factor empty .)
    BLUE            reduce using rule 93 (exp -> factor empty .)
    GREEN           reduce using rule 93 (exp -> factor empty .)
    BLACK           reduce using rule 93 (exp -> factor empty .)
    WHITE           reduce using rule 93 (exp -> factor empty .)
    ORANGE          reduce using rule 93 (exp -> factor empty .)
    PURPLE          reduce using rule 93 (exp -> factor empty .)
    CYAN            reduce using rule 93 (exp -> factor empty .)
    ]               reduce using rule 93 (exp -> factor empty .)


state 77

    (89) exp -> exp + . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 110
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 78

    (91) exp -> exp * . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 111
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 79

    (90) exp -> exp - . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 112
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 80

    (92) exp -> exp / . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 113
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 81

    (94) return -> RETURN exp ; .

    MOD             reduce using rule 94 (return -> RETURN exp ; .)
    IF              reduce using rule 94 (return -> RETURN exp ; .)
    ECHO            reduce using rule 94 (return -> RETURN exp ; .)
    WHILE           reduce using rule 94 (return -> RETURN exp ; .)
    REPLAY          reduce using rule 94 (return -> RETURN exp ; .)
    SAMPLE          reduce using rule 94 (return -> RETURN exp ; .)
    #               reduce using rule 94 (return -> RETURN exp ; .)
    ARR             reduce using rule 94 (return -> RETURN exp ; .)
    MAT             reduce using rule 94 (return -> RETURN exp ; .)
    RETURN          reduce using rule 94 (return -> RETURN exp ; .)
    ID              reduce using rule 94 (return -> RETURN exp ; .)
    OVAL            reduce using rule 94 (return -> RETURN exp ; .)
    TRIO            reduce using rule 94 (return -> RETURN exp ; .)
    QUAD            reduce using rule 94 (return -> RETURN exp ; .)
    ARC             reduce using rule 94 (return -> RETURN exp ; .)
    END             reduce using rule 94 (return -> RETURN exp ; .)
    }               reduce using rule 94 (return -> RETURN exp ; .)


state 82

    (71) command -> figure exp exp . color ;
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp
    (105) color -> . RED
    (106) color -> . YELLOW
    (107) color -> . BLUE
    (108) color -> . GREEN
    (109) color -> . BLACK
    (110) color -> . WHITE
    (111) color -> . ORANGE
    (112) color -> . PURPLE
    (113) color -> . CYAN

    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80
    RED             shift and go to state 123
    YELLOW          shift and go to state 118
    BLUE            shift and go to state 114
    GREEN           shift and go to state 117
    BLACK           shift and go to state 121
    WHITE           shift and go to state 122
    ORANGE          shift and go to state 120
    PURPLE          shift and go to state 116
    CYAN            shift and go to state 119

    color                          shift and go to state 115

state 83

    (36) id -> callID # calling2 .

    =               reduce using rule 36 (id -> callID # calling2 .)
    <               reduce using rule 36 (id -> callID # calling2 .)
    >               reduce using rule 36 (id -> callID # calling2 .)
    AND             reduce using rule 36 (id -> callID # calling2 .)
    OR              reduce using rule 36 (id -> callID # calling2 .)
    +               reduce using rule 36 (id -> callID # calling2 .)
    -               reduce using rule 36 (id -> callID # calling2 .)
    *               reduce using rule 36 (id -> callID # calling2 .)
    /               reduce using rule 36 (id -> callID # calling2 .)
    )               reduce using rule 36 (id -> callID # calling2 .)
    ;               reduce using rule 36 (id -> callID # calling2 .)
    ,               reduce using rule 36 (id -> callID # calling2 .)
    (               reduce using rule 36 (id -> callID # calling2 .)
    CTE_INTEGER     reduce using rule 36 (id -> callID # calling2 .)
    CTE_FLOAT       reduce using rule 36 (id -> callID # calling2 .)
    TRUE            reduce using rule 36 (id -> callID # calling2 .)
    FALSE           reduce using rule 36 (id -> callID # calling2 .)
    ID              reduce using rule 36 (id -> callID # calling2 .)
    RED             reduce using rule 36 (id -> callID # calling2 .)
    YELLOW          reduce using rule 36 (id -> callID # calling2 .)
    BLUE            reduce using rule 36 (id -> callID # calling2 .)
    GREEN           reduce using rule 36 (id -> callID # calling2 .)
    BLACK           reduce using rule 36 (id -> callID # calling2 .)
    WHITE           reduce using rule 36 (id -> callID # calling2 .)
    ORANGE          reduce using rule 36 (id -> callID # calling2 .)
    PURPLE          reduce using rule 36 (id -> callID # calling2 .)
    CYAN            reduce using rule 36 (id -> callID # calling2 .)
    ]               reduce using rule 36 (id -> callID # calling2 .)


state 84

    (40) calling2 -> ( . maincalling )
    (41) maincalling -> . insertEra callingA
    (43) insertEra -> .

    (               reduce using rule 43 (insertEra -> .)
    CTE_INTEGER     reduce using rule 43 (insertEra -> .)
    CTE_FLOAT       reduce using rule 43 (insertEra -> .)
    TRUE            reduce using rule 43 (insertEra -> .)
    FALSE           reduce using rule 43 (insertEra -> .)
    ID              reduce using rule 43 (insertEra -> .)
    )               reduce using rule 43 (insertEra -> .)

    insertEra                      shift and go to state 124
    maincalling                    shift and go to state 125

state 85

    (75) cycle -> WHILE gotoW ( . expression ) gotoFalse block continueGoW
    (80) expression -> . exp = = exp
    (81) expression -> . exp < > exp
    (82) expression -> . exp < = exp
    (83) expression -> . exp > = exp
    (84) expression -> . exp > exp
    (85) expression -> . exp < exp
    (86) expression -> . exp AND exp
    (87) expression -> . exp OR exp
    (88) expression -> . exp empty
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 74
    factor                         shift and go to state 41
    expression                     shift and go to state 126
    id                             shift and go to state 39

state 86

    (76) repeat -> REPLAY CTE_INTEGER gotoR . [ repeatA ] ;

    [               shift and go to state 127


state 87

    (57) assign -> id = expression . ;

    ;               shift and go to state 128


state 88

    (39) calling -> # callID calling2 . ;

    ;               shift and go to state 129


state 89

    (58) condition -> IF ( expression . ) gotoFalse block conditionA continueGo

    )               shift and go to state 130


state 90

    (61) write -> ECHO ( writeA . writeB ) ;
    (64) writeB -> . , writeA
    (65) writeB -> . empty
    (127) empty -> .

    ,               shift and go to state 131
    )               reduce using rule 127 (empty -> .)

    writeB                         shift and go to state 132
    empty                          shift and go to state 133

state 91

    (63) writeA -> CTE_STRING .

    ,               reduce using rule 63 (writeA -> CTE_STRING .)
    )               reduce using rule 63 (writeA -> CTE_STRING .)


state 92

    (62) writeA -> expression .

    ,               reduce using rule 62 (writeA -> expression .)
    )               reduce using rule 62 (writeA -> expression .)


state 93

    (104) move -> RIGHT .

    (               reduce using rule 104 (move -> RIGHT .)
    CTE_INTEGER     reduce using rule 104 (move -> RIGHT .)
    CTE_FLOAT       reduce using rule 104 (move -> RIGHT .)
    TRUE            reduce using rule 104 (move -> RIGHT .)
    FALSE           reduce using rule 104 (move -> RIGHT .)
    ID              reduce using rule 104 (move -> RIGHT .)


state 94

    (74) commandA -> OFF move . exp ;
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 134
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 95

    (101) move -> UP .

    (               reduce using rule 101 (move -> UP .)
    CTE_INTEGER     reduce using rule 101 (move -> UP .)
    CTE_FLOAT       reduce using rule 101 (move -> UP .)
    TRUE            reduce using rule 101 (move -> UP .)
    FALSE           reduce using rule 101 (move -> UP .)
    ID              reduce using rule 101 (move -> UP .)


state 96

    (102) move -> DOWN .

    (               reduce using rule 102 (move -> DOWN .)
    CTE_INTEGER     reduce using rule 102 (move -> DOWN .)
    CTE_FLOAT       reduce using rule 102 (move -> DOWN .)
    TRUE            reduce using rule 102 (move -> DOWN .)
    FALSE           reduce using rule 102 (move -> DOWN .)
    ID              reduce using rule 102 (move -> DOWN .)


state 97

    (103) move -> LEFT .

    (               reduce using rule 103 (move -> LEFT .)
    CTE_INTEGER     reduce using rule 103 (move -> LEFT .)
    CTE_FLOAT       reduce using rule 103 (move -> LEFT .)
    TRUE            reduce using rule 103 (move -> LEFT .)
    FALSE           reduce using rule 103 (move -> LEFT .)
    ID              reduce using rule 103 (move -> LEFT .)


state 98

    (73) commandA -> ON move . exp CTE_INTEGER color ;
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 135
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 99

    (34) id -> ID [ sumdim . exp ] [ sumdim exp ]
    (35) id -> ID [ sumdim . exp ]
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 136
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 100

    (66) array -> ARR typeDim ID . [ CTE_INTEGER ] ;

    [               shift and go to state 137


state 101

    (67) matrix -> MAT typeDim ID . [ CTE_INTEGER ] [ CTE_INTEGER ] ;

    [               shift and go to state 138


state 102

    (24) module -> MOD typeMod # . moduleID addMod insertQuadMod moduleA endMod
    (27) moduleID -> . ID

    ID              shift and go to state 139

    moduleID                       shift and go to state 140

state 103

    (86) expression -> exp AND . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 141
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 104

    (81) expression -> exp < . > exp
    (82) expression -> exp < . = exp
    (85) expression -> exp < . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    >               shift and go to state 143
    =               shift and go to state 142
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 144
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 105

    (80) expression -> exp = . = exp

    =               shift and go to state 145


state 106

    (87) expression -> exp OR . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 146
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 107

    (88) expression -> exp empty .

    )               reduce using rule 88 (expression -> exp empty .)
    ,               reduce using rule 88 (expression -> exp empty .)
    ;               reduce using rule 88 (expression -> exp empty .)


state 108

    (83) expression -> exp > . = exp
    (84) expression -> exp > . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    =               shift and go to state 147
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 148
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 109

    (95) factor -> ( expression ) .

    +               reduce using rule 95 (factor -> ( expression ) .)
    -               reduce using rule 95 (factor -> ( expression ) .)
    *               reduce using rule 95 (factor -> ( expression ) .)
    /               reduce using rule 95 (factor -> ( expression ) .)
    (               reduce using rule 95 (factor -> ( expression ) .)
    CTE_INTEGER     reduce using rule 95 (factor -> ( expression ) .)
    CTE_FLOAT       reduce using rule 95 (factor -> ( expression ) .)
    TRUE            reduce using rule 95 (factor -> ( expression ) .)
    FALSE           reduce using rule 95 (factor -> ( expression ) .)
    ID              reduce using rule 95 (factor -> ( expression ) .)
    )               reduce using rule 95 (factor -> ( expression ) .)
    ;               reduce using rule 95 (factor -> ( expression ) .)
    ,               reduce using rule 95 (factor -> ( expression ) .)
    =               reduce using rule 95 (factor -> ( expression ) .)
    <               reduce using rule 95 (factor -> ( expression ) .)
    >               reduce using rule 95 (factor -> ( expression ) .)
    AND             reduce using rule 95 (factor -> ( expression ) .)
    OR              reduce using rule 95 (factor -> ( expression ) .)
    RED             reduce using rule 95 (factor -> ( expression ) .)
    YELLOW          reduce using rule 95 (factor -> ( expression ) .)
    BLUE            reduce using rule 95 (factor -> ( expression ) .)
    GREEN           reduce using rule 95 (factor -> ( expression ) .)
    BLACK           reduce using rule 95 (factor -> ( expression ) .)
    WHITE           reduce using rule 95 (factor -> ( expression ) .)
    ORANGE          reduce using rule 95 (factor -> ( expression ) .)
    PURPLE          reduce using rule 95 (factor -> ( expression ) .)
    CYAN            reduce using rule 95 (factor -> ( expression ) .)
    ]               reduce using rule 95 (factor -> ( expression ) .)


state 110

    (89) exp -> exp + exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    =               reduce using rule 89 (exp -> exp + exp .)
    <               reduce using rule 89 (exp -> exp + exp .)
    >               reduce using rule 89 (exp -> exp + exp .)
    AND             reduce using rule 89 (exp -> exp + exp .)
    OR              reduce using rule 89 (exp -> exp + exp .)
    +               reduce using rule 89 (exp -> exp + exp .)
    -               reduce using rule 89 (exp -> exp + exp .)
    ;               reduce using rule 89 (exp -> exp + exp .)
    )               reduce using rule 89 (exp -> exp + exp .)
    ,               reduce using rule 89 (exp -> exp + exp .)
    (               reduce using rule 89 (exp -> exp + exp .)
    CTE_INTEGER     reduce using rule 89 (exp -> exp + exp .)
    CTE_FLOAT       reduce using rule 89 (exp -> exp + exp .)
    TRUE            reduce using rule 89 (exp -> exp + exp .)
    FALSE           reduce using rule 89 (exp -> exp + exp .)
    ID              reduce using rule 89 (exp -> exp + exp .)
    RED             reduce using rule 89 (exp -> exp + exp .)
    YELLOW          reduce using rule 89 (exp -> exp + exp .)
    BLUE            reduce using rule 89 (exp -> exp + exp .)
    GREEN           reduce using rule 89 (exp -> exp + exp .)
    BLACK           reduce using rule 89 (exp -> exp + exp .)
    WHITE           reduce using rule 89 (exp -> exp + exp .)
    ORANGE          reduce using rule 89 (exp -> exp + exp .)
    PURPLE          reduce using rule 89 (exp -> exp + exp .)
    CYAN            reduce using rule 89 (exp -> exp + exp .)
    ]               reduce using rule 89 (exp -> exp + exp .)
    *               shift and go to state 78
    /               shift and go to state 80

  ! *               [ reduce using rule 89 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 89 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 77 ]
  ! -               [ shift and go to state 79 ]


state 111

    (91) exp -> exp * exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    =               reduce using rule 91 (exp -> exp * exp .)
    <               reduce using rule 91 (exp -> exp * exp .)
    >               reduce using rule 91 (exp -> exp * exp .)
    AND             reduce using rule 91 (exp -> exp * exp .)
    OR              reduce using rule 91 (exp -> exp * exp .)
    +               reduce using rule 91 (exp -> exp * exp .)
    -               reduce using rule 91 (exp -> exp * exp .)
    *               reduce using rule 91 (exp -> exp * exp .)
    /               reduce using rule 91 (exp -> exp * exp .)
    ;               reduce using rule 91 (exp -> exp * exp .)
    )               reduce using rule 91 (exp -> exp * exp .)
    ,               reduce using rule 91 (exp -> exp * exp .)
    (               reduce using rule 91 (exp -> exp * exp .)
    CTE_INTEGER     reduce using rule 91 (exp -> exp * exp .)
    CTE_FLOAT       reduce using rule 91 (exp -> exp * exp .)
    TRUE            reduce using rule 91 (exp -> exp * exp .)
    FALSE           reduce using rule 91 (exp -> exp * exp .)
    ID              reduce using rule 91 (exp -> exp * exp .)
    RED             reduce using rule 91 (exp -> exp * exp .)
    YELLOW          reduce using rule 91 (exp -> exp * exp .)
    BLUE            reduce using rule 91 (exp -> exp * exp .)
    GREEN           reduce using rule 91 (exp -> exp * exp .)
    BLACK           reduce using rule 91 (exp -> exp * exp .)
    WHITE           reduce using rule 91 (exp -> exp * exp .)
    ORANGE          reduce using rule 91 (exp -> exp * exp .)
    PURPLE          reduce using rule 91 (exp -> exp * exp .)
    CYAN            reduce using rule 91 (exp -> exp * exp .)
    ]               reduce using rule 91 (exp -> exp * exp .)

  ! +               [ shift and go to state 77 ]
  ! -               [ shift and go to state 79 ]
  ! *               [ shift and go to state 78 ]
  ! /               [ shift and go to state 80 ]


state 112

    (90) exp -> exp - exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    =               reduce using rule 90 (exp -> exp - exp .)
    <               reduce using rule 90 (exp -> exp - exp .)
    >               reduce using rule 90 (exp -> exp - exp .)
    AND             reduce using rule 90 (exp -> exp - exp .)
    OR              reduce using rule 90 (exp -> exp - exp .)
    +               reduce using rule 90 (exp -> exp - exp .)
    -               reduce using rule 90 (exp -> exp - exp .)
    ;               reduce using rule 90 (exp -> exp - exp .)
    )               reduce using rule 90 (exp -> exp - exp .)
    ,               reduce using rule 90 (exp -> exp - exp .)
    (               reduce using rule 90 (exp -> exp - exp .)
    CTE_INTEGER     reduce using rule 90 (exp -> exp - exp .)
    CTE_FLOAT       reduce using rule 90 (exp -> exp - exp .)
    TRUE            reduce using rule 90 (exp -> exp - exp .)
    FALSE           reduce using rule 90 (exp -> exp - exp .)
    ID              reduce using rule 90 (exp -> exp - exp .)
    RED             reduce using rule 90 (exp -> exp - exp .)
    YELLOW          reduce using rule 90 (exp -> exp - exp .)
    BLUE            reduce using rule 90 (exp -> exp - exp .)
    GREEN           reduce using rule 90 (exp -> exp - exp .)
    BLACK           reduce using rule 90 (exp -> exp - exp .)
    WHITE           reduce using rule 90 (exp -> exp - exp .)
    ORANGE          reduce using rule 90 (exp -> exp - exp .)
    PURPLE          reduce using rule 90 (exp -> exp - exp .)
    CYAN            reduce using rule 90 (exp -> exp - exp .)
    ]               reduce using rule 90 (exp -> exp - exp .)
    *               shift and go to state 78
    /               shift and go to state 80

  ! *               [ reduce using rule 90 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 90 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 77 ]
  ! -               [ shift and go to state 79 ]


state 113

    (92) exp -> exp / exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    =               reduce using rule 92 (exp -> exp / exp .)
    <               reduce using rule 92 (exp -> exp / exp .)
    >               reduce using rule 92 (exp -> exp / exp .)
    AND             reduce using rule 92 (exp -> exp / exp .)
    OR              reduce using rule 92 (exp -> exp / exp .)
    +               reduce using rule 92 (exp -> exp / exp .)
    -               reduce using rule 92 (exp -> exp / exp .)
    *               reduce using rule 92 (exp -> exp / exp .)
    /               reduce using rule 92 (exp -> exp / exp .)
    ;               reduce using rule 92 (exp -> exp / exp .)
    )               reduce using rule 92 (exp -> exp / exp .)
    ,               reduce using rule 92 (exp -> exp / exp .)
    (               reduce using rule 92 (exp -> exp / exp .)
    CTE_INTEGER     reduce using rule 92 (exp -> exp / exp .)
    CTE_FLOAT       reduce using rule 92 (exp -> exp / exp .)
    TRUE            reduce using rule 92 (exp -> exp / exp .)
    FALSE           reduce using rule 92 (exp -> exp / exp .)
    ID              reduce using rule 92 (exp -> exp / exp .)
    RED             reduce using rule 92 (exp -> exp / exp .)
    YELLOW          reduce using rule 92 (exp -> exp / exp .)
    BLUE            reduce using rule 92 (exp -> exp / exp .)
    GREEN           reduce using rule 92 (exp -> exp / exp .)
    BLACK           reduce using rule 92 (exp -> exp / exp .)
    WHITE           reduce using rule 92 (exp -> exp / exp .)
    ORANGE          reduce using rule 92 (exp -> exp / exp .)
    PURPLE          reduce using rule 92 (exp -> exp / exp .)
    CYAN            reduce using rule 92 (exp -> exp / exp .)
    ]               reduce using rule 92 (exp -> exp / exp .)

  ! +               [ shift and go to state 77 ]
  ! -               [ shift and go to state 79 ]
  ! *               [ shift and go to state 78 ]
  ! /               [ shift and go to state 80 ]


state 114

    (107) color -> BLUE .

    ;               reduce using rule 107 (color -> BLUE .)


state 115

    (71) command -> figure exp exp color . ;

    ;               shift and go to state 149


state 116

    (112) color -> PURPLE .

    ;               reduce using rule 112 (color -> PURPLE .)


state 117

    (108) color -> GREEN .

    ;               reduce using rule 108 (color -> GREEN .)


state 118

    (106) color -> YELLOW .

    ;               reduce using rule 106 (color -> YELLOW .)


state 119

    (113) color -> CYAN .

    ;               reduce using rule 113 (color -> CYAN .)


state 120

    (111) color -> ORANGE .

    ;               reduce using rule 111 (color -> ORANGE .)


state 121

    (109) color -> BLACK .

    ;               reduce using rule 109 (color -> BLACK .)


state 122

    (110) color -> WHITE .

    ;               reduce using rule 110 (color -> WHITE .)


state 123

    (105) color -> RED .

    ;               reduce using rule 105 (color -> RED .)


state 124

    (41) maincalling -> insertEra . callingA
    (44) callingA -> . callingB
    (45) callingA -> . empty
    (46) callingB -> . exp checkParam callingC
    (127) empty -> .
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    )               reduce using rule 127 (empty -> .)
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    var_cte                        shift and go to state 37
    callID                         shift and go to state 5
    callingA                       shift and go to state 151
    callingB                       shift and go to state 152
    exp                            shift and go to state 153
    factor                         shift and go to state 41
    id                             shift and go to state 39
    empty                          shift and go to state 150

state 125

    (40) calling2 -> ( maincalling . )

    )               shift and go to state 154


state 126

    (75) cycle -> WHILE gotoW ( expression . ) gotoFalse block continueGoW

    )               shift and go to state 155


state 127

    (76) repeat -> REPLAY CTE_INTEGER gotoR [ . repeatA ] ;
    (77) repeatA -> . command repeatB
    (71) command -> . figure exp exp color ;
    (72) command -> . SAMPLE commandA
    (97) figure -> . OVAL
    (98) figure -> . TRIO
    (99) figure -> . QUAD
    (100) figure -> . ARC

    SAMPLE          shift and go to state 21
    OVAL            shift and go to state 7
    TRIO            shift and go to state 17
    QUAD            shift and go to state 24
    ARC             shift and go to state 32

    figure                         shift and go to state 4
    repeatA                        shift and go to state 156
    command                        shift and go to state 157

state 128

    (57) assign -> id = expression ; .

    MOD             reduce using rule 57 (assign -> id = expression ; .)
    IF              reduce using rule 57 (assign -> id = expression ; .)
    ECHO            reduce using rule 57 (assign -> id = expression ; .)
    WHILE           reduce using rule 57 (assign -> id = expression ; .)
    REPLAY          reduce using rule 57 (assign -> id = expression ; .)
    SAMPLE          reduce using rule 57 (assign -> id = expression ; .)
    #               reduce using rule 57 (assign -> id = expression ; .)
    ARR             reduce using rule 57 (assign -> id = expression ; .)
    MAT             reduce using rule 57 (assign -> id = expression ; .)
    RETURN          reduce using rule 57 (assign -> id = expression ; .)
    ID              reduce using rule 57 (assign -> id = expression ; .)
    OVAL            reduce using rule 57 (assign -> id = expression ; .)
    TRIO            reduce using rule 57 (assign -> id = expression ; .)
    QUAD            reduce using rule 57 (assign -> id = expression ; .)
    ARC             reduce using rule 57 (assign -> id = expression ; .)
    END             reduce using rule 57 (assign -> id = expression ; .)
    }               reduce using rule 57 (assign -> id = expression ; .)


state 129

    (39) calling -> # callID calling2 ; .

    MOD             reduce using rule 39 (calling -> # callID calling2 ; .)
    IF              reduce using rule 39 (calling -> # callID calling2 ; .)
    ECHO            reduce using rule 39 (calling -> # callID calling2 ; .)
    WHILE           reduce using rule 39 (calling -> # callID calling2 ; .)
    REPLAY          reduce using rule 39 (calling -> # callID calling2 ; .)
    SAMPLE          reduce using rule 39 (calling -> # callID calling2 ; .)
    #               reduce using rule 39 (calling -> # callID calling2 ; .)
    ARR             reduce using rule 39 (calling -> # callID calling2 ; .)
    MAT             reduce using rule 39 (calling -> # callID calling2 ; .)
    RETURN          reduce using rule 39 (calling -> # callID calling2 ; .)
    ID              reduce using rule 39 (calling -> # callID calling2 ; .)
    OVAL            reduce using rule 39 (calling -> # callID calling2 ; .)
    TRIO            reduce using rule 39 (calling -> # callID calling2 ; .)
    QUAD            reduce using rule 39 (calling -> # callID calling2 ; .)
    ARC             reduce using rule 39 (calling -> # callID calling2 ; .)
    END             reduce using rule 39 (calling -> # callID calling2 ; .)
    }               reduce using rule 39 (calling -> # callID calling2 ; .)


state 130

    (58) condition -> IF ( expression ) . gotoFalse block conditionA continueGo
    (119) gotoFalse -> .

    {               reduce using rule 119 (gotoFalse -> .)

    gotoFalse                      shift and go to state 158

state 131

    (64) writeB -> , . writeA
    (62) writeA -> . expression
    (63) writeA -> . CTE_STRING
    (80) expression -> . exp = = exp
    (81) expression -> . exp < > exp
    (82) expression -> . exp < = exp
    (83) expression -> . exp > = exp
    (84) expression -> . exp > exp
    (85) expression -> . exp < exp
    (86) expression -> . exp AND exp
    (87) expression -> . exp OR exp
    (88) expression -> . exp empty
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    CTE_STRING      shift and go to state 91
    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 74
    factor                         shift and go to state 41
    writeA                         shift and go to state 159
    expression                     shift and go to state 92
    id                             shift and go to state 39

state 132

    (61) write -> ECHO ( writeA writeB . ) ;

    )               shift and go to state 160


state 133

    (65) writeB -> empty .

    )               reduce using rule 65 (writeB -> empty .)


state 134

    (74) commandA -> OFF move exp . ;
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    ;               shift and go to state 161
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 135

    (73) commandA -> ON move exp . CTE_INTEGER color ;
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    CTE_INTEGER     shift and go to state 162
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 136

    (34) id -> ID [ sumdim exp . ] [ sumdim exp ]
    (35) id -> ID [ sumdim exp . ]
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    ]               shift and go to state 163
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 137

    (66) array -> ARR typeDim ID [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 164


state 138

    (67) matrix -> MAT typeDim ID [ . CTE_INTEGER ] [ CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 165


state 139

    (27) moduleID -> ID .

    (               reduce using rule 27 (moduleID -> ID .)
    {               reduce using rule 27 (moduleID -> ID .)


state 140

    (24) module -> MOD typeMod # moduleID . addMod insertQuadMod moduleA endMod
    (23) addMod -> .

    (               reduce using rule 23 (addMod -> .)
    {               reduce using rule 23 (addMod -> .)

    addMod                         shift and go to state 166

state 141

    (86) expression -> exp AND exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 86 (expression -> exp AND exp .)
    ,               reduce using rule 86 (expression -> exp AND exp .)
    ;               reduce using rule 86 (expression -> exp AND exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 142

    (82) expression -> exp < = . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 167
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 143

    (81) expression -> exp < > . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 168
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 144

    (85) expression -> exp < exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 85 (expression -> exp < exp .)
    ,               reduce using rule 85 (expression -> exp < exp .)
    ;               reduce using rule 85 (expression -> exp < exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 145

    (80) expression -> exp = = . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 169
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 146

    (87) expression -> exp OR exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 87 (expression -> exp OR exp .)
    ,               reduce using rule 87 (expression -> exp OR exp .)
    ;               reduce using rule 87 (expression -> exp OR exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 147

    (83) expression -> exp > = . exp
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 170
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 148

    (84) expression -> exp > exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 84 (expression -> exp > exp .)
    ,               reduce using rule 84 (expression -> exp > exp .)
    ;               reduce using rule 84 (expression -> exp > exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 149

    (71) command -> figure exp exp color ; .

    IF              reduce using rule 71 (command -> figure exp exp color ; .)
    ECHO            reduce using rule 71 (command -> figure exp exp color ; .)
    WHILE           reduce using rule 71 (command -> figure exp exp color ; .)
    REPLAY          reduce using rule 71 (command -> figure exp exp color ; .)
    SAMPLE          reduce using rule 71 (command -> figure exp exp color ; .)
    #               reduce using rule 71 (command -> figure exp exp color ; .)
    ARR             reduce using rule 71 (command -> figure exp exp color ; .)
    MAT             reduce using rule 71 (command -> figure exp exp color ; .)
    RETURN          reduce using rule 71 (command -> figure exp exp color ; .)
    ID              reduce using rule 71 (command -> figure exp exp color ; .)
    OVAL            reduce using rule 71 (command -> figure exp exp color ; .)
    TRIO            reduce using rule 71 (command -> figure exp exp color ; .)
    QUAD            reduce using rule 71 (command -> figure exp exp color ; .)
    ARC             reduce using rule 71 (command -> figure exp exp color ; .)
    }               reduce using rule 71 (command -> figure exp exp color ; .)
    ]               reduce using rule 71 (command -> figure exp exp color ; .)
    MOD             reduce using rule 71 (command -> figure exp exp color ; .)
    END             reduce using rule 71 (command -> figure exp exp color ; .)


state 150

    (45) callingA -> empty .

    )               reduce using rule 45 (callingA -> empty .)


state 151

    (41) maincalling -> insertEra callingA .

    )               reduce using rule 41 (maincalling -> insertEra callingA .)


state 152

    (44) callingA -> callingB .

    )               reduce using rule 44 (callingA -> callingB .)


state 153

    (46) callingB -> exp . checkParam callingC
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp
    (47) checkParam -> .

    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80
    ,               reduce using rule 47 (checkParam -> .)
    )               reduce using rule 47 (checkParam -> .)

    checkParam                     shift and go to state 171

state 154

    (40) calling2 -> ( maincalling ) .

    =               reduce using rule 40 (calling2 -> ( maincalling ) .)
    ;               reduce using rule 40 (calling2 -> ( maincalling ) .)
    +               reduce using rule 40 (calling2 -> ( maincalling ) .)
    -               reduce using rule 40 (calling2 -> ( maincalling ) .)
    *               reduce using rule 40 (calling2 -> ( maincalling ) .)
    /               reduce using rule 40 (calling2 -> ( maincalling ) .)
    (               reduce using rule 40 (calling2 -> ( maincalling ) .)
    CTE_INTEGER     reduce using rule 40 (calling2 -> ( maincalling ) .)
    CTE_FLOAT       reduce using rule 40 (calling2 -> ( maincalling ) .)
    TRUE            reduce using rule 40 (calling2 -> ( maincalling ) .)
    FALSE           reduce using rule 40 (calling2 -> ( maincalling ) .)
    ID              reduce using rule 40 (calling2 -> ( maincalling ) .)
    <               reduce using rule 40 (calling2 -> ( maincalling ) .)
    >               reduce using rule 40 (calling2 -> ( maincalling ) .)
    AND             reduce using rule 40 (calling2 -> ( maincalling ) .)
    OR              reduce using rule 40 (calling2 -> ( maincalling ) .)
    )               reduce using rule 40 (calling2 -> ( maincalling ) .)
    RED             reduce using rule 40 (calling2 -> ( maincalling ) .)
    YELLOW          reduce using rule 40 (calling2 -> ( maincalling ) .)
    BLUE            reduce using rule 40 (calling2 -> ( maincalling ) .)
    GREEN           reduce using rule 40 (calling2 -> ( maincalling ) .)
    BLACK           reduce using rule 40 (calling2 -> ( maincalling ) .)
    WHITE           reduce using rule 40 (calling2 -> ( maincalling ) .)
    ORANGE          reduce using rule 40 (calling2 -> ( maincalling ) .)
    PURPLE          reduce using rule 40 (calling2 -> ( maincalling ) .)
    CYAN            reduce using rule 40 (calling2 -> ( maincalling ) .)
    ,               reduce using rule 40 (calling2 -> ( maincalling ) .)
    ]               reduce using rule 40 (calling2 -> ( maincalling ) .)


state 155

    (75) cycle -> WHILE gotoW ( expression ) . gotoFalse block continueGoW
    (119) gotoFalse -> .

    {               reduce using rule 119 (gotoFalse -> .)

    gotoFalse                      shift and go to state 172

state 156

    (76) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA . ] ;

    ]               shift and go to state 173


state 157

    (77) repeatA -> command . repeatB
    (78) repeatB -> . repeatA
    (79) repeatB -> . empty
    (77) repeatA -> . command repeatB
    (127) empty -> .
    (71) command -> . figure exp exp color ;
    (72) command -> . SAMPLE commandA
    (97) figure -> . OVAL
    (98) figure -> . TRIO
    (99) figure -> . QUAD
    (100) figure -> . ARC

    ]               reduce using rule 127 (empty -> .)
    SAMPLE          shift and go to state 21
    OVAL            shift and go to state 7
    TRIO            shift and go to state 17
    QUAD            shift and go to state 24
    ARC             shift and go to state 32

    figure                         shift and go to state 4
    repeatA                        shift and go to state 174
    repeatB                        shift and go to state 175
    command                        shift and go to state 157
    empty                          shift and go to state 176

state 158

    (58) condition -> IF ( expression ) gotoFalse . block conditionA continueGo
    (51) block -> . { blockA

    {               shift and go to state 177

    block                          shift and go to state 178

state 159

    (64) writeB -> , writeA .

    )               reduce using rule 64 (writeB -> , writeA .)


state 160

    (61) write -> ECHO ( writeA writeB ) . ;

    ;               shift and go to state 179


state 161

    (74) commandA -> OFF move exp ; .

    MOD             reduce using rule 74 (commandA -> OFF move exp ; .)
    IF              reduce using rule 74 (commandA -> OFF move exp ; .)
    ECHO            reduce using rule 74 (commandA -> OFF move exp ; .)
    WHILE           reduce using rule 74 (commandA -> OFF move exp ; .)
    REPLAY          reduce using rule 74 (commandA -> OFF move exp ; .)
    SAMPLE          reduce using rule 74 (commandA -> OFF move exp ; .)
    #               reduce using rule 74 (commandA -> OFF move exp ; .)
    ARR             reduce using rule 74 (commandA -> OFF move exp ; .)
    MAT             reduce using rule 74 (commandA -> OFF move exp ; .)
    RETURN          reduce using rule 74 (commandA -> OFF move exp ; .)
    ID              reduce using rule 74 (commandA -> OFF move exp ; .)
    OVAL            reduce using rule 74 (commandA -> OFF move exp ; .)
    TRIO            reduce using rule 74 (commandA -> OFF move exp ; .)
    QUAD            reduce using rule 74 (commandA -> OFF move exp ; .)
    ARC             reduce using rule 74 (commandA -> OFF move exp ; .)
    END             reduce using rule 74 (commandA -> OFF move exp ; .)
    ]               reduce using rule 74 (commandA -> OFF move exp ; .)
    }               reduce using rule 74 (commandA -> OFF move exp ; .)


state 162

    (73) commandA -> ON move exp CTE_INTEGER . color ;
    (105) color -> . RED
    (106) color -> . YELLOW
    (107) color -> . BLUE
    (108) color -> . GREEN
    (109) color -> . BLACK
    (110) color -> . WHITE
    (111) color -> . ORANGE
    (112) color -> . PURPLE
    (113) color -> . CYAN

    RED             shift and go to state 123
    YELLOW          shift and go to state 118
    BLUE            shift and go to state 114
    GREEN           shift and go to state 117
    BLACK           shift and go to state 121
    WHITE           shift and go to state 122
    ORANGE          shift and go to state 120
    PURPLE          shift and go to state 116
    CYAN            shift and go to state 119

    color                          shift and go to state 180

state 163

    (34) id -> ID [ sumdim exp ] . [ sumdim exp ]
    (35) id -> ID [ sumdim exp ] .

    [               shift and go to state 181
    =               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    <               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    >               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    AND             reduce using rule 35 (id -> ID [ sumdim exp ] .)
    OR              reduce using rule 35 (id -> ID [ sumdim exp ] .)
    +               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    -               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    *               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    /               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    )               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    ;               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    ,               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    (               reduce using rule 35 (id -> ID [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 35 (id -> ID [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 35 (id -> ID [ sumdim exp ] .)
    TRUE            reduce using rule 35 (id -> ID [ sumdim exp ] .)
    FALSE           reduce using rule 35 (id -> ID [ sumdim exp ] .)
    ID              reduce using rule 35 (id -> ID [ sumdim exp ] .)
    RED             reduce using rule 35 (id -> ID [ sumdim exp ] .)
    YELLOW          reduce using rule 35 (id -> ID [ sumdim exp ] .)
    BLUE            reduce using rule 35 (id -> ID [ sumdim exp ] .)
    GREEN           reduce using rule 35 (id -> ID [ sumdim exp ] .)
    BLACK           reduce using rule 35 (id -> ID [ sumdim exp ] .)
    WHITE           reduce using rule 35 (id -> ID [ sumdim exp ] .)
    ORANGE          reduce using rule 35 (id -> ID [ sumdim exp ] .)
    PURPLE          reduce using rule 35 (id -> ID [ sumdim exp ] .)
    CYAN            reduce using rule 35 (id -> ID [ sumdim exp ] .)
    ]               reduce using rule 35 (id -> ID [ sumdim exp ] .)


state 164

    (66) array -> ARR typeDim ID [ CTE_INTEGER . ] ;

    ]               shift and go to state 182


state 165

    (67) matrix -> MAT typeDim ID [ CTE_INTEGER . ] [ CTE_INTEGER ] ;

    ]               shift and go to state 183


state 166

    (24) module -> MOD typeMod # moduleID addMod . insertQuadMod moduleA endMod
    (125) insertQuadMod -> .

    (               reduce using rule 125 (insertQuadMod -> .)
    {               reduce using rule 125 (insertQuadMod -> .)

    insertQuadMod                  shift and go to state 184

state 167

    (82) expression -> exp < = exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 82 (expression -> exp < = exp .)
    ,               reduce using rule 82 (expression -> exp < = exp .)
    ;               reduce using rule 82 (expression -> exp < = exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 168

    (81) expression -> exp < > exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 81 (expression -> exp < > exp .)
    ,               reduce using rule 81 (expression -> exp < > exp .)
    ;               reduce using rule 81 (expression -> exp < > exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 169

    (80) expression -> exp = = exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 80 (expression -> exp = = exp .)
    ,               reduce using rule 80 (expression -> exp = = exp .)
    ;               reduce using rule 80 (expression -> exp = = exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 170

    (83) expression -> exp > = exp .
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    )               reduce using rule 83 (expression -> exp > = exp .)
    ,               reduce using rule 83 (expression -> exp > = exp .)
    ;               reduce using rule 83 (expression -> exp > = exp .)
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 171

    (46) callingB -> exp checkParam . callingC
    (48) callingC -> . , sumXparam callingB
    (49) callingC -> . empty
    (127) empty -> .

    ,               shift and go to state 185
    )               reduce using rule 127 (empty -> .)

    callingC                       shift and go to state 186
    empty                          shift and go to state 187

state 172

    (75) cycle -> WHILE gotoW ( expression ) gotoFalse . block continueGoW
    (51) block -> . { blockA

    {               shift and go to state 177

    block                          shift and go to state 188

state 173

    (76) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] . ;

    ;               shift and go to state 189


state 174

    (78) repeatB -> repeatA .

    ]               reduce using rule 78 (repeatB -> repeatA .)


state 175

    (77) repeatA -> command repeatB .

    ]               reduce using rule 77 (repeatA -> command repeatB .)


state 176

    (79) repeatB -> empty .

    ]               reduce using rule 79 (repeatB -> empty .)


state 177

    (51) block -> { . blockA
    (52) blockA -> . blockB }
    (53) blockA -> . }
    (54) blockB -> . statute blockC
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . return
    (57) assign -> . id = expression ;
    (58) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (61) write -> . ECHO ( writeA writeB ) ;
    (75) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (76) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (71) command -> . figure exp exp color ;
    (72) command -> . SAMPLE commandA
    (39) calling -> . # callID calling2 ;
    (66) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (67) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (94) return -> . RETURN exp ;
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (97) figure -> . OVAL
    (98) figure -> . TRIO
    (99) figure -> . QUAD
    (100) figure -> . ARC
    (42) callID -> . ID

    }               shift and go to state 191
    IF              shift and go to state 16
    ECHO            shift and go to state 20
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 21
    #               shift and go to state 13
    ARR             shift and go to state 29
    MAT             shift and go to state 30
    RETURN          shift and go to state 3
    ID              shift and go to state 25
    OVAL            shift and go to state 7
    TRIO            shift and go to state 17
    QUAD            shift and go to state 24
    ARC             shift and go to state 32

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    array                          shift and go to state 11
    id                             shift and go to state 12
    matrix                         shift and go to state 14
    write                          shift and go to state 15
    command                        shift and go to state 33
    repeat                         shift and go to state 18
    return                         shift and go to state 10
    condition                      shift and go to state 26
    cycle                          shift and go to state 27
    statute                        shift and go to state 190
    calling                        shift and go to state 31
    blockB                         shift and go to state 192
    blockA                         shift and go to state 193
    assign                         shift and go to state 36

state 178

    (58) condition -> IF ( expression ) gotoFalse block . conditionA continueGo
    (59) conditionA -> . ELSE gotoE block
    (60) conditionA -> . empty
    (127) empty -> .

    ELSE            shift and go to state 196
    MOD             reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    ECHO            reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    REPLAY          reduce using rule 127 (empty -> .)
    SAMPLE          reduce using rule 127 (empty -> .)
    #               reduce using rule 127 (empty -> .)
    ARR             reduce using rule 127 (empty -> .)
    MAT             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    OVAL            reduce using rule 127 (empty -> .)
    TRIO            reduce using rule 127 (empty -> .)
    QUAD            reduce using rule 127 (empty -> .)
    ARC             reduce using rule 127 (empty -> .)
    END             reduce using rule 127 (empty -> .)
    }               reduce using rule 127 (empty -> .)

    conditionA                     shift and go to state 194
    empty                          shift and go to state 195

state 179

    (61) write -> ECHO ( writeA writeB ) ; .

    IF              reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    ECHO            reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    WHILE           reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    REPLAY          reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    SAMPLE          reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    #               reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    ARR             reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    MAT             reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    RETURN          reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    ID              reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    OVAL            reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    TRIO            reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    QUAD            reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    ARC             reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    }               reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    MOD             reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)
    END             reduce using rule 61 (write -> ECHO ( writeA writeB ) ; .)


state 180

    (73) commandA -> ON move exp CTE_INTEGER color . ;

    ;               shift and go to state 197


state 181

    (34) id -> ID [ sumdim exp ] [ . sumdim exp ]
    (38) sumdim -> .

    (               reduce using rule 38 (sumdim -> .)
    CTE_INTEGER     reduce using rule 38 (sumdim -> .)
    CTE_FLOAT       reduce using rule 38 (sumdim -> .)
    TRUE            reduce using rule 38 (sumdim -> .)
    FALSE           reduce using rule 38 (sumdim -> .)
    ID              reduce using rule 38 (sumdim -> .)

    sumdim                         shift and go to state 198

state 182

    (66) array -> ARR typeDim ID [ CTE_INTEGER ] . ;

    ;               shift and go to state 199


state 183

    (67) matrix -> MAT typeDim ID [ CTE_INTEGER ] . [ CTE_INTEGER ] ;

    [               shift and go to state 200


state 184

    (24) module -> MOD typeMod # moduleID addMod insertQuadMod . moduleA endMod
    (25) moduleA -> . ( vars ) block
    (26) moduleA -> . block
    (51) block -> . { blockA

    (               shift and go to state 201
    {               shift and go to state 177

    block                          shift and go to state 202
    moduleA                        shift and go to state 203

state 185

    (48) callingC -> , . sumXparam callingB
    (50) sumXparam -> .

    (               reduce using rule 50 (sumXparam -> .)
    CTE_INTEGER     reduce using rule 50 (sumXparam -> .)
    CTE_FLOAT       reduce using rule 50 (sumXparam -> .)
    TRUE            reduce using rule 50 (sumXparam -> .)
    FALSE           reduce using rule 50 (sumXparam -> .)
    ID              reduce using rule 50 (sumXparam -> .)

    sumXparam                      shift and go to state 204

state 186

    (46) callingB -> exp checkParam callingC .

    )               reduce using rule 46 (callingB -> exp checkParam callingC .)


state 187

    (49) callingC -> empty .

    )               reduce using rule 49 (callingC -> empty .)


state 188

    (75) cycle -> WHILE gotoW ( expression ) gotoFalse block . continueGoW
    (124) continueGoW -> .

    MOD             reduce using rule 124 (continueGoW -> .)
    IF              reduce using rule 124 (continueGoW -> .)
    ECHO            reduce using rule 124 (continueGoW -> .)
    WHILE           reduce using rule 124 (continueGoW -> .)
    REPLAY          reduce using rule 124 (continueGoW -> .)
    SAMPLE          reduce using rule 124 (continueGoW -> .)
    #               reduce using rule 124 (continueGoW -> .)
    ARR             reduce using rule 124 (continueGoW -> .)
    MAT             reduce using rule 124 (continueGoW -> .)
    RETURN          reduce using rule 124 (continueGoW -> .)
    ID              reduce using rule 124 (continueGoW -> .)
    OVAL            reduce using rule 124 (continueGoW -> .)
    TRIO            reduce using rule 124 (continueGoW -> .)
    QUAD            reduce using rule 124 (continueGoW -> .)
    ARC             reduce using rule 124 (continueGoW -> .)
    END             reduce using rule 124 (continueGoW -> .)
    }               reduce using rule 124 (continueGoW -> .)

    continueGoW                    shift and go to state 205

state 189

    (76) repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .

    MOD             reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    IF              reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ECHO            reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    WHILE           reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    REPLAY          reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    SAMPLE          reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    #               reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARR             reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    MAT             reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    RETURN          reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ID              reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    OVAL            reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    TRIO            reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    QUAD            reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    ARC             reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    END             reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)
    }               reduce using rule 76 (repeat -> REPLAY CTE_INTEGER gotoR [ repeatA ] ; .)


state 190

    (54) blockB -> statute . blockC
    (55) blockC -> . blockB
    (56) blockC -> . empty
    (54) blockB -> . statute blockC
    (127) empty -> .
    (9) statute -> . assign
    (10) statute -> . condition
    (11) statute -> . write
    (12) statute -> . cycle
    (13) statute -> . repeat
    (14) statute -> . command
    (15) statute -> . calling
    (16) statute -> . array
    (17) statute -> . matrix
    (18) statute -> . return
    (57) assign -> . id = expression ;
    (58) condition -> . IF ( expression ) gotoFalse block conditionA continueGo
    (61) write -> . ECHO ( writeA writeB ) ;
    (75) cycle -> . WHILE gotoW ( expression ) gotoFalse block continueGoW
    (76) repeat -> . REPLAY CTE_INTEGER gotoR [ repeatA ] ;
    (71) command -> . figure exp exp color ;
    (72) command -> . SAMPLE commandA
    (39) calling -> . # callID calling2 ;
    (66) array -> . ARR typeDim ID [ CTE_INTEGER ] ;
    (67) matrix -> . MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ;
    (94) return -> . RETURN exp ;
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (97) figure -> . OVAL
    (98) figure -> . TRIO
    (99) figure -> . QUAD
    (100) figure -> . ARC
    (42) callID -> . ID

    }               reduce using rule 127 (empty -> .)
    IF              shift and go to state 16
    ECHO            shift and go to state 20
    WHILE           shift and go to state 8
    REPLAY          shift and go to state 9
    SAMPLE          shift and go to state 21
    #               shift and go to state 13
    ARR             shift and go to state 29
    MAT             shift and go to state 30
    RETURN          shift and go to state 3
    ID              shift and go to state 25
    OVAL            shift and go to state 7
    TRIO            shift and go to state 17
    QUAD            shift and go to state 24
    ARC             shift and go to state 32

    figure                         shift and go to state 4
    callID                         shift and go to state 5
    array                          shift and go to state 11
    id                             shift and go to state 12
    matrix                         shift and go to state 14
    write                          shift and go to state 15
    command                        shift and go to state 33
    empty                          shift and go to state 206
    repeat                         shift and go to state 18
    return                         shift and go to state 10
    condition                      shift and go to state 26
    cycle                          shift and go to state 27
    statute                        shift and go to state 190
    calling                        shift and go to state 31
    blockC                         shift and go to state 207
    blockB                         shift and go to state 208
    assign                         shift and go to state 36

state 191

    (53) blockA -> } .

    ELSE            reduce using rule 53 (blockA -> } .)
    MOD             reduce using rule 53 (blockA -> } .)
    IF              reduce using rule 53 (blockA -> } .)
    ECHO            reduce using rule 53 (blockA -> } .)
    WHILE           reduce using rule 53 (blockA -> } .)
    REPLAY          reduce using rule 53 (blockA -> } .)
    SAMPLE          reduce using rule 53 (blockA -> } .)
    #               reduce using rule 53 (blockA -> } .)
    ARR             reduce using rule 53 (blockA -> } .)
    MAT             reduce using rule 53 (blockA -> } .)
    RETURN          reduce using rule 53 (blockA -> } .)
    ID              reduce using rule 53 (blockA -> } .)
    OVAL            reduce using rule 53 (blockA -> } .)
    TRIO            reduce using rule 53 (blockA -> } .)
    QUAD            reduce using rule 53 (blockA -> } .)
    ARC             reduce using rule 53 (blockA -> } .)
    END             reduce using rule 53 (blockA -> } .)
    }               reduce using rule 53 (blockA -> } .)


state 192

    (52) blockA -> blockB . }

    }               shift and go to state 209


state 193

    (51) block -> { blockA .

    MOD             reduce using rule 51 (block -> { blockA .)
    IF              reduce using rule 51 (block -> { blockA .)
    ECHO            reduce using rule 51 (block -> { blockA .)
    WHILE           reduce using rule 51 (block -> { blockA .)
    REPLAY          reduce using rule 51 (block -> { blockA .)
    SAMPLE          reduce using rule 51 (block -> { blockA .)
    #               reduce using rule 51 (block -> { blockA .)
    ARR             reduce using rule 51 (block -> { blockA .)
    MAT             reduce using rule 51 (block -> { blockA .)
    RETURN          reduce using rule 51 (block -> { blockA .)
    ID              reduce using rule 51 (block -> { blockA .)
    OVAL            reduce using rule 51 (block -> { blockA .)
    TRIO            reduce using rule 51 (block -> { blockA .)
    QUAD            reduce using rule 51 (block -> { blockA .)
    ARC             reduce using rule 51 (block -> { blockA .)
    END             reduce using rule 51 (block -> { blockA .)
    }               reduce using rule 51 (block -> { blockA .)
    ELSE            reduce using rule 51 (block -> { blockA .)


state 194

    (58) condition -> IF ( expression ) gotoFalse block conditionA . continueGo
    (123) continueGo -> .

    MOD             reduce using rule 123 (continueGo -> .)
    IF              reduce using rule 123 (continueGo -> .)
    ECHO            reduce using rule 123 (continueGo -> .)
    WHILE           reduce using rule 123 (continueGo -> .)
    REPLAY          reduce using rule 123 (continueGo -> .)
    SAMPLE          reduce using rule 123 (continueGo -> .)
    #               reduce using rule 123 (continueGo -> .)
    ARR             reduce using rule 123 (continueGo -> .)
    MAT             reduce using rule 123 (continueGo -> .)
    RETURN          reduce using rule 123 (continueGo -> .)
    ID              reduce using rule 123 (continueGo -> .)
    OVAL            reduce using rule 123 (continueGo -> .)
    TRIO            reduce using rule 123 (continueGo -> .)
    QUAD            reduce using rule 123 (continueGo -> .)
    ARC             reduce using rule 123 (continueGo -> .)
    END             reduce using rule 123 (continueGo -> .)
    }               reduce using rule 123 (continueGo -> .)

    continueGo                     shift and go to state 210

state 195

    (60) conditionA -> empty .

    MOD             reduce using rule 60 (conditionA -> empty .)
    IF              reduce using rule 60 (conditionA -> empty .)
    ECHO            reduce using rule 60 (conditionA -> empty .)
    WHILE           reduce using rule 60 (conditionA -> empty .)
    REPLAY          reduce using rule 60 (conditionA -> empty .)
    SAMPLE          reduce using rule 60 (conditionA -> empty .)
    #               reduce using rule 60 (conditionA -> empty .)
    ARR             reduce using rule 60 (conditionA -> empty .)
    MAT             reduce using rule 60 (conditionA -> empty .)
    RETURN          reduce using rule 60 (conditionA -> empty .)
    ID              reduce using rule 60 (conditionA -> empty .)
    OVAL            reduce using rule 60 (conditionA -> empty .)
    TRIO            reduce using rule 60 (conditionA -> empty .)
    QUAD            reduce using rule 60 (conditionA -> empty .)
    ARC             reduce using rule 60 (conditionA -> empty .)
    END             reduce using rule 60 (conditionA -> empty .)
    }               reduce using rule 60 (conditionA -> empty .)


state 196

    (59) conditionA -> ELSE . gotoE block
    (120) gotoE -> .

    {               reduce using rule 120 (gotoE -> .)

    gotoE                          shift and go to state 211

state 197

    (73) commandA -> ON move exp CTE_INTEGER color ; .

    MOD             reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    IF              reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    ECHO            reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    WHILE           reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    REPLAY          reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    SAMPLE          reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    #               reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARR             reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    MAT             reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    RETURN          reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    ID              reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    OVAL            reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    TRIO            reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    QUAD            reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    ARC             reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    END             reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    ]               reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)
    }               reduce using rule 73 (commandA -> ON move exp CTE_INTEGER color ; .)


state 198

    (34) id -> ID [ sumdim exp ] [ sumdim . exp ]
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    callID                         shift and go to state 5
    var_cte                        shift and go to state 37
    exp                            shift and go to state 212
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 199

    (66) array -> ARR typeDim ID [ CTE_INTEGER ] ; .

    IF              reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    #               reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    RETURN          reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ID              reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    }               reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)
    END             reduce using rule 66 (array -> ARR typeDim ID [ CTE_INTEGER ] ; .)


state 200

    (67) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ . CTE_INTEGER ] ;

    CTE_INTEGER     shift and go to state 213


state 201

    (25) moduleA -> ( . vars ) block
    (28) vars -> . type ID varsA
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . BOOL

    INT             shift and go to state 216
    FLOAT           shift and go to state 215
    BOOL            shift and go to state 217

    type                           shift and go to state 218
    vars                           shift and go to state 214

state 202

    (26) moduleA -> block .

    MOD             reduce using rule 26 (moduleA -> block .)
    IF              reduce using rule 26 (moduleA -> block .)
    ECHO            reduce using rule 26 (moduleA -> block .)
    WHILE           reduce using rule 26 (moduleA -> block .)
    REPLAY          reduce using rule 26 (moduleA -> block .)
    SAMPLE          reduce using rule 26 (moduleA -> block .)
    #               reduce using rule 26 (moduleA -> block .)
    ARR             reduce using rule 26 (moduleA -> block .)
    MAT             reduce using rule 26 (moduleA -> block .)
    RETURN          reduce using rule 26 (moduleA -> block .)
    ID              reduce using rule 26 (moduleA -> block .)
    OVAL            reduce using rule 26 (moduleA -> block .)
    TRIO            reduce using rule 26 (moduleA -> block .)
    QUAD            reduce using rule 26 (moduleA -> block .)
    ARC             reduce using rule 26 (moduleA -> block .)
    END             reduce using rule 26 (moduleA -> block .)


state 203

    (24) module -> MOD typeMod # moduleID addMod insertQuadMod moduleA . endMod
    (126) endMod -> .

    MOD             reduce using rule 126 (endMod -> .)
    IF              reduce using rule 126 (endMod -> .)
    ECHO            reduce using rule 126 (endMod -> .)
    WHILE           reduce using rule 126 (endMod -> .)
    REPLAY          reduce using rule 126 (endMod -> .)
    SAMPLE          reduce using rule 126 (endMod -> .)
    #               reduce using rule 126 (endMod -> .)
    ARR             reduce using rule 126 (endMod -> .)
    MAT             reduce using rule 126 (endMod -> .)
    RETURN          reduce using rule 126 (endMod -> .)
    ID              reduce using rule 126 (endMod -> .)
    OVAL            reduce using rule 126 (endMod -> .)
    TRIO            reduce using rule 126 (endMod -> .)
    QUAD            reduce using rule 126 (endMod -> .)
    ARC             reduce using rule 126 (endMod -> .)
    END             reduce using rule 126 (endMod -> .)

    endMod                         shift and go to state 219

state 204

    (48) callingC -> , sumXparam . callingB
    (46) callingB -> . exp checkParam callingC
    (89) exp -> . exp + exp
    (90) exp -> . exp - exp
    (91) exp -> . exp * exp
    (92) exp -> . exp / exp
    (93) exp -> . factor empty
    (95) factor -> . ( expression )
    (96) factor -> . var_cte
    (114) var_cte -> . id
    (115) var_cte -> . CTE_INTEGER
    (116) var_cte -> . CTE_FLOAT
    (117) var_cte -> . TRUE
    (118) var_cte -> . FALSE
    (34) id -> . ID [ sumdim exp ] [ sumdim exp ]
    (35) id -> . ID [ sumdim exp ]
    (36) id -> . callID # calling2
    (37) id -> . ID empty
    (42) callID -> . ID

    (               shift and go to state 40
    CTE_INTEGER     shift and go to state 42
    CTE_FLOAT       shift and go to state 44
    TRUE            shift and go to state 38
    FALSE           shift and go to state 43
    ID              shift and go to state 25

    var_cte                        shift and go to state 37
    callID                         shift and go to state 5
    callingB                       shift and go to state 220
    exp                            shift and go to state 153
    factor                         shift and go to state 41
    id                             shift and go to state 39

state 205

    (75) cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .

    MOD             reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    IF              reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ECHO            reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    WHILE           reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    REPLAY          reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    SAMPLE          reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    #               reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARR             reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    MAT             reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    RETURN          reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ID              reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    OVAL            reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    TRIO            reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    QUAD            reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    ARC             reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    END             reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)
    }               reduce using rule 75 (cycle -> WHILE gotoW ( expression ) gotoFalse block continueGoW .)


state 206

    (56) blockC -> empty .

    }               reduce using rule 56 (blockC -> empty .)


state 207

    (54) blockB -> statute blockC .

    }               reduce using rule 54 (blockB -> statute blockC .)


state 208

    (55) blockC -> blockB .

    }               reduce using rule 55 (blockC -> blockB .)


state 209

    (52) blockA -> blockB } .

    ELSE            reduce using rule 52 (blockA -> blockB } .)
    MOD             reduce using rule 52 (blockA -> blockB } .)
    IF              reduce using rule 52 (blockA -> blockB } .)
    ECHO            reduce using rule 52 (blockA -> blockB } .)
    WHILE           reduce using rule 52 (blockA -> blockB } .)
    REPLAY          reduce using rule 52 (blockA -> blockB } .)
    SAMPLE          reduce using rule 52 (blockA -> blockB } .)
    #               reduce using rule 52 (blockA -> blockB } .)
    ARR             reduce using rule 52 (blockA -> blockB } .)
    MAT             reduce using rule 52 (blockA -> blockB } .)
    RETURN          reduce using rule 52 (blockA -> blockB } .)
    ID              reduce using rule 52 (blockA -> blockB } .)
    OVAL            reduce using rule 52 (blockA -> blockB } .)
    TRIO            reduce using rule 52 (blockA -> blockB } .)
    QUAD            reduce using rule 52 (blockA -> blockB } .)
    ARC             reduce using rule 52 (blockA -> blockB } .)
    END             reduce using rule 52 (blockA -> blockB } .)
    }               reduce using rule 52 (blockA -> blockB } .)


state 210

    (58) condition -> IF ( expression ) gotoFalse block conditionA continueGo .

    MOD             reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    IF              reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ECHO            reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    WHILE           reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    REPLAY          reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    SAMPLE          reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    #               reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARR             reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    MAT             reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    RETURN          reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ID              reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    OVAL            reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    TRIO            reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    QUAD            reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    ARC             reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    END             reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)
    }               reduce using rule 58 (condition -> IF ( expression ) gotoFalse block conditionA continueGo .)


state 211

    (59) conditionA -> ELSE gotoE . block
    (51) block -> . { blockA

    {               shift and go to state 177

    block                          shift and go to state 221

state 212

    (34) id -> ID [ sumdim exp ] [ sumdim exp . ]
    (89) exp -> exp . + exp
    (90) exp -> exp . - exp
    (91) exp -> exp . * exp
    (92) exp -> exp . / exp

    ]               shift and go to state 222
    +               shift and go to state 77
    -               shift and go to state 79
    *               shift and go to state 78
    /               shift and go to state 80


state 213

    (67) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER . ] ;

    ]               shift and go to state 223


state 214

    (25) moduleA -> ( vars . ) block

    )               shift and go to state 224


state 215

    (32) type -> FLOAT .

    ID              reduce using rule 32 (type -> FLOAT .)


state 216

    (31) type -> INT .

    ID              reduce using rule 31 (type -> INT .)


state 217

    (33) type -> BOOL .

    ID              reduce using rule 33 (type -> BOOL .)


state 218

    (28) vars -> type . ID varsA

    ID              shift and go to state 225


state 219

    (24) module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .

    MOD             reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    IF              reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ECHO            reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    WHILE           reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    REPLAY          reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    SAMPLE          reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    #               reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ARR             reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    MAT             reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    RETURN          reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ID              reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    OVAL            reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    TRIO            reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    QUAD            reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    ARC             reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)
    END             reduce using rule 24 (module -> MOD typeMod # moduleID addMod insertQuadMod moduleA endMod .)


state 220

    (48) callingC -> , sumXparam callingB .

    )               reduce using rule 48 (callingC -> , sumXparam callingB .)


state 221

    (59) conditionA -> ELSE gotoE block .

    MOD             reduce using rule 59 (conditionA -> ELSE gotoE block .)
    IF              reduce using rule 59 (conditionA -> ELSE gotoE block .)
    ECHO            reduce using rule 59 (conditionA -> ELSE gotoE block .)
    WHILE           reduce using rule 59 (conditionA -> ELSE gotoE block .)
    REPLAY          reduce using rule 59 (conditionA -> ELSE gotoE block .)
    SAMPLE          reduce using rule 59 (conditionA -> ELSE gotoE block .)
    #               reduce using rule 59 (conditionA -> ELSE gotoE block .)
    ARR             reduce using rule 59 (conditionA -> ELSE gotoE block .)
    MAT             reduce using rule 59 (conditionA -> ELSE gotoE block .)
    RETURN          reduce using rule 59 (conditionA -> ELSE gotoE block .)
    ID              reduce using rule 59 (conditionA -> ELSE gotoE block .)
    OVAL            reduce using rule 59 (conditionA -> ELSE gotoE block .)
    TRIO            reduce using rule 59 (conditionA -> ELSE gotoE block .)
    QUAD            reduce using rule 59 (conditionA -> ELSE gotoE block .)
    ARC             reduce using rule 59 (conditionA -> ELSE gotoE block .)
    END             reduce using rule 59 (conditionA -> ELSE gotoE block .)
    }               reduce using rule 59 (conditionA -> ELSE gotoE block .)


state 222

    (34) id -> ID [ sumdim exp ] [ sumdim exp ] .

    =               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    <               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    >               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    AND             reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    OR              reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    +               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    -               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    *               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    /               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    )               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ;               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ,               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    (               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CTE_INTEGER     reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CTE_FLOAT       reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    TRUE            reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    FALSE           reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ID              reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    RED             reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    YELLOW          reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    BLUE            reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    GREEN           reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    BLACK           reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    WHITE           reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ORANGE          reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    PURPLE          reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    CYAN            reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)
    ]               reduce using rule 34 (id -> ID [ sumdim exp ] [ sumdim exp ] .)


state 223

    (67) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] . ;

    ;               shift and go to state 226


state 224

    (25) moduleA -> ( vars ) . block
    (51) block -> . { blockA

    {               shift and go to state 177

    block                          shift and go to state 227

state 225

    (28) vars -> type ID . varsA
    (29) varsA -> . , vars
    (30) varsA -> . empty
    (127) empty -> .

    ,               shift and go to state 229
    )               reduce using rule 127 (empty -> .)

    varsA                          shift and go to state 228
    empty                          shift and go to state 230

state 226

    (67) matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .

    IF              reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ECHO            reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    WHILE           reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    REPLAY          reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    SAMPLE          reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    #               reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARR             reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MAT             reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    RETURN          reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ID              reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    OVAL            reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    TRIO            reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    QUAD            reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    ARC             reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    }               reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    MOD             reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)
    END             reduce using rule 67 (matrix -> MAT typeDim ID [ CTE_INTEGER ] [ CTE_INTEGER ] ; .)


state 227

    (25) moduleA -> ( vars ) block .

    MOD             reduce using rule 25 (moduleA -> ( vars ) block .)
    IF              reduce using rule 25 (moduleA -> ( vars ) block .)
    ECHO            reduce using rule 25 (moduleA -> ( vars ) block .)
    WHILE           reduce using rule 25 (moduleA -> ( vars ) block .)
    REPLAY          reduce using rule 25 (moduleA -> ( vars ) block .)
    SAMPLE          reduce using rule 25 (moduleA -> ( vars ) block .)
    #               reduce using rule 25 (moduleA -> ( vars ) block .)
    ARR             reduce using rule 25 (moduleA -> ( vars ) block .)
    MAT             reduce using rule 25 (moduleA -> ( vars ) block .)
    RETURN          reduce using rule 25 (moduleA -> ( vars ) block .)
    ID              reduce using rule 25 (moduleA -> ( vars ) block .)
    OVAL            reduce using rule 25 (moduleA -> ( vars ) block .)
    TRIO            reduce using rule 25 (moduleA -> ( vars ) block .)
    QUAD            reduce using rule 25 (moduleA -> ( vars ) block .)
    ARC             reduce using rule 25 (moduleA -> ( vars ) block .)
    END             reduce using rule 25 (moduleA -> ( vars ) block .)


state 228

    (28) vars -> type ID varsA .

    )               reduce using rule 28 (vars -> type ID varsA .)


state 229

    (29) varsA -> , . vars
    (28) vars -> . type ID varsA
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . BOOL

    INT             shift and go to state 216
    FLOAT           shift and go to state 215
    BOOL            shift and go to state 217

    type                           shift and go to state 218
    vars                           shift and go to state 231

state 230

    (30) varsA -> empty .

    )               reduce using rule 30 (varsA -> empty .)


state 231

    (29) varsA -> , vars .

    )               reduce using rule 29 (varsA -> , vars .)

